
use chrono::Utc;            //to get time
use hmac::{Hmac, Mac,};	                            //so I can do the signature stuff
use sha2::{Sha256, Sha384, Sha512, Digest};	        //so I can do signature stuff
use hex;
//use reqwest::Client;                                //to actually make the request itself
//use serde_json::Result;                             //for parsing
//use serde::{Deserialize, Serialize};                //for the deserialization/serialization that I need
use serde_json::Value;
use std::error::Error;
use url::form_urlencoded;
use base64;
use base64::encode;
use serde_json::json;                               //use for gemini formatting
use uuid::Uuid;										//this is for bitstamp. part of the input for the signature needs to have a weird nonce
//use std::time::Instant;                             //this is to record time for execution
//02/09/24 - changed from std::time to tokio::time
use tokio::time::Duration;                            //for "sleep"
//use std::thread::sleep;                          
//use tokio::time::delay_for;                       //02/09/24 - tokip updated. not in it

use crate::network::NeuralNetwork;                         //to take in neuralNetwork as parameter

/*
    pub fn nothing() {
        //runs the action according to the index
        //i need to make this wait until the next state begins and then give it a reward?


    }
    //all my functions from this point on are going to be in this format:
    //pub fn [coin]_[percentage, floored]_[exchange to buy]_[exchange to sell] () {}
    pub fn eos_two_coinbase_kraken () -> f64 {
        //this will go to the [coinbase] api, get how much [2%] of my total usd is in it, buy [eos] from there
        //transfer it to [kraken] wallet api, and immediately sell all of it
        //





//------------------I MIGHT PUT THIS IN ANOTHER FUNCTION-----------------------/////
        //----I WILL HAVE TO CHANGE RETURN TYPE OF ABOVE FUNCTION OF COURSE----//
        //then it will calculate how much I spent on the coins.
        //Calculate how much my wallet in the 2nd exchange went up by
        //then subtract 2nd number - 1st number
        //to return a f64 that I will then use in my reward function

        //the reason I made it type    Option<f64> is because I don't want to prematurely
        //    assign a value to it, so if somehow it never gets assigned a value,
        //    I can then handle the situation.
        let how_much_i_spent: Option<f64>;
        match how_much_i_spent {
            Some(_) => (),
            None => panic!("how_much_i_spent   is none"),
        }
        let how_much_2nd_wallet_changed: Option<f64>;           //same thing as above^^
        match how_much_2nd_wallet_changed {
            Some(_) => (),
            None => panic!("how_much_2nd_wallet_changed    is none"),
        }

        //can't directly subtract Option types. So I need to handle the possiblity that
        //how_much_i_spent    and/or    how_much_2nd_wallet_changed    could carry no value
        //adds another layer of redundancy, which is always good
        let total_gained = match(how_much_i_spent, how_much_2nd_wallet_changed) {
            (Some(spent), Some(gained)) => Some(gained-spent),
            _ => None,
        };

        //at this point in the code, I have now returned the f64 I waned
        //now I will use this f64 for the reward function

//-----------ABOVE----------------------------------------------------------///////

    }

    pub fn eos_two_coinbase_pionex () {

    }

    pub fn eos_two_kraken_coinbase () {

    }
    //rest of eos_two
    pub fn eos_three
    //rest of eos_three

    pub fn eos_four
    //rest of eos_four

    pub fn eos_five
    //rest of eos_five

    pub fn eos_six
    //rest of eos_six

    pub fn eos_seven
    //rest of eos_seven







*/
    //function format:
    //s = sandbox
    //i# = index followed by the number
    //then coin name
    //then percentage
    //then [exchange buy]
    //then [exchange sell]

    pub fn s_i0_do_nothing(value_prior: &f64) -> Result<f64, Box<dyn Error + Send>>{
        Ok(*value_prior)
    }
    //cant use 1 through 4 because minimum Kraken buy is 0.2 SOL
    /*
    pub async fn s_i1_sol_1_coinbase_kraken(coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        let right_now = Instant::now();   //to measure execution time
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        //let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                //let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                //coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);










        //this will serve as the 2.5 second transfer speed to kraken
        //will do 3 seconds though so I have 500 miliseconds window that will make my
        //       AI be even better
        //sleep(Duration::from_secs(3));
        delay_for(Duration::from_secs(3)).await;











        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        //let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            //kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            let coinbase_taker_fee = 0.008;

            let total_spent = 0.01*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            let kraken_taker_fee = 0.0026;
            
            let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            *kraken_wallet += money_from_sell_after_fees;

            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


        //this will count as value after

            let elapsed = right_now.elapsed();
            println!("Elapsed: {:?}", elapsed);

            return Ok(value_after)

     }

     pub async fn s_i2_sol_2_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            //let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text)?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.02*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
    
    
                return Ok(value_after)
        
    }

    pub async fn s_i3_sol_3_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            //let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text)?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.03*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
    
    
                return Ok(value_after)

    }

    pub async fn s_i4_sol_4_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            //let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text)?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                //println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.04*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
    
    
            return Ok(value_after)

    }
    */
    pub async fn s_i5_sol_5_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64 )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 5 coinbase kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.05*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
            //this will count as value after
    
    
    
                return Ok(value_after)

    }

    pub async fn s_i6_sol_6_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 6 coinbase kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.06*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
                            //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
                return Ok(value_after)

    }

    pub async fn s_i7_sol_7_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 7 coinbase kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.07*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
                return Ok(value_after)

    }

    pub async fn s_i8_sol_8_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 8 coinbase kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.08*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
                return Ok(value_after)

    }

    pub async fn s_i9_sol_9_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 9 coinbase kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.09*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
                return Ok(value_after)

    }

    pub async fn s_i10_sol_10_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 10 coinbase kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.10*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
                return Ok(value_after)

    }
    //coinbase has 10 dollar minimum order size:
//https://www.businessinsider.com/personal-finance/bitstamp-crypto-exchange-review#:~:text=Bitstamp%20has%20a%20%240%20minimum,of%20more%20than%20%24100%20million).
    /*
    pub async fn s_i11_sol_1_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.01*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
    
                return Ok(value_after)

    }

    pub async fn s_i12_sol_2_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.02*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
    
                return Ok(value_after)

    }
    */
    //begin removal
    pub async fn s_i13_sol_3_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 3 coinbase bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.03*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
                return Ok(value_after)

    }

    pub async fn s_i14_sol_4_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 4 coinbase bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.04*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i15_sol_5_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 5 coinbase bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.05*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i16_sol_6_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 6 coinbase bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.06*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
                return Ok(value_after)

    }

    pub async fn s_i17_sol_7_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 7 coinbase bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.07*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i18_sol_8_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 8 coinbase bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.08*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }

    pub async fn s_i19_sol_9_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 9 coinbase bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.09*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


    
                return Ok(value_after)

    }

    pub async fn s_i20_sol_10_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 10 coinbase bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.10*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 62
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }
    //end removal
    //gemini has withdraw minimums of 10 dollars
    /*
    pub async fn s_i21_sol_1_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);




        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.01;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
    
                return Ok(value_after)

    }    

    pub async fn s_i22_sol_2_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.02;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
    
                return Ok(value_after)

    }
    */
    pub async fn s_i23_sol_3_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);


        //need to GET AMOUNT AND PRICE SO i CAN PUT IT INTO THE INPUT AND MNAKE ANEW INPUT FRUNCITON



        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 3 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.03;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }

    pub async fn s_i24_sol_4_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);






        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 4 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.04;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }

    pub async fn s_i25_sol_5_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 5 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.05;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


    
                return Ok(value_after)

    }

    pub async fn s_i26_sol_6_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 6 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.06;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }

    pub async fn s_i27_sol_7_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 7 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.07;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }

    pub async fn s_i28_sol_8_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 8 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.08;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i29_sol_9_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 9 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.09;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i30_sol_10_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 10 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.10;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }
    //cant use 1 through 4 because minimum Kraken buy is 0.2 SOL
    /*
    pub async fn s_i31_sol_1_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.01;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }

    pub async fn s_i32_sol_2_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.02;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }

    pub async fn s_i33_sol_3_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.03;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }

    pub async fn s_i34_sol_4_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.04;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }
    */
    pub async fn s_i35_sol_5_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 5 gemini kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.05;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is kraken and gemini being updated, I will update:
                //  60, 63, 64
                let indices = [60, 63, 64];
                let new_values = [value_after, *kraken_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }

    pub async fn s_i36_sol_6_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);






        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 6 gemini kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.06;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is kraken and gemini being updated, I will update:
                //  60, 63, 64
                let indices = [60, 63, 64];
                let new_values = [value_after, *kraken_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i37_sol_7_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);






        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 7 gemini kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.07;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is kraken and gemini being updated, I will update:
                //  60, 63, 64
                let indices = [60, 63, 64];
                let new_values = [value_after, *kraken_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


    
                return Ok(value_after)

    }

    pub async fn s_i38_sol_8_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);






        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 8 gemini kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.08;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is kraken and gemini being updated, I will update:
                //  60, 63, 64
                let indices = [60, 63, 64];
                let new_values = [value_after, *kraken_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }

    pub async fn s_i39_sol_9_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);






        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 9 gemini kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).expect("couldnt get value from kraken responese text");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.09;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is kraken and gemini being updated, I will update:
                //  60, 63, 64
                let indices = [60, 63, 64];
                let new_values = [value_after, *kraken_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i40_sol_10_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 10 gemini kraken: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).expect("couldn't parse kraken in s_i40_sol_10_gemini_kraken");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.10;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is kraken and gemini being updated, I will update:
                //  60, 63, 64
                let indices = [60, 63, 64];
                let new_values = [value_after, *kraken_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }
    //gemini has withdraw minimums of 10 dollars: 
    //      https://www.gemini.com/legal/user-agreement#section-fiat-currency-withdrawals
    /*
    pub async fn s_i41_sol_1_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.01;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }

    pub async fn s_i42_sol_2_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.02;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }
    */
    //begin removal
    pub async fn s_i43_sol_3_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 3 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.03;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and gemini being updated, I will update:
                //  60, 62, 64
                let indices = [60, 62, 64];
                let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }

    pub async fn s_i44_sol_4_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 4 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.04;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and gemini being updated, I will update:
                //  60, 62, 64
                let indices = [60, 62, 64];
                let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i45_sol_5_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 5 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.05;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and gemini being updated, I will update:
                //  60, 62, 64
                let indices = [60, 62, 64];
                let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;

                return Ok(value_after)

    }

    pub async fn s_i46_sol_6_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 6 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.06;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and gemini being updated, I will update:
                //  60, 62, 64
                let indices = [60, 62, 64];
                let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i47_sol_7_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 7 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.07;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and gemini being updated, I will update:
                //  60, 62, 64
                let indices = [60, 62, 64];
                let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;

                return Ok(value_after)

    }

    pub async fn s_i48_sol_8_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 8 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.08;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    

                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and gemini being updated, I will update:
                //  60, 62, 64
                let indices = [60, 62, 64];
                let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;

                return Ok(value_after)

    }

    pub async fn s_i49_sol_9_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 9 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.09;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and gemini being updated, I will update:
                //  60, 62, 64
                let indices = [60, 62, 64];
                let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;

    
                return Ok(value_after)

    }

    pub async fn s_i50_sol_10_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 10 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.10;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and gemini being updated, I will update:
                //  60, 62, 64
                let indices = [60, 62, 64];
                let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }
    //end removal//
    //cant use 1 through 4 because minimum Kraken buy is 0.2 SOL
    /*
    pub async fn s_i51_sol_1_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.01;  //aka 1 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol = money_going_to_sol_after_fees/kraken_buy_price_ask;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);

            return Ok(value_after)

     }

     pub async fn s_i52_sol_2_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.02;  //aka 2 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol = money_going_to_sol_after_fees/kraken_buy_price_ask;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);

            return Ok(value_after)

     }

     pub async fn s_i53_sol_3_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.03;  //aka 3 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol = money_going_to_sol_after_fees/kraken_buy_price_ask;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);

            return Ok(value_after)

     }

     pub async fn s_i54_sol_4_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol = money_going_to_sol_after_fees/kraken_buy_price_ask;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);

            return Ok(value_after)

     }
     */
     pub async fn s_i55_sol_5_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 5 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;

            
            return Ok(value_after)

     }

     pub async fn s_i56_sol_6_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 6 kraken coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.06;  //aka 6 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;

            return Ok(value_after)

     }

     pub async fn s_i57_sol_7_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 7 kraken coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;

            return Ok(value_after)

     }

     pub async fn s_i58_sol_8_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 8 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.08;  //aka 8 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)

     }

     pub async fn s_i59_sol_9_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 9 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.09;  //aka 9 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)

     }

     pub async fn s_i60_sol_10_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 10 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.10;  //aka 10 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)

     }
     //cant use 1 through 4 because minimum Kraken buy is 0.2 SOL
     /*
     pub async fn s_i61_sol_1_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.01;  //aka 1 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);

            return Ok(value_after)

    }

    pub async fn s_i62_sol_2_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.02;  //aka 2 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);

            return Ok(value_after)

    }

    pub async fn s_i63_sol_3_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.03;  //aka 3 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);

            return Ok(value_after)

    }

    pub async fn s_i64_sol_4_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();












        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);

            return Ok(value_after)

    }
    */
    //begin removal
    pub async fn s_i65_sol_5_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 5 kraken bitstamp: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //*coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and kraken being updated, I will update:
                //  60, 62, 63
                let indices = [60, 62, 63];
                let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)

    }

    pub async fn s_i66_sol_6_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 6 kraken bitstamp: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.06;  //aka 6 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //*coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and kraken being updated, I will update:
                //  60, 62, 63
                let indices = [60, 62, 63];
                let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)

    }

    pub async fn s_i67_sol_7_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 7 kraken bitstamp: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //*coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);


            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)

    }

    pub async fn s_i68_sol_8_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();














        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 8 kraken bitstamp: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.08;  //aka 8 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //*coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)

    }

    pub async fn s_i69_sol_9_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 9 kraken bitstamp: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.09;  //aka 9 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //*coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)

    }

    pub async fn s_i70_sol_10_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 10 kraken bitstamp: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.10;  //aka 10 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //*coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)

    }
    //end removal//
    pub async fn s_i75_xlm_5_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 5 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
                let fraction_of_wallet_used = 0.05;
                let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
                return Ok(value_after)

    }

    pub async fn s_i76_xlm_6_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 6 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
                let fraction_of_wallet_used = 0.06;
                let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i77_xlm_7_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 7 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
                let fraction_of_wallet_used = 0.07;
                let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
                return Ok(value_after)

    }

    pub async fn s_i78_xlm_8_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 8 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
                let fraction_of_wallet_used = 0.08;
                let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i79_xlm_9_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 9 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
                let fraction_of_wallet_used = 0.09;
                let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i80_xlm_10_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("xlm 10 coinbase kraken: 5 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(5);
            tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
                let fraction_of_wallet_used = 0.10;
                let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i83_xlm_3_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 3 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
            let coinbase_taker_fee = 0.008;
            let fraction_of_wallet_used = 0.03;
            let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 62
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i84_xlm_4_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 4 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
            let coinbase_taker_fee = 0.008;
            let fraction_of_wallet_used = 0.04;
            let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 62
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i85_xlm_5_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 5 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
            let coinbase_taker_fee = 0.008;
            let fraction_of_wallet_used = 0.05;
            let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 62
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i86_xlm_6_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 6 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
            let coinbase_taker_fee = 0.008;
            let fraction_of_wallet_used = 0.06;
            let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 62
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

                return Ok(value_after)

    }

    pub async fn s_i87_xlm_7_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 7 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
            let coinbase_taker_fee = 0.008;
            let fraction_of_wallet_used = 0.07;
            let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 62
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i88_xlm_8_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 8 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
            let coinbase_taker_fee = 0.008;
            let fraction_of_wallet_used = 0.08;
            let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 62
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i89_xlm_9_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 9 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
            let coinbase_taker_fee = 0.008;
            let fraction_of_wallet_used = 0.09;
            let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 62
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;

                return Ok(value_after)

    }

    pub async fn s_i90_xlm_10_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 10 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
            let coinbase_taker_fee = 0.008;
            let fraction_of_wallet_used = 0.10;
            let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 62
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
                return Ok(value_after)

    }

    pub async fn s_i95_xlm_5_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            //let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
                //println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }




    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 5 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price_bid = 0.0;
            //let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    //let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


            //kraken calculations - buy
                let kraken_taker_fee = 0.0026;
                let fraction_of_wallet_used = 0.05;
                let total_spent = fraction_of_wallet_used*(*kraken_wallet);
                let fee_for_purchase = total_spent*kraken_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of kraken wallet
                *kraken_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            //coinbase calculations - sell
                let coinbase_taker_fee = 0.008;
                    
                let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *coinbase_wallet += money_from_sell_after_fees;

                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            //this will count as value after
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
        
    
            return Ok(value_after)

    }

    pub async fn s_i96_xlm_6_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            //let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
                //println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }




    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 6 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price_bid = 0.0;
            //let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    //let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


            //kraken calculations - buy
                let kraken_taker_fee = 0.0026;
                let fraction_of_wallet_used = 0.06;
                let total_spent = fraction_of_wallet_used*(*kraken_wallet);
                let fee_for_purchase = total_spent*kraken_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of kraken wallet
                *kraken_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            //coinbase calculations - sell
                let coinbase_taker_fee = 0.008;
                    
                let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *coinbase_wallet += money_from_sell_after_fees;

                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            //this will count as value after
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
    
            return Ok(value_after)

    }

    pub async fn s_i97_xlm_7_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            //let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
                //println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }




    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 7 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price_bid = 0.0;
            //let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    //let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


            //kraken calculations - buy
                let kraken_taker_fee = 0.0026;
                let fraction_of_wallet_used = 0.07;
                let total_spent = fraction_of_wallet_used*(*kraken_wallet);
                let fee_for_purchase = total_spent*kraken_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of kraken wallet
                *kraken_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            //coinbase calculations - sell
                let coinbase_taker_fee = 0.008;
                    
                let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *coinbase_wallet += money_from_sell_after_fees;

                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            //this will count as value after
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
            return Ok(value_after)

    }

    pub async fn s_i98_xlm_8_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            //let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
                //println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }




    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 8 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price_bid = 0.0;
            //let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    //let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


            //kraken calculations - buy
                let kraken_taker_fee = 0.0026;
                let fraction_of_wallet_used = 0.08;
                let total_spent = fraction_of_wallet_used*(*kraken_wallet);
                let fee_for_purchase = total_spent*kraken_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of kraken wallet
                *kraken_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            //coinbase calculations - sell
                let coinbase_taker_fee = 0.008;
                    
                let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *coinbase_wallet += money_from_sell_after_fees;

                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            //this will count as value after
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
            return Ok(value_after)

    }

    pub async fn s_i99_xlm_9_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            //let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
                //println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }




    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 9 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price_bid = 0.0;
            //let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    //let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


            //kraken calculations - buy
                let kraken_taker_fee = 0.0026;
                let fraction_of_wallet_used = 0.09;
                let total_spent = fraction_of_wallet_used*(*kraken_wallet);
                let fee_for_purchase = total_spent*kraken_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of kraken wallet
                *kraken_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            //coinbase calculations - sell
                let coinbase_taker_fee = 0.008;
                    
                let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *coinbase_wallet += money_from_sell_after_fees;

                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            //this will count as value after
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
            return Ok(value_after)

    }

    pub async fn s_i100_xlm_10_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut kraken_buy_price_ask = 0.0;
            //let mut kraken_sell_price_bid = 0.0;
            if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
                //println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }




    
    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 10 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            let mut coinbase_sell_price_bid = 0.0;
            //let mut coinbase_buy_price_ask = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    //let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


            //kraken calculations - buy
                let kraken_taker_fee = 0.0026;
                let fraction_of_wallet_used = 0.10;
                let total_spent = fraction_of_wallet_used*(*kraken_wallet);
                let fee_for_purchase = total_spent*kraken_taker_fee;
                let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                //new state of kraken wallet
                *kraken_wallet -= total_spent;
                let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            //coinbase calculations - sell
                let coinbase_taker_fee = 0.008;
                    
                let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *coinbase_wallet += money_from_sell_after_fees;

                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            //this will count as value after
    
                    //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 63];
                let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
            return Ok(value_after)

    }

    pub async fn s_i105_xlm_5_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        //let mut kraken_sell_price_bid = 0.0;
        if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }









                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}", bitstamp_sell_price_bid, );
        //println!("Ask: {}", bitstamp_buy_price_ask);
        //println!("Bitstamp response:\n{:?}", bitstamp_response_text);






        //kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_used = 0.05;
        let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        //new state of kraken wallet
        *kraken_wallet -= total_spent;
        let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        //bitstamp calculations
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;



        let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is bitstamp and kraken being updated, I will update:
        //  60, 62, 63
        let indices = [60, 62, 63];
        let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;
        
        return Ok(value_after)


    }

    pub async fn s_i106_xlm_6_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        //let mut kraken_sell_price_bid = 0.0;
        if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }









                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}", bitstamp_sell_price_bid, );
        //println!("Ask: {}", bitstamp_buy_price_ask);
        //println!("Bitstamp response:\n{:?}", bitstamp_response_text);






        //kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_used = 0.06;
        let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        //new state of kraken wallet
        *kraken_wallet -= total_spent;
        let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        //bitstamp calculations
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;



        let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
        //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is bitstamp and kraken being updated, I will update:
        //  60, 62, 63
        let indices = [60, 62, 63];
        let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;
    
    return Ok(value_after)


    }

    pub async fn s_i107_xlm_7_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        //let mut kraken_sell_price_bid = 0.0;
        if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }









                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}", bitstamp_sell_price_bid, );
        //println!("Ask: {}", bitstamp_buy_price_ask);
        //println!("Bitstamp response:\n{:?}", bitstamp_response_text);






        //kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_used = 0.07;
        let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        //new state of kraken wallet
        *kraken_wallet -= total_spent;
        let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        //bitstamp calculations
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;



        let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
        //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is bitstamp and kraken being updated, I will update:
        //  60, 62, 63
        let indices = [60, 62, 63];
        let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;
    
    return Ok(value_after)


    }

    pub async fn s_i108_xlm_8_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        //let mut kraken_sell_price_bid = 0.0;
        if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }









                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}", bitstamp_sell_price_bid, );
        //println!("Ask: {}", bitstamp_buy_price_ask);
        //println!("Bitstamp response:\n{:?}", bitstamp_response_text);






        //kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_used = 0.08;
        let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        //new state of kraken wallet
        *kraken_wallet -= total_spent;
        let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        //bitstamp calculations
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;



        let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
        //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is bitstamp and kraken being updated, I will update:
        //  60, 62, 63
        let indices = [60, 62, 63];
        let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;
    
    return Ok(value_after)


    }

    pub async fn s_i109_xlm_9_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        //let mut kraken_sell_price_bid = 0.0;
        if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }









                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}", bitstamp_sell_price_bid, );
        //println!("Ask: {}", bitstamp_buy_price_ask);
        //println!("Bitstamp response:\n{:?}", bitstamp_response_text);






        //kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_used = 0.09;
        let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        //new state of kraken wallet
        *kraken_wallet -= total_spent;
        let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        //bitstamp calculations
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;



        let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
        //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is bitstamp and kraken being updated, I will update:
        //  60, 62, 63
        let indices = [60, 62, 63];
        let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;
    
    return Ok(value_after)


    }

    pub async fn s_i110_xlm_10_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        let mut kraken_buy_price_ask = 0.0;
        //let mut kraken_sell_price_bid = 0.0;
        if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }









                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}", bitstamp_sell_price_bid, );
        //println!("Ask: {}", bitstamp_buy_price_ask);
        //println!("Bitstamp response:\n{:?}", bitstamp_response_text);






        //kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_used = 0.10;
        let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        //new state of kraken wallet
        *kraken_wallet -= total_spent;
        let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        //bitstamp calculations
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;



        let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is bitstamp and kraken being updated, I will update:
        //  60, 62, 63
        let indices = [60, 62, 63];
        let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;
    
    return Ok(value_after)


    }
//xrp
    //coinbase bitstamp = 3 AND UP for min of 10 USD on Bit and Coin
    pub async fn s_i113_xrp_3_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);

            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};

            let response = client.execute(request).await.expect("couldn't build response");
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


            let response_text = response.text().await.expect("couldn't build response_text");

            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;

            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                    let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                    coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                    let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);









            println!("xrp 3 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        println!("Bitstamp:\n{:?}", bitstamp_response_text);




            //coinbase calculations
                let coinbase_taker_fee = 0.008;

                let total_spent = 0.03*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;

                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i114_xrp_4_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);

            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};

            let response = client.execute(request).await.expect("couldn't build response");
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


            let response_text = response.text().await.expect("couldn't build response_text");

            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;

            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                    let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                    coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                    let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);









            println!("xrp 4 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        println!("Bitstamp:\n{:?}", bitstamp_response_text);




            //coinbase calculations
                let coinbase_taker_fee = 0.008;

                let total_spent = 0.04*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;

                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i115_xrp_5_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);

            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};

            let response = client.execute(request).await.expect("couldn't build response");
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


            let response_text = response.text().await.expect("couldn't build response_text");

            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;

            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                    let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                    coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                    let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);









            println!("xrp 5 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        println!("Bitstamp:\n{:?}", bitstamp_response_text);




            //coinbase calculations
                let coinbase_taker_fee = 0.008;

                let total_spent = 0.05*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;

                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i116_xrp_6_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);

            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};

            let response = client.execute(request).await.expect("couldn't build response");
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


            let response_text = response.text().await.expect("couldn't build response_text");

            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;

            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                    let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                    coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                    let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);









            println!("xrp 6 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        println!("Bitstamp:\n{:?}", bitstamp_response_text);




            //coinbase calculations
                let coinbase_taker_fee = 0.008;

                let total_spent = 0.06*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;

                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i117_xrp_7_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);

            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};

            let response = client.execute(request).await.expect("couldn't build response");
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


            let response_text = response.text().await.expect("couldn't build response_text");

            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;

            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                    let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                    coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                    let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);









            println!("xrp 7 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        println!("Bitstamp:\n{:?}", bitstamp_response_text);




            //coinbase calculations
                let coinbase_taker_fee = 0.008;

                let total_spent = 0.07*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;

                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i118_xrp_8_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);

            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};

            let response = client.execute(request).await.expect("couldn't build response");
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


            let response_text = response.text().await.expect("couldn't build response_text");

            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;

            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                    let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                    coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                    let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);









            println!("xrp 8 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        println!("Bitstamp:\n{:?}", bitstamp_response_text);




            //coinbase calculations
                let coinbase_taker_fee = 0.008;

                let total_spent = 0.08*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;

                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i119_xrp_9_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);

            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};

            let response = client.execute(request).await.expect("couldn't build response");
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


            let response_text = response.text().await.expect("couldn't build response_text");

            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;

            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                    let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                    coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                    let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);









            println!("xrp 9 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        println!("Bitstamp:\n{:?}", bitstamp_response_text);




            //coinbase calculations
                let coinbase_taker_fee = 0.008;

                let total_spent = 0.09*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;

                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }

    pub async fn s_i120_xrp_10_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);

            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()
            .expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};

            let response = client.execute(request).await.expect("couldn't build response");
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


            let response_text = response.text().await.expect("couldn't build response_text");

            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            let mut coinbase_sell_price_bid = 0.0;
            let mut coinbase_buy_price_ask = 0.0;

            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                    let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                    coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                    let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                    //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
                }
            }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);









            println!("xrp 10 coinbase bitstamp: 8 sec delay...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        println!("Bitstamp:\n{:?}", bitstamp_response_text);




            //coinbase calculations
                let coinbase_taker_fee = 0.008;

                let total_spent = 0.10*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;

                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and kraken being updated, I will update:
                //  60, 61, 63
                let indices = [60, 61, 62];
                let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;


                return Ok(value_after)

    }
//gemini bitstamp   = 3 AND UP for min of 10 USD on Gemini and Bit
    pub async fn s_i123_xrp_3_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
            let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build()
                    .expect("couldn't build gemini request");
        
        
            let gemini_response = client.execute(gemini_request).await
                                    .expect("Failed to execute Gemini request");
            let gemini_response_text = gemini_response.text().await
                                    .expect("Failed to turn response into text");
            let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                    .expect("Failed to parse JSON");
            let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            //CAN ONLY BUY. NOT SELL
            let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        





            println!("xrp 3 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

            let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                .header("X-Auth-Signature", bitstamp_signature)
                .header("X-Auth-Nonce", bitstamp_nonce)
                .header("X-Auth-Timestamp", bitstamp_timestamp)
                .header("X-Auth-Version", "v2")
                //.header("Content-Type", content_type)
                //.body(payload_string)
                .build()
                .expect("\ncould not build bitstamp_request");

            let bitstamp_response = client.execute(bitstamp_request).await
                .expect("Failed to execute Bitstamp request");
            let bitstamp_response_text = bitstamp_response.text().await
                .expect("Failed to turn response into text");
            //probably dont need "bitstamp" once we transfer this to the actual function
            let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            .expect("Failed to parse JSON");

            // Extract the bid and ask values
            let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            println!("Bitstamp:\n{:?}", bitstamp_response_text);




                //gemini calculations for buy 
                    //this should equal 0.4%
                    let gemini_taker_fee = 0.004;
                    let fraction_of_wallet_im_using = 0.03;

                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                    let fee_for_purchase = total_spent*gemini_taker_fee;
                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                    //new state of gemini wallet below
                    *gemini_wallet -= total_spent;
                    let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

                //bitstamp calculations - sell
                    let bitstamp_taker_fee = 0.004;
                    let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                    let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                    *bitstamp_wallet += money_from_sell_after_fees;

                    //this will count as value after
                    let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                    //println!("value after:\n\t{}",value_after);
        
    
                    //value_after = 60
                    //coinbase = 61
                    //bitstamp = 62
                    //kraken = 63
                    //gemini = 64
                    //since this is bitstamp and gemini being updated, I will update:
                    //  60, 62, 64
                    let indices = [60, 62, 64];
                    let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                    //01/24/24 - removed and added:
                        //neural_network.update_input(&indices, &new_values);
                        //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                        //neural_network.update_input(&indices, &transformed_values).await;
                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                        neural_network.update_input(&indices, &scaled_values).await;
    
        
        return Ok(value_after)
    }

    pub async fn s_i124_xrp_4_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
            let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build()
                    .expect("couldn't build gemini request");
        
        
            let gemini_response = client.execute(gemini_request).await
                                    .expect("Failed to execute Gemini request");
            let gemini_response_text = gemini_response.text().await
                                    .expect("Failed to turn response into text");
            let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                    .expect("Failed to parse JSON");
            let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            //CAN ONLY BUY. NOT SELL
            let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        




            println!("xrp 4 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

            let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                .header("X-Auth-Signature", bitstamp_signature)
                .header("X-Auth-Nonce", bitstamp_nonce)
                .header("X-Auth-Timestamp", bitstamp_timestamp)
                .header("X-Auth-Version", "v2")
                //.header("Content-Type", content_type)
                //.body(payload_string)
                .build()
                .expect("\ncould not build bitstamp_request");

            let bitstamp_response = client.execute(bitstamp_request).await
                .expect("Failed to execute Bitstamp request");
            let bitstamp_response_text = bitstamp_response.text().await
                .expect("Failed to turn response into text");
            //probably dont need "bitstamp" once we transfer this to the actual function
            let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            .expect("Failed to parse JSON");

            // Extract the bid and ask values
            let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            println!("Bitstamp:\n{:?}", bitstamp_response_text);




                //gemini calculations for buy 
                    //this should equal 0.4%
                    let gemini_taker_fee = 0.004;
                    let fraction_of_wallet_im_using = 0.04;

                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                    let fee_for_purchase = total_spent*gemini_taker_fee;
                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                    //new state of gemini wallet below
                    *gemini_wallet -= total_spent;
                    let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

                //bitstamp calculations - sell
                    let bitstamp_taker_fee = 0.004;
                    let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                    let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                    *bitstamp_wallet += money_from_sell_after_fees;

                    //this will count as value after
                    let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                    //println!("value after:\n\t{}",value_after);
        
    
                    //value_after = 60
                    //coinbase = 61
                    //bitstamp = 62
                    //kraken = 63
                    //gemini = 64
                    //since this is bitstamp and gemini being updated, I will update:
                    //  60, 62, 64
                    let indices = [60, 62, 64];
                    let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                    //01/24/24 - removed and added:
                        //neural_network.update_input(&indices, &new_values);
                        //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                        //neural_network.update_input(&indices, &transformed_values).await;
                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                        neural_network.update_input(&indices, &scaled_values).await;
    
        
        return Ok(value_after)
    }

    pub async fn s_i125_xrp_5_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
            let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build()
                    .expect("couldn't build gemini request");
        
        
            let gemini_response = client.execute(gemini_request).await
                                    .expect("Failed to execute Gemini request");
            let gemini_response_text = gemini_response.text().await
                                    .expect("Failed to turn response into text");
            let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                    .expect("Failed to parse JSON");
            let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            //CAN ONLY BUY. NOT SELL
            let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        




            println!("xrp 5 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

            let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                .header("X-Auth-Signature", bitstamp_signature)
                .header("X-Auth-Nonce", bitstamp_nonce)
                .header("X-Auth-Timestamp", bitstamp_timestamp)
                .header("X-Auth-Version", "v2")
                //.header("Content-Type", content_type)
                //.body(payload_string)
                .build()
                .expect("\ncould not build bitstamp_request");

            let bitstamp_response = client.execute(bitstamp_request).await
                .expect("Failed to execute Bitstamp request");
            let bitstamp_response_text = bitstamp_response.text().await
                .expect("Failed to turn response into text");
            //probably dont need "bitstamp" once we transfer this to the actual function
            let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            .expect("Failed to parse JSON");

            // Extract the bid and ask values
            let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            println!("Bitstamp:\n{:?}", bitstamp_response_text);




                //gemini calculations for buy 
                    //this should equal 0.4%
                    let gemini_taker_fee = 0.004;
                    let fraction_of_wallet_im_using = 0.05;

                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                    let fee_for_purchase = total_spent*gemini_taker_fee;
                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                    //new state of gemini wallet below
                    *gemini_wallet -= total_spent;
                    let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

                //bitstamp calculations - sell
                    let bitstamp_taker_fee = 0.004;
                    let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                    let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                    *bitstamp_wallet += money_from_sell_after_fees;

                    //this will count as value after
                    let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                    //println!("value after:\n\t{}",value_after);
        
    
                    //value_after = 60
                    //coinbase = 61
                    //bitstamp = 62
                    //kraken = 63
                    //gemini = 64
                    //since this is bitstamp and gemini being updated, I will update:
                    //  60, 62, 64
                    let indices = [60, 62, 64];
                    let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                    //01/24/24 - removed and added:
                        //neural_network.update_input(&indices, &new_values);
                        //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                        //neural_network.update_input(&indices, &transformed_values).await;
                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                        neural_network.update_input(&indices, &scaled_values).await;
    
        
        return Ok(value_after)
    }

    pub async fn s_i126_xrp_6_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
            let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build()
                    .expect("couldn't build gemini request");
        
        
            let gemini_response = client.execute(gemini_request).await
                                    .expect("Failed to execute Gemini request");
            let gemini_response_text = gemini_response.text().await
                                    .expect("Failed to turn response into text");
            let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                    .expect("Failed to parse JSON");
            let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            //CAN ONLY BUY. NOT SELL
            let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        




            println!("xrp 6 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

            let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                .header("X-Auth-Signature", bitstamp_signature)
                .header("X-Auth-Nonce", bitstamp_nonce)
                .header("X-Auth-Timestamp", bitstamp_timestamp)
                .header("X-Auth-Version", "v2")
                //.header("Content-Type", content_type)
                //.body(payload_string)
                .build()
                .expect("\ncould not build bitstamp_request");

            let bitstamp_response = client.execute(bitstamp_request).await
                .expect("Failed to execute Bitstamp request");
            let bitstamp_response_text = bitstamp_response.text().await
                .expect("Failed to turn response into text");
            //probably dont need "bitstamp" once we transfer this to the actual function
            let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            .expect("Failed to parse JSON");

            // Extract the bid and ask values
            let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            println!("Bitstamp:\n{:?}", bitstamp_response_text);




                //gemini calculations for buy 
                    //this should equal 0.4%
                    let gemini_taker_fee = 0.004;
                    let fraction_of_wallet_im_using = 0.06;

                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                    let fee_for_purchase = total_spent*gemini_taker_fee;
                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                    //new state of gemini wallet below
                    *gemini_wallet -= total_spent;
                    let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

                //bitstamp calculations - sell
                    let bitstamp_taker_fee = 0.004;
                    let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                    let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                    *bitstamp_wallet += money_from_sell_after_fees;

                    //this will count as value after
                    let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                    //println!("value after:\n\t{}",value_after);
        
    
                    //value_after = 60
                    //coinbase = 61
                    //bitstamp = 62
                    //kraken = 63
                    //gemini = 64
                    //since this is bitstamp and gemini being updated, I will update:
                    //  60, 62, 64
                    let indices = [60, 62, 64];
                    let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                    //01/24/24 - removed and added:
                        //neural_network.update_input(&indices, &new_values);
                        //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                        //neural_network.update_input(&indices, &transformed_values).await;
                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                        neural_network.update_input(&indices, &scaled_values).await;
    
        
        return Ok(value_after)
    }

    pub async fn s_i127_xrp_7_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
            let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build()
                    .expect("couldn't build gemini request");
        
        
            let gemini_response = client.execute(gemini_request).await
                                    .expect("Failed to execute Gemini request");
            let gemini_response_text = gemini_response.text().await
                                    .expect("Failed to turn response into text");
            let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                    .expect("Failed to parse JSON");
            let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            //CAN ONLY BUY. NOT SELL
            let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        




            println!("xrp 7 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

            let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                .header("X-Auth-Signature", bitstamp_signature)
                .header("X-Auth-Nonce", bitstamp_nonce)
                .header("X-Auth-Timestamp", bitstamp_timestamp)
                .header("X-Auth-Version", "v2")
                //.header("Content-Type", content_type)
                //.body(payload_string)
                .build()
                .expect("\ncould not build bitstamp_request");

            let bitstamp_response = client.execute(bitstamp_request).await
                .expect("Failed to execute Bitstamp request");
            let bitstamp_response_text = bitstamp_response.text().await
                .expect("Failed to turn response into text");
            //probably dont need "bitstamp" once we transfer this to the actual function
            let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            .expect("Failed to parse JSON");

            // Extract the bid and ask values
            let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            println!("Bitstamp:\n{:?}", bitstamp_response_text);




                //gemini calculations for buy 
                    //this should equal 0.4%
                    let gemini_taker_fee = 0.004;
                    let fraction_of_wallet_im_using = 0.07;

                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                    let fee_for_purchase = total_spent*gemini_taker_fee;
                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                    //new state of gemini wallet below
                    *gemini_wallet -= total_spent;
                    let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

                //bitstamp calculations - sell
                    let bitstamp_taker_fee = 0.004;
                    let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                    let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                    *bitstamp_wallet += money_from_sell_after_fees;

                    //this will count as value after
                    let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                    //println!("value after:\n\t{}",value_after);
        
    
                    //value_after = 60
                    //coinbase = 61
                    //bitstamp = 62
                    //kraken = 63
                    //gemini = 64
                    //since this is bitstamp and gemini being updated, I will update:
                    //  60, 62, 64
                    let indices = [60, 62, 64];
                    let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                    //01/24/24 - removed and added:
                        //neural_network.update_input(&indices, &new_values);
                        //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                        //neural_network.update_input(&indices, &transformed_values).await;
                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                        neural_network.update_input(&indices, &scaled_values).await;
    
        
        return Ok(value_after)
    }

    pub async fn s_i128_xrp_8_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
            let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build()
                    .expect("couldn't build gemini request");
        
        
            let gemini_response = client.execute(gemini_request).await
                                    .expect("Failed to execute Gemini request");
            let gemini_response_text = gemini_response.text().await
                                    .expect("Failed to turn response into text");
            let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                    .expect("Failed to parse JSON");
            let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            //CAN ONLY BUY. NOT SELL
            let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        





            println!("xrp 8 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

            let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                .header("X-Auth-Signature", bitstamp_signature)
                .header("X-Auth-Nonce", bitstamp_nonce)
                .header("X-Auth-Timestamp", bitstamp_timestamp)
                .header("X-Auth-Version", "v2")
                //.header("Content-Type", content_type)
                //.body(payload_string)
                .build()
                .expect("\ncould not build bitstamp_request");

            let bitstamp_response = client.execute(bitstamp_request).await
                .expect("Failed to execute Bitstamp request");
            let bitstamp_response_text = bitstamp_response.text().await
                .expect("Failed to turn response into text");
            //probably dont need "bitstamp" once we transfer this to the actual function
            let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            .expect("Failed to parse JSON");

            // Extract the bid and ask values
            let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            println!("Bitstamp:\n{:?}", bitstamp_response_text);




                //gemini calculations for buy 
                    //this should equal 0.4%
                    let gemini_taker_fee = 0.004;
                    let fraction_of_wallet_im_using = 0.08;

                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                    let fee_for_purchase = total_spent*gemini_taker_fee;
                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                    //new state of gemini wallet below
                    *gemini_wallet -= total_spent;
                    let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

                //bitstamp calculations - sell
                    let bitstamp_taker_fee = 0.004;
                    let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                    let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                    *bitstamp_wallet += money_from_sell_after_fees;

                    //this will count as value after
                    let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                    //println!("value after:\n\t{}",value_after);
        
    
                    //value_after = 60
                    //coinbase = 61
                    //bitstamp = 62
                    //kraken = 63
                    //gemini = 64
                    //since this is bitstamp and gemini being updated, I will update:
                    //  60, 62, 64
                    let indices = [60, 62, 64];
                    let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                    //01/24/24 - removed and added:
                        //neural_network.update_input(&indices, &new_values);
                        //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                        //neural_network.update_input(&indices, &transformed_values).await;
                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                        neural_network.update_input(&indices, &scaled_values).await;
    
        
        return Ok(value_after)
    }

    pub async fn s_i129_xrp_9_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
            let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build()
                    .expect("couldn't build gemini request");
        
        
            let gemini_response = client.execute(gemini_request).await
                                    .expect("Failed to execute Gemini request");
            let gemini_response_text = gemini_response.text().await
                                    .expect("Failed to turn response into text");
            let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                    .expect("Failed to parse JSON");
            let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            //CAN ONLY BUY. NOT SELL
            let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        




            println!("xrp 9 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

            let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                .header("X-Auth-Signature", bitstamp_signature)
                .header("X-Auth-Nonce", bitstamp_nonce)
                .header("X-Auth-Timestamp", bitstamp_timestamp)
                .header("X-Auth-Version", "v2")
                //.header("Content-Type", content_type)
                //.body(payload_string)
                .build()
                .expect("\ncould not build bitstamp_request");

            let bitstamp_response = client.execute(bitstamp_request).await
                .expect("Failed to execute Bitstamp request");
            let bitstamp_response_text = bitstamp_response.text().await
                .expect("Failed to turn response into text");
            //probably dont need "bitstamp" once we transfer this to the actual function
            let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            .expect("Failed to parse JSON");

            // Extract the bid and ask values
            let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            println!("Bitstamp:\n{:?}", bitstamp_response_text);




                //gemini calculations for buy 
                    //this should equal 0.4%
                    let gemini_taker_fee = 0.004;
                    let fraction_of_wallet_im_using = 0.09;

                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                    let fee_for_purchase = total_spent*gemini_taker_fee;
                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                    //new state of gemini wallet below
                    *gemini_wallet -= total_spent;
                    let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

                //bitstamp calculations - sell
                    let bitstamp_taker_fee = 0.004;
                    let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                    let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                    *bitstamp_wallet += money_from_sell_after_fees;

                    //this will count as value after
                    let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                    //println!("value after:\n\t{}",value_after);
        
    
                    //value_after = 60
                    //coinbase = 61
                    //bitstamp = 62
                    //kraken = 63
                    //gemini = 64
                    //since this is bitstamp and gemini being updated, I will update:
                    //  60, 62, 64
                    let indices = [60, 62, 64];
                    let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                    //01/24/24 - removed and added:
                        //neural_network.update_input(&indices, &new_values);
                        //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                        //neural_network.update_input(&indices, &transformed_values).await;
                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                        neural_network.update_input(&indices, &scaled_values).await;
    
        
        return Ok(value_after)
    }

    pub async fn s_i130_xrp_10_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
            let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build()
                    .expect("couldn't build gemini request");
        
        
            let gemini_response = client.execute(gemini_request).await
                                    .expect("Failed to execute Gemini request");
            let gemini_response_text = gemini_response.text().await
                                    .expect("Failed to turn response into text");
            let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                    .expect("Failed to parse JSON");
            let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            //CAN ONLY BUY. NOT SELL
            let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        




            println!("xrp 10 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

            let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                .header("X-Auth-Signature", bitstamp_signature)
                .header("X-Auth-Nonce", bitstamp_nonce)
                .header("X-Auth-Timestamp", bitstamp_timestamp)
                .header("X-Auth-Version", "v2")
                //.header("Content-Type", content_type)
                //.body(payload_string)
                .build()
                .expect("\ncould not build bitstamp_request");

            let bitstamp_response = client.execute(bitstamp_request).await
                .expect("Failed to execute Bitstamp request");
            let bitstamp_response_text = bitstamp_response.text().await
                .expect("Failed to turn response into text");
            //probably dont need "bitstamp" once we transfer this to the actual function
            let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            .expect("Failed to parse JSON");

            // Extract the bid and ask values
            let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            //println!("Bitstamp:\n{:?}", bitstamp_response_text);




                //gemini calculations for buy 
                    //this should equal 0.4%
                    let gemini_taker_fee = 0.004;
                    let fraction_of_wallet_im_using = 0.10;

                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                    let fee_for_purchase = total_spent*gemini_taker_fee;
                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                    //new state of gemini wallet below
                    *gemini_wallet -= total_spent;
                    let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

                //bitstamp calculations - sell
                    let bitstamp_taker_fee = 0.004;
                    let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                    let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                    *bitstamp_wallet += money_from_sell_after_fees;

                    //this will count as value after
                    let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                    //println!("value after:\n\t{}",value_after);
        
    
                    //value_after = 60
                    //coinbase = 61
                    //bitstamp = 62
                    //kraken = 63
                    //gemini = 64
                    //since this is bitstamp and gemini being updated, I will update:
                    //  60, 62, 64
                    let indices = [60, 62, 64];
                    let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
                    //01/24/24 - removed and added:
                        //neural_network.update_input(&indices, &new_values);
                        //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                        //neural_network.update_input(&indices, &transformed_values).await;
                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                        neural_network.update_input(&indices, &scaled_values).await;
    
        
        return Ok(value_after)
    }
//kraken bitstamp   = 4 AND UP for min of 25 XRP withdraw = 15 dollars. 3 and up should work but just in case
    pub async fn s_i134_xrp_4_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {

            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XRPUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            //println!("kraken response:{}", kraken_response_text);

            let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
                // Access the ask and bid prices
                kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
                kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
                //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
                //println!("xrp Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    





            println!("xrp 4 kraken bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;








            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

            let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                .header("X-Auth-Signature", bitstamp_signature)
                .header("X-Auth-Nonce", bitstamp_nonce)
                .header("X-Auth-Timestamp", bitstamp_timestamp)
                .header("X-Auth-Version", "v2")
                //.header("Content-Type", content_type)
                //.body(payload_string)
                .build()
                .expect("\ncould not build bitstamp_request");

            let bitstamp_response = client.execute(bitstamp_request).await
                .expect("Failed to execute Bitstamp request");
            let bitstamp_response_text = bitstamp_response.text().await
                .expect("Failed to turn response into text");
            //probably dont need "bitstamp" once we transfer this to the actual function
            let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            .expect("Failed to parse JSON");

            // Extract the bid and ask values
            let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            //println!("Bitstamp:\n{:?}", bitstamp_response_text);








//kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_xrp_after_fees;
            let amount_of_xrp_before_withdraw_fee = 
                            money_going_to_xrp_after_fees/kraken_buy_price_ask;
            let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //*coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is bitstamp and kraken being updated, I will update:
                //  60, 62, 63
                let indices = [60, 62, 63];
                let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
            //01/24/24 - removed and added:
                //neural_network.update_input(&indices, &new_values);
                //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                //neural_network.update_input(&indices, &transformed_values).await;
                let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                neural_network.update_input(&indices, &scaled_values).await;


            return Ok(value_after)
}

    pub async fn s_i135_xrp_5_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }






        println!("xrp 5 kraken bitstamp  delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;








        //-------bitstamp--------------------//
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        //println!("Bitstamp:\n{:?}", bitstamp_response_text);








//kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        *kraken_wallet -= money_going_to_xrp_after_fees;
        let amount_of_xrp_before_withdraw_fee = 
                        money_going_to_xrp_after_fees/kraken_buy_price_ask;
        let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

        


    //coinbase calculations for sell

        //let coinbase_taker_fee = 0.008;
        //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //*coinbase_wallet += money_from_sell_after_fees;

    //bitstamp calculations for sell
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;


    //this will count as value after
        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;


        return Ok(value_after)
    }

    pub async fn s_i136_xrp_6_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }






        println!("xrp 6 kraken bitstamp  delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;








        //-------bitstamp--------------------//
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        //println!("Bitstamp:\n{:?}", bitstamp_response_text);








//kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_im_using = 0.06;  //aka 6 percent
        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        *kraken_wallet -= money_going_to_xrp_after_fees;
        let amount_of_xrp_before_withdraw_fee = 
                        money_going_to_xrp_after_fees/kraken_buy_price_ask;
        let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

        


    //coinbase calculations for sell

        //let coinbase_taker_fee = 0.008;
        //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //*coinbase_wallet += money_from_sell_after_fees;

    //bitstamp calculations for sell
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;


    //this will count as value after
        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;


        return Ok(value_after)
    }

    pub async fn s_i137_xrp_7_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }






        println!("xrp 7 kraken bitstamp  delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;








        //-------bitstamp--------------------//
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        //println!("Bitstamp:\n{:?}", bitstamp_response_text);








//kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        *kraken_wallet -= money_going_to_xrp_after_fees;
        let amount_of_xrp_before_withdraw_fee = 
                        money_going_to_xrp_after_fees/kraken_buy_price_ask;
        let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

        


    //coinbase calculations for sell

        //let coinbase_taker_fee = 0.008;
        //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //*coinbase_wallet += money_from_sell_after_fees;

    //bitstamp calculations for sell
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;


    //this will count as value after
        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;


        return Ok(value_after)
    }

    pub async fn s_i138_xrp_8_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }






        println!("xrp 8 kraken bitstamp  delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;








        //-------bitstamp--------------------//
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        //println!("Bitstamp:\n{:?}", bitstamp_response_text);








//kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_im_using = 0.08;  //aka 8 percent
        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        *kraken_wallet -= money_going_to_xrp_after_fees;
        let amount_of_xrp_before_withdraw_fee = 
                        money_going_to_xrp_after_fees/kraken_buy_price_ask;
            let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

        


    //coinbase calculations for sell

        //let coinbase_taker_fee = 0.008;
        //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //*coinbase_wallet += money_from_sell_after_fees;

    //bitstamp calculations for sell
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;


    //this will count as value after
        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;


        return Ok(value_after)
    }

    pub async fn s_i139_xrp_9_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }






        println!("xrp 9 kraken bitstamp  delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;








        //-------bitstamp--------------------//
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        //println!("Bitstamp:\n{:?}", bitstamp_response_text);








//kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_im_using = 0.09;  //aka 9 percent
        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        *kraken_wallet -= money_going_to_xrp_after_fees;
        let amount_of_xrp_before_withdraw_fee = 
                        money_going_to_xrp_after_fees/kraken_buy_price_ask;
            let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

        


    //coinbase calculations for sell

        //let coinbase_taker_fee = 0.008;
        //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //*coinbase_wallet += money_from_sell_after_fees;

    //bitstamp calculations for sell
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;


    //this will count as value after
        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;


        return Ok(value_after)
    }
    //-----NEED-TO-APPEND-TO-END-----//
    pub async fn s_i140_xrp_10_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64  )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }






        println!("xrp 10 kraken bitstamp  delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;








        //-------bitstamp--------------------//
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");

        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");

        // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
        //println!("Bitstamp:\n{:?}", bitstamp_response_text);








//kraken calculations - buy
        let kraken_taker_fee = 0.0026;
        let fraction_of_wallet_im_using = 0.10;  //aka 10 percent
        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        let fee_for_purchase = total_spent*kraken_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        *kraken_wallet -= money_going_to_xrp_after_fees;
        let amount_of_xrp_before_withdraw_fee = 
                        money_going_to_xrp_after_fees/kraken_buy_price_ask;
            let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

        


    //coinbase calculations for sell

        //let coinbase_taker_fee = 0.008;
        //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //*coinbase_wallet += money_from_sell_after_fees;

    //bitstamp calculations for sell
        let bitstamp_taker_fee = 0.004;
        let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        *bitstamp_wallet += money_from_sell_after_fees;


    //this will count as value after
        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



            //value_after = 60
            //coinbase = 61
            //bitstamp = 62
            //kraken = 63
            //gemini = 64
            //since this is bitstamp and kraken being updated, I will update:
            //  60, 62, 63
            let indices = [60, 62, 63];
            let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;


        return Ok(value_after)
    }
//gemini coinbase   = 3 AND UP for gemini/coin
    pub async fn s_i143_xrp_3_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 3 gemini coinbase simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }



                    //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.03; //aka 3 percent

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
        return Ok(value_after)
    }

    pub async fn s_i144_xrp_4_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 4 gemini coinbase 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }



                    //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.04; //aka 4 percent

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
        return Ok(value_after)
    }

    pub async fn s_i145_xrp_5_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 5 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }



                    //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.05; //aka 5 percent

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
        return Ok(value_after)
    }

    pub async fn s_i146_xrp_6_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 6 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }



                    //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.06; //aka 6 percent

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
        return Ok(value_after)
    }

    pub async fn s_i147_xrp_7_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 7 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }



                    //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.07; //aka 7 percent

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
        return Ok(value_after)
    }

    pub async fn s_i148_xrp_8_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 8 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }



                    //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.08; //aka 8 percent

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
        return Ok(value_after)
    }

    pub async fn s_i149_xrp_9_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 9 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }



                    //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.09; //aka 9 percent

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
        return Ok(value_after)
    }

    pub async fn s_i150_xrp_10_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 10 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }



                    //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.10; //aka 10 percent

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //*bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
                //value_after = 60
                //coinbase = 61
                //bitstamp = 62
                //kraken = 63
                //gemini = 64
                //since this is coinbase and gemini being updated, I will update:
                //  60, 61, 64
                let indices = [60, 61, 64];
                let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
                //01/24/24 - removed and added:
                    //neural_network.update_input(&indices, &new_values);
                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                    //neural_network.update_input(&indices, &transformed_values).await;
                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
                    neural_network.update_input(&indices, &scaled_values).await;
    
        return Ok(value_after)
    }
//gemini kraken     = 3 AND UP for min of 10 USD for gemini. min buy of 10 XRP for kraken so maximal min is 6 dollars.
pub async fn s_i153_xrp_3_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
    gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

    fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
        let encoded_payload = encode(gemini_payload.to_string());
        let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                        .expect("HMAC can take key of any size");
        mac.update(encoded_payload.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        let gemini_signature = hex::encode(code_bytes);
        println!("Gemini signature:\n{}", &gemini_signature);
        gemini_signature

    }
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time.
    //		let now = Utc::now();
    let now = Utc::now();
    let gemini_time_stamp = now.timestamp().to_string();
    let gemini_nonce = gemini_time_stamp;
    let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
    let gemini_payload = json!({
        "request": "/v1/mytrades",
        "nonce": &gemini_nonce
    });
    let base64_encoded_payload = encode(gemini_payload.to_string());
    let gemini_content_type = "text/plain";
    let gemini_content_length = "0";
    let gemini_cache_control = "no-cache";
    let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

    //02/07/24 - added:
        let mut attempts = 0;
        let gemini_buy_ask: Option<f64>;
        loop {
            let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build();
        
            match gemini_request {
                Ok(request) => {
                    match client.execute(request).await {
                        Ok(response) => {
                            let gemini_response_text = response.text().await;
                            match gemini_response_text {
                                Ok(text) => {

                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(value) => {
                                            let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                                .ok_or_else(|| "Failed to get ask as string")
                                                .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                                
                                            match gemini_buy_ask_result {
                                                Ok(ask) => {
                                                    gemini_buy_ask = Some(ask);
                                                    // Continue with your logic here using `ask`
                                                    break; // Exit the loop if everything is successful
                                                },
                                                Err(e) => log::error!("{}", e),
                                            }
                                        },
                                        Err(_) => log::error!("Failed to parse JSON"),
                                    }
                                },
                                Err(_) => log::error!("Failed to turn response into text"),
                            }
                        },
                        Err(_) => log::error!("Failed to execute Gemini request"),
                    }
                },
                Err(_) => log::error!("Couldn't build gemini request"),
            }
        
            attempts += 1;
            if attempts >= 3 {
                panic!("Failed after 3 attempts");
            }
        }





//02/07/24 - removed
    // let gemini_request = client.get(gemini_url)
    //         .header("Content-Type", gemini_content_type)
    //         .header("Content-Length", gemini_content_length)
    //         .header("X-GEMINI-APIKEY", gemini_api_key)
    //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
    //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
    //         .header("Cache-Control", gemini_cache_control)
    //         .build()
    //         .expect("couldn't build gemini request");


    // let gemini_response = client.execute(gemini_request).await
    //                         .expect("Failed to execute Gemini request");
    // let gemini_response_text = gemini_response.text().await
    //                         .expect("Failed to turn response into text");
    // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
    //                         .expect("Failed to parse JSON");
    // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
    // //CAN ONLY BUY. NOT SELL
    // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
    // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





    println!("xrp 3 gemini kraken simulated exchange delay: 8 sec...");
    let when = tokio::time::Instant::now() + Duration::from_secs(8);
    //02/09/24 - updated tokio. changed to sleep_until
    tokio::time::sleep_until(when).await;



    //---KRAKEN--//

    //basically Kraken requires a value that is always increasing to be in each request.
    //I didnt use now.timestamp().to_string()  because just in case I have 2 
    //	requests in a second I dont want to be penalized.
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time. MAY NEED TO USE LOCAL TIME
    let now = Utc::now();
    let nonce = now.timestamp_millis().to_string();
    let data = vec![
        ("nonce", &nonce),
        // Add more parameters as needed
    ];
    //let post_data: String = form_urlencoded::Serializer::new(String::new())
    //    .extend_pairs(data)
    //    .finish();
    
    let url_path = "/0/public/Ticker?pair=XRPUSD";
    //let message = format!("{}{}{}", url_path, nonce, post_data);

    fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
    -> String {
        // Create the post data
        let post_data: String = form_urlencoded::Serializer::new(String::new())
            .extend_pairs(data)
            .finish();
        //FOR DEBUGGING
        //println!("Private key:\n{}", secret);
        //println!("Nonce:\n{}", nonce_str);
        //println!("Encoded payload:\n{}", post_data);
        //println!("URI Path:\n{}", url_path);
    
        // Create the encoded string (nonce + post data) and hash it
        let encoded = format!("{}{}", nonce_str, post_data);
        let mut hasher = sha2::Sha256::new();
        hasher.update(encoded);
        let encoded_hash = hasher.finalize();
    
        // Create the message (url_path + encoded_hash as bytes)
        let mut message = url_path.as_bytes().to_vec();
        message.extend_from_slice(&encoded_hash);
    
        // Create a HMAC-SHA512 object with the base64-decoded secret
        let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
            .expect("HMAC can take key of any size");
    
        // Compute the HMAC of the message
        mac.update(&message);
        let result = mac.finalize();
    
        // Return the base64-encoded HMAC
        let signature = base64::encode(result.into_bytes());
        //println!("Kraken signature:\n{}", signature);
    
        signature
    }

    let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

    //kraken asked for 3 headers: key, sign, and content type with its corresponding info
    //.body is nonce because in the Kraken code provided in cURL: 
    //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
    //--data-urlencode "nonce=<YOUR-NONCE>"
    //		this means that nonce is added to the body of the request



    //02/07/24 - removed
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
        //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
        //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }
    //02/07/24 - replaced with:
        let mut kraken_sell_price_bid: Option<f64> = None;
        let mut kraken_buy_price_ask: Option<f64> = None;
        let mut value_after: Option<f64> = None;
        let mut attempts = 0;
        
        loop {
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build();
        
            match kraken_basic_request {
                Ok(request) => {
                    match client.execute(request).await {
                        Ok(response) => {
                            match response.text().await {
                                Ok(kraken_response_text) => {
                                    match serde_json::from_str::<Value>(&kraken_response_text) {
                                        Ok(value) => {
                                            if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse().ok());
                                                kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse().ok());


                                                let gemini_taker_fee = 0.004;
                                                let fraction_of_wallet_im_using = 0.03; //aka 3 percent
                                    
                                                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                let fee_for_purchase = total_spent*gemini_taker_fee;
                                                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                //new state of gemini wallet below
                                                *gemini_wallet -= total_spent;
                                                //let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
                                                if let Some(gemini_buy_ask) = gemini_buy_ask {
                                                    if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
                                                        let amount_of_xrp = money_going_to_xrp_after_fees / gemini_buy_ask;
                                                        // Continue with your logic here...
                                                        //kraken calculations - for sell
                                                            let kraken_taker_fee = 0.0026;
                                                            
                                                            let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
                                                            let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                                                            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                                                            *kraken_wallet += money_from_sell_after_fees;

                                                
                                                
                                                        //this will count as value after
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);

                                                    
                                                    
                                                                //value_after = 60
                                                                //coinbase = 61
                                                                //bitstamp = 62
                                                                //kraken = 63
                                                                //gemini = 64
                                                                //since this is kraken and gemini being updated, I will update:
                                                                //  60, 63, 64
                                                                let indices = [60, 63, 64];
                                                                let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
                                                                //01/24/24 - removed and added:
                                                                    //neural_network.update_input(&indices, &new_values);
                                                                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                                                                    //neural_network.update_input(&indices, &transformed_values).await;
                                                                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                    neural_network.update_input(&indices, &scaled_values).await;
                                                    }
                                                    else {
                                                        log::error!("Kraken sell price is None. Response text was: {}", kraken_response_text);
                                                    }
                                                } 
                                                else {
                                                    log::error!("Gemini buy ask is None. Response text was: {}", kraken_response_text);
                                                }
                                            } 
                                            else {
                                                log::error!("Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                            }
                                        },
                                        Err(e) => log::error!("Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                    }
                                },
                                Err(e) => log::error!("Failed to read response text. Error was: {}", e),
                            }
                        },
                        Err(e) => log::error!("Failed to execute Kraken request. Error was: {}", e),
                    }
                },
                Err(e) => log::error!("Failed to build kraken request. Error was: {}", e),
            }
        
            // Continue with your logic here...
            // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
        
            if kraken_sell_price_bid.is_some() && kraken_buy_price_ask.is_some() {
                break; // Exit the loop if everything is successful
            }
        
            attempts += 1;
            if attempts >= 3 {
                panic!("Failed after 3 attempts");
            }
        }




    // //gemini calculations for buy 
    //     //this should equal 0.4%
    //     let gemini_taker_fee = 0.004;
    //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

    //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
    //     let fee_for_purchase = total_spent*gemini_taker_fee;
    //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
    //     //new state of gemini wallet below
    //     *gemini_wallet -= total_spent;
    //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




    // //coinbase calculations for sell

    //     //let coinbase_taker_fee = 0.008;
    //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
    //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
    //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
    //     //*coinbase_wallet += money_from_sell_after_fees;



    // //coinbase calculations for buy - not needed in this so code commented out
    
    //     //let coinbase_taker_fee = 0.008;

    //     //let total_spent = 0.10*(*coinbase_wallet);
    //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
    //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
    //     ////new state of coinbase wallet below
    //     //*coinbase_wallet -= total_spent;
    //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

    // //kraken calculations - for sell
    //     let kraken_taker_fee = 0.0026;
        
    //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
    //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
    //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
    //     *kraken_wallet += money_from_sell_after_fees;

    //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


    // //bitstamp calculations - for sell
    //     //let bitstamp_taker_fee = 0.004;
    //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
    //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
    //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
    //     //*bitstamp_wallet += money_from_sell_after_fees;



    // //this will count as value after
    //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    //     //println!("value after:\n\t{}",value_after);


    //     //value_after = 60
    //     //coinbase = 61
    //     //bitstamp = 62
    //     //kraken = 63
    //     //gemini = 64
    //     //since this is kraken and gemini being updated, I will update:
    //     //  60, 63, 64
    //     let indices = [60, 63, 64];
    //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
    //     //01/24/24 - removed and added:
    //         //neural_network.update_input(&indices, &new_values);
    //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
    //         //neural_network.update_input(&indices, &transformed_values).await;
    //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
    //         neural_network.update_input(&indices, &scaled_values).await;

    //     return Ok(value_after)
    match value_after {
        Some(value) => return Ok(value),
        None => {
            
            panic!("Failed to get a valid value after {} attempts. 
            Final values: kraken_sell_price_bid = {:?}
            gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
        }
    }
}

    pub async fn s_i154_xrp_4_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
                                            Ok(value) => {
                                                let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                                    .ok_or_else(|| "Failed to get ask as string")
                                                    .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                                    
                                                match gemini_buy_ask_result {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(e) => log::error!("{}", e),
                                                }
                                            },
                                            Err(_) => log::error!("Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 4 gemini kraken simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse().ok());
                                                    kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse().ok());


                                                    let gemini_taker_fee = 0.004;
                                                    let fraction_of_wallet_im_using = 0.04; //aka 4 percent
                                        
                                                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                    let fee_for_purchase = total_spent*gemini_taker_fee;
                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                    //new state of gemini wallet below
                                                    *gemini_wallet -= total_spent;
                                                    //let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
                                                    if let Some(gemini_buy_ask) = gemini_buy_ask {
                                                        if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
                                                            let amount_of_xrp = money_going_to_xrp_after_fees / gemini_buy_ask;
                                                            // Continue with your logic here...
                                                            //kraken calculations - for sell
                                                                let kraken_taker_fee = 0.0026;
                                                                
                                                                let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                                                                *kraken_wallet += money_from_sell_after_fees;

                                                    
                                                    
                                                            //this will count as value after
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);

                                                    
                                                    
                                                                //value_after = 60
                                                                //coinbase = 61
                                                                //bitstamp = 62
                                                                //kraken = 63
                                                                //gemini = 64
                                                                //since this is kraken and gemini being updated, I will update:
                                                                //  60, 63, 64
                                                                let indices = [60, 63, 64];
                                                                let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
                                                                //01/24/24 - removed and added:
                                                                    //neural_network.update_input(&indices, &new_values);
                                                                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                                                                    //neural_network.update_input(&indices, &transformed_values).await;
                                                                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                    neural_network.update_input(&indices, &scaled_values).await;
                                                        }
                                                        else {
                                                            log::error!("Kraken sell price is None. Response text was: {}", kraken_response_text);
                                                        }
                                                    } 
                                                    else {
                                                        log::error!("Gemini buy ask is None. Response text was: {}", kraken_response_text);
                                                    }
                                                } 
                                                else {
                                                    log::error!("Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
                if kraken_sell_price_bid.is_some() && kraken_buy_price_ask.is_some() {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 60
        //     //coinbase = 61
        //     //bitstamp = 62
        //     //kraken = 63
        //     //gemini = 64
        //     //since this is kraken and gemini being updated, I will update:
        //     //  60, 63, 64
        //     let indices = [60, 63, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
}

        pub async fn s_i155_xrp_5_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
                                            Ok(value) => {
                                                let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                                    .ok_or_else(|| "Failed to get ask as string")
                                                    .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                                    
                                                match gemini_buy_ask_result {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(e) => log::error!("{}", e),
                                                }
                                            },
                                            Err(_) => log::error!("Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 5 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse().ok());
                                                    kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse().ok());


                                                    let gemini_taker_fee = 0.004;
                                                    let fraction_of_wallet_im_using = 0.05; //aka 5 percent
                                        
                                                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                    let fee_for_purchase = total_spent*gemini_taker_fee;
                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                    //new state of gemini wallet below
                                                    *gemini_wallet -= total_spent;
                                                    //let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
                                                    if let Some(gemini_buy_ask) = gemini_buy_ask {
                                                        if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
                                                            let amount_of_xrp = money_going_to_xrp_after_fees / gemini_buy_ask;
                                                            // Continue with your logic here...
                                                            //kraken calculations - for sell
                                                                let kraken_taker_fee = 0.0026;
                                                                
                                                                let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                                                                *kraken_wallet += money_from_sell_after_fees;

                                                    
                                                    
                                                            //this will count as value after
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);

                                                    
                                                    
                                                                //value_after = 60
                                                                //coinbase = 61
                                                                //bitstamp = 62
                                                                //kraken = 63
                                                                //gemini = 64
                                                                //since this is kraken and gemini being updated, I will update:
                                                                //  60, 63, 64
                                                                let indices = [60, 63, 64];
                                                                let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
                                                                //01/24/24 - removed and added:
                                                                    //neural_network.update_input(&indices, &new_values);
                                                                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                                                                    //neural_network.update_input(&indices, &transformed_values).await;
                                                                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                    neural_network.update_input(&indices, &scaled_values).await;
                                                        }
                                                        else {
                                                            log::error!("Kraken sell price is None. Response text was: {}", kraken_response_text);
                                                        }
                                                    } 
                                                    else {
                                                        log::error!("Gemini buy ask is None. Response text was: {}", kraken_response_text);
                                                    }
                                                } 
                                                else {
                                                    log::error!("Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
                if kraken_sell_price_bid.is_some() && kraken_buy_price_ask.is_some() {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 60
        //     //coinbase = 61
        //     //bitstamp = 62
        //     //kraken = 63
        //     //gemini = 64
        //     //since this is kraken and gemini being updated, I will update:
        //     //  60, 63, 64
        //     let indices = [60, 63, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
    }

    pub async fn s_i156_xrp_6_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
                                            Ok(value) => {
                                                let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                                    .ok_or_else(|| "Failed to get ask as string")
                                                    .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                                    
                                                match gemini_buy_ask_result {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(e) => log::error!("{}", e),
                                                }
                                            },
                                            Err(_) => log::error!("Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 6 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse().ok());
                                                    kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse().ok());


                                                    let gemini_taker_fee = 0.004;
                                                    let fraction_of_wallet_im_using = 0.06; //aka 6 percent
                                        
                                                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                    let fee_for_purchase = total_spent*gemini_taker_fee;
                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                    //new state of gemini wallet below
                                                    *gemini_wallet -= total_spent;
                                                    //let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
                                                    if let Some(gemini_buy_ask) = gemini_buy_ask {
                                                        if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
                                                            let amount_of_xrp = money_going_to_xrp_after_fees / gemini_buy_ask;
                                                            // Continue with your logic here...
                                                            //kraken calculations - for sell
                                                                let kraken_taker_fee = 0.0026;
                                                                
                                                                let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                                                                *kraken_wallet += money_from_sell_after_fees;

                                                    
                                                    
                                                            //this will count as value after
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);

                                                    
                                                    
                                                                //value_after = 60
                                                                //coinbase = 61
                                                                //bitstamp = 62
                                                                //kraken = 63
                                                                //gemini = 64
                                                                //since this is kraken and gemini being updated, I will update:
                                                                //  60, 63, 64
                                                                let indices = [60, 63, 64];
                                                                let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
                                                                //01/24/24 - removed and added:
                                                                    //neural_network.update_input(&indices, &new_values);
                                                                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                                                                    //neural_network.update_input(&indices, &transformed_values).await;
                                                                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                    neural_network.update_input(&indices, &scaled_values).await;
                                                        }
                                                        else {
                                                            log::error!("Kraken sell price is None. Response text was: {}", kraken_response_text);
                                                        }
                                                    } 
                                                    else {
                                                        log::error!("Gemini buy ask is None. Response text was: {}", kraken_response_text);
                                                    }
                                                } 
                                                else {
                                                    log::error!("Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
                if kraken_sell_price_bid.is_some() && kraken_buy_price_ask.is_some() {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 60
        //     //coinbase = 61
        //     //bitstamp = 62
        //     //kraken = 63
        //     //gemini = 64
        //     //since this is kraken and gemini being updated, I will update:
        //     //  60, 63, 64
        //     let indices = [60, 63, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
    }

    pub async fn s_i157_xrp_7_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
                                            Ok(value) => {
                                                let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                                    .ok_or_else(|| "Failed to get ask as string")
                                                    .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                                    
                                                match gemini_buy_ask_result {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(e) => log::error!("{}", e),
                                                }
                                            },
                                            Err(_) => log::error!("Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 7 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse().ok());
                                                    kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse().ok());


                                                    let gemini_taker_fee = 0.004;
                                                    let fraction_of_wallet_im_using = 0.07; //aka 7 percent
                                        
                                                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                    let fee_for_purchase = total_spent*gemini_taker_fee;
                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                    //new state of gemini wallet below
                                                    *gemini_wallet -= total_spent;
                                                    //let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
                                                    if let Some(gemini_buy_ask) = gemini_buy_ask {
                                                        if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
                                                            let amount_of_xrp = money_going_to_xrp_after_fees / gemini_buy_ask;
                                                            // Continue with your logic here...
                                                            //kraken calculations - for sell
                                                                let kraken_taker_fee = 0.0026;
                                                                
                                                                let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                                                                *kraken_wallet += money_from_sell_after_fees;

                                                    
                                                    
                                                            //this will count as value after
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);

                                                    
                                                    
                                                                //value_after = 60
                                                                //coinbase = 61
                                                                //bitstamp = 62
                                                                //kraken = 63
                                                                //gemini = 64
                                                                //since this is kraken and gemini being updated, I will update:
                                                                //  60, 63, 64
                                                                let indices = [60, 63, 64];
                                                                let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
                                                                //01/24/24 - removed and added:
                                                                    //neural_network.update_input(&indices, &new_values);
                                                                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                                                                    //neural_network.update_input(&indices, &transformed_values).await;
                                                                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                    neural_network.update_input(&indices, &scaled_values).await;
                                                        }
                                                        else {
                                                            log::error!("Kraken sell price is None. Response text was: {}", kraken_response_text);
                                                        }
                                                    } 
                                                    else {
                                                        log::error!("Gemini buy ask is None. Response text was: {}", kraken_response_text);
                                                    }
                                                } 
                                                else {
                                                    log::error!("Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
                if kraken_sell_price_bid.is_some() && kraken_buy_price_ask.is_some() {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 60
        //     //coinbase = 61
        //     //bitstamp = 62
        //     //kraken = 63
        //     //gemini = 64
        //     //since this is kraken and gemini being updated, I will update:
        //     //  60, 63, 64
        //     let indices = [60, 63, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
    }

    pub async fn s_i158_xrp_8_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
                                            Ok(value) => {
                                                let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                                    .ok_or_else(|| "Failed to get ask as string")
                                                    .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                                    
                                                match gemini_buy_ask_result {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(e) => log::error!("{}", e),
                                                }
                                            },
                                            Err(_) => log::error!("Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 8 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse().ok());
                                                    kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse().ok());


                                                    let gemini_taker_fee = 0.004;
                                                    let fraction_of_wallet_im_using = 0.08; //aka 8 percent
                                        
                                                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                    let fee_for_purchase = total_spent*gemini_taker_fee;
                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                    //new state of gemini wallet below
                                                    *gemini_wallet -= total_spent;
                                                    //let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
                                                    if let Some(gemini_buy_ask) = gemini_buy_ask {
                                                        if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
                                                            let amount_of_xrp = money_going_to_xrp_after_fees / gemini_buy_ask;
                                                            // Continue with your logic here...
                                                            //kraken calculations - for sell
                                                                let kraken_taker_fee = 0.0026;
                                                                
                                                                let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                                                                *kraken_wallet += money_from_sell_after_fees;

                                                    
                                                    
                                                            //this will count as value after
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);

                                                    
                                                    
                                                                //value_after = 60
                                                                //coinbase = 61
                                                                //bitstamp = 62
                                                                //kraken = 63
                                                                //gemini = 64
                                                                //since this is kraken and gemini being updated, I will update:
                                                                //  60, 63, 64
                                                                let indices = [60, 63, 64];
                                                                let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
                                                                //01/24/24 - removed and added:
                                                                    //neural_network.update_input(&indices, &new_values);
                                                                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                                                                    //neural_network.update_input(&indices, &transformed_values).await;
                                                                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                    neural_network.update_input(&indices, &scaled_values).await;
                                                        }
                                                        else {
                                                            log::error!("Kraken sell price is None. Response text was: {}", kraken_response_text);
                                                        }
                                                    } 
                                                    else {
                                                        log::error!("Gemini buy ask is None. Response text was: {}", kraken_response_text);
                                                    }
                                                } 
                                                else {
                                                    log::error!("Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
                if kraken_sell_price_bid.is_some() && kraken_buy_price_ask.is_some() {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 60
        //     //coinbase = 61
        //     //bitstamp = 62
        //     //kraken = 63
        //     //gemini = 64
        //     //since this is kraken and gemini being updated, I will update:
        //     //  60, 63, 64
        //     let indices = [60, 63, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
    }

    pub async fn s_i159_xrp_9_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
                                            Ok(value) => {
                                                let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                                    .ok_or_else(|| "Failed to get ask as string")
                                                    .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                                    
                                                match gemini_buy_ask_result {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(e) => log::error!("{}", e),
                                                }
                                            },
                                            Err(_) => log::error!("Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 9 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse().ok());
                                                    kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse().ok());


                                                    let gemini_taker_fee = 0.004;
                                                    let fraction_of_wallet_im_using = 0.09; //aka 9 percent
                                        
                                                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                    let fee_for_purchase = total_spent*gemini_taker_fee;
                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                    //new state of gemini wallet below
                                                    *gemini_wallet -= total_spent;
                                                    //let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
                                                    if let Some(gemini_buy_ask) = gemini_buy_ask {
                                                        if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
                                                            let amount_of_xrp = money_going_to_xrp_after_fees / gemini_buy_ask;
                                                            // Continue with your logic here...
                                                            //kraken calculations - for sell
                                                                let kraken_taker_fee = 0.0026;
                                                                
                                                                let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                                                                *kraken_wallet += money_from_sell_after_fees;

                                                    
                                                    
                                                            //this will count as value after
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);

                                                    
                                                    
                                                                //value_after = 60
                                                                //coinbase = 61
                                                                //bitstamp = 62
                                                                //kraken = 63
                                                                //gemini = 64
                                                                //since this is kraken and gemini being updated, I will update:
                                                                //  60, 63, 64
                                                                let indices = [60, 63, 64];
                                                                let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
                                                                //01/24/24 - removed and added:
                                                                    //neural_network.update_input(&indices, &new_values);
                                                                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                                                                    //neural_network.update_input(&indices, &transformed_values).await;
                                                                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                    neural_network.update_input(&indices, &scaled_values).await;
                                                        }
                                                        else {
                                                            log::error!("Kraken sell price is None. Response text was: {}", kraken_response_text);
                                                        }
                                                    } 
                                                    else {
                                                        log::error!("Gemini buy ask is None. Response text was: {}", kraken_response_text);
                                                    }
                                                } 
                                                else {
                                                    log::error!("Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
                if kraken_sell_price_bid.is_some() && kraken_buy_price_ask.is_some() {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 60
        //     //coinbase = 61
        //     //bitstamp = 62
        //     //kraken = 63
        //     //gemini = 64
        //     //since this is kraken and gemini being updated, I will update:
        //     //  60, 63, 64
        //     let indices = [60, 63, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
}

        pub async fn s_i160_xrp_10_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
                                            Ok(value) => {
                                                let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                                    .ok_or_else(|| "Failed to get ask as string")
                                                    .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                                    
                                                match gemini_buy_ask_result {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(e) => log::error!("{}", e),
                                                }
                                            },
                                            Err(_) => log::error!("Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 10 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse().ok());
                                                    kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse().ok());


                                                    let gemini_taker_fee = 0.004;
                                                    let fraction_of_wallet_im_using = 0.10; //aka 10 percent
                                        
                                                    let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                    let fee_for_purchase = total_spent*gemini_taker_fee;
                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                    //new state of gemini wallet below
                                                    *gemini_wallet -= total_spent;
                                                    //let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
                                                    if let Some(gemini_buy_ask) = gemini_buy_ask {
                                                        if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
                                                            let amount_of_xrp = money_going_to_xrp_after_fees / gemini_buy_ask;
                                                            // Continue with your logic here...
                                                            //kraken calculations - for sell
                                                                let kraken_taker_fee = 0.0026;
                                                                
                                                                let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                                                                *kraken_wallet += money_from_sell_after_fees;

                                                    
                                                    
                                                            //this will count as value after
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);

                                                    
                                                    
                                                                //value_after = 60
                                                                //coinbase = 61
                                                                //bitstamp = 62
                                                                //kraken = 63
                                                                //gemini = 64
                                                                //since this is kraken and gemini being updated, I will update:
                                                                //  60, 63, 64
                                                                let indices = [60, 63, 64];
                                                                let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
                                                                //01/24/24 - removed and added:
                                                                    //neural_network.update_input(&indices, &new_values);
                                                                    //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
                                                                    //neural_network.update_input(&indices, &transformed_values).await;
                                                                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                    neural_network.update_input(&indices, &scaled_values).await;
                                                        }
                                                        else {
                                                            log::error!("Kraken sell price is None. Response text was: {}", kraken_response_text);
                                                        }
                                                    } 
                                                    else {
                                                        log::error!("Gemini buy ask is None. Response text was: {}", kraken_response_text);
                                                    }
                                                } 
                                                else {
                                                    log::error!("Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
                if kraken_sell_price_bid.is_some() && kraken_buy_price_ask.is_some() {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 60
        //     //coinbase = 61
        //     //bitstamp = 62
        //     //kraken = 63
        //     //gemini = 64
        //     //since this is kraken and gemini being updated, I will update:
        //     //  60, 63, 64
        //     let indices = [60, 63, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
    }
//coinbase kraken   = 3 AND UP FOR min of 10 USD for coinbase. min buy of 10 XRP for kraken so maximal min is 6 dollars.
    pub async fn s_i163_xrp_3_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);









        println!("xrp 3 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }


        let coinbase_taker_fee = 0.008;
        let fraction_of_wallet_used = 0.03;
        let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
        let fee_for_purchase = total_spent*coinbase_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //new state of coinbase wallet below
        *coinbase_wallet -= total_spent;
        let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

    //kraken calculations
        let kraken_taker_fee = 0.0026;
        
        let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        *kraken_wallet += money_from_sell_after_fees;

        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


    //this will count as value after

            //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is coinbase and kraken being updated, I will update:
        //  60, 61, 63
        let indices = [60, 61, 63];
        let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;

        return Ok(value_after)

}

    pub async fn s_i164_xrp_4_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);









        println!("xrp 4 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }


        let coinbase_taker_fee = 0.008;
        let fraction_of_wallet_used = 0.04;
        let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
        let fee_for_purchase = total_spent*coinbase_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //new state of coinbase wallet below
        *coinbase_wallet -= total_spent;
        let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

    //kraken calculations
        let kraken_taker_fee = 0.0026;
        
        let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        *kraken_wallet += money_from_sell_after_fees;

        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


    //this will count as value after

            //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is coinbase and kraken being updated, I will update:
        //  60, 61, 63
        let indices = [60, 61, 63];
        let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;

        return Ok(value_after)

}

    pub async fn s_i165_xrp_5_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);









        println!("xrp 5 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }


        let coinbase_taker_fee = 0.008;
        let fraction_of_wallet_used = 0.05;
        let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
        let fee_for_purchase = total_spent*coinbase_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //new state of coinbase wallet below
        *coinbase_wallet -= total_spent;
        let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

    //kraken calculations
        let kraken_taker_fee = 0.0026;
        
        let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        *kraken_wallet += money_from_sell_after_fees;

        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


    //this will count as value after

            //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is coinbase and kraken being updated, I will update:
        //  60, 61, 63
        let indices = [60, 61, 63];
        let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;

        return Ok(value_after)

}

    pub async fn s_i166_xrp_6_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);









        println!("xrp 6 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }


        let coinbase_taker_fee = 0.008;
        let fraction_of_wallet_used = 0.06;
        let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
        let fee_for_purchase = total_spent*coinbase_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //new state of coinbase wallet below
        *coinbase_wallet -= total_spent;
        let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

    //kraken calculations
        let kraken_taker_fee = 0.0026;
        
        let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        *kraken_wallet += money_from_sell_after_fees;

        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


    //this will count as value after

            //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is coinbase and kraken being updated, I will update:
        //  60, 61, 63
        let indices = [60, 61, 63];
        let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;

        return Ok(value_after)
    }

    pub async fn s_i167_xrp_7_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);









        println!("xrp 7 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }


        let coinbase_taker_fee = 0.008;
        let fraction_of_wallet_used = 0.07; //aka 7 percent
        let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
        let fee_for_purchase = total_spent*coinbase_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //new state of coinbase wallet below
        *coinbase_wallet -= total_spent;
        let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

    //kraken calculations
        let kraken_taker_fee = 0.0026;
        
        let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        *kraken_wallet += money_from_sell_after_fees;

        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


    //this will count as value after

            //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is coinbase and kraken being updated, I will update:
        //  60, 61, 63
        let indices = [60, 61, 63];
        let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;

        return Ok(value_after)
    }

    pub async fn s_i168_xrp_8_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);









        println!("xrp 8 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }


        let coinbase_taker_fee = 0.008;
        let fraction_of_wallet_used = 0.08; //aka 8 percent
        let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
        let fee_for_purchase = total_spent*coinbase_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //new state of coinbase wallet below
        *coinbase_wallet -= total_spent;
        let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

    //kraken calculations
        let kraken_taker_fee = 0.0026;
        
        let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        *kraken_wallet += money_from_sell_after_fees;

        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


    //this will count as value after

            //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is coinbase and kraken being updated, I will update:
        //  60, 61, 63
        let indices = [60, 61, 63];
        let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;

        return Ok(value_after)
    }

    pub async fn s_i169_xrp_9_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);









        println!("xrp 9 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }


        let coinbase_taker_fee = 0.008;
        let fraction_of_wallet_used = 0.09; //aka 9 percent
        let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
        let fee_for_purchase = total_spent*coinbase_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //new state of coinbase wallet below
        *coinbase_wallet -= total_spent;
        let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

    //kraken calculations
        let kraken_taker_fee = 0.0026;
        
        let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        *kraken_wallet += money_from_sell_after_fees;

        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


    //this will count as value after

            //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is coinbase and kraken being updated, I will update:
        //  60, 61, 63
        let indices = [60, 61, 63];
        let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;

        return Ok(value_after)
    }

    pub async fn s_i170_xrp_10_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);
        //02/04/24 - need to add loop here
        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()
        .expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await.expect("couldn't build response");
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await.expect("couldn't build response_text");

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        let mut coinbase_sell_price_bid = 0.0;
        let mut coinbase_buy_price_ask = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
                let bid_size = bids["size"].as_str().expect("could not find bids[size]");
                coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
                let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
                //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);









        println!("xrp 10 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        //println!("kraken response:{}", kraken_response_text);

        let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
            //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //println!("xrp Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }


        let coinbase_taker_fee = 0.008;
        let fraction_of_wallet_used = 0.10; //aka 10 percent
        let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
        let fee_for_purchase = total_spent*coinbase_taker_fee;
        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //new state of coinbase wallet below
        *coinbase_wallet -= total_spent;
        let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

    //kraken calculations
        let kraken_taker_fee = 0.0026;
        
        let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        *kraken_wallet += money_from_sell_after_fees;

        let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


    //this will count as value after

            //value_after = 60
        //coinbase = 61
        //bitstamp = 62
        //kraken = 63
        //gemini = 64
        //since this is coinbase and kraken being updated, I will update:
        //  60, 61, 63
        let indices = [60, 61, 63];
        let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //01/24/24 - removed and added:
            //neural_network.update_input(&indices, &new_values);
            //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //neural_network.update_input(&indices, &transformed_values).await;
            let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            neural_network.update_input(&indices, &scaled_values).await;

        return Ok(value_after)
    }
//kraken coinbase   = 4 AND UP for min of 25 XRP withdraw = 15 dollars. 3 and up should work but just in case
pub async fn s_i174_xrp_4_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
    gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

    //---KRAKEN--//

    //basically Kraken requires a value that is always increasing to be in each request.
    //I didnt use now.timestamp().to_string()  because just in case I have 2 
    //	requests in a second I dont want to be penalized.
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time. MAY NEED TO USE LOCAL TIME
    let now = Utc::now();
    let nonce = now.timestamp_millis().to_string();
    let data = vec![
        ("nonce", &nonce),
        // Add more parameters as needed
    ];
    //let post_data: String = form_urlencoded::Serializer::new(String::new())
    //    .extend_pairs(data)
    //    .finish();
    
    let url_path = "/0/public/Ticker?pair=XRPUSD";
    //let message = format!("{}{}{}", url_path, nonce, post_data);


    fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
    -> String {
        // Create the post data
        let post_data: String = form_urlencoded::Serializer::new(String::new())
            .extend_pairs(data)
            .finish();
        //FOR DEBUGGING
        //println!("Private key:\n{}", secret);
        //println!("Nonce:\n{}", nonce_str);
        //println!("Encoded payload:\n{}", post_data);
        //println!("URI Path:\n{}", url_path);
    
        // Create the encoded string (nonce + post data) and hash it
        let encoded = format!("{}{}", nonce_str, post_data);
        let mut hasher = sha2::Sha256::new();
        hasher.update(encoded);
        let encoded_hash = hasher.finalize();
    
        // Create the message (url_path + encoded_hash as bytes)
        let mut message = url_path.as_bytes().to_vec();
        message.extend_from_slice(&encoded_hash);
    
        // Create a HMAC-SHA512 object with the base64-decoded secret
        let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
            .expect("HMAC can take key of any size");
    
        // Compute the HMAC of the message
        mac.update(&message);
        let result = mac.finalize();
    
        // Return the base64-encoded HMAC
        let signature = base64::encode(result.into_bytes());
        //println!("Kraken signature:\n{}", signature);
    
        signature
    }


    
    let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

    //kraken asked for 3 headers: key, sign, and content type with its corresponding info
    //.body is nonce because in the Kraken code provided in cURL: 
    //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
    //--data-urlencode "nonce=<YOUR-NONCE>"
    //		this means that nonce is added to the body of the request
    //02/02/24 - removed:
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
        //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
        //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }
//02/02/24 - added in its place:
    let kraken_buy_price_ask: Option<f64>;
    //let mut kraken_sell_price_bid: Option<f64> = None;
    let mut attempts = 0;

    loop {
        attempts += 1;
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            .header("API-Key", kraken_api_key)
            .header("API-Sign", &kraken_signature)
            .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            .body(format!("nonce={}", nonce))
            .build();

        match kraken_basic_request {
            Ok(req) => {
                let kraken_response = client.execute(req).await;
                match kraken_response {
                    Ok(resp) => {
                        let kraken_response_text = resp.text().await;
                        match kraken_response_text {
                            Ok(text) => {
                                match serde_json::from_str::<Value>(&text) {
                                    Ok(v) => {
                                        if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
                                            // Access the ask and bid prices
                                            kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                            //kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                            break;
                                        } else {
                                            if attempts > 3 {
                                                panic!("Failed to parse Kraken response after 3 attempts.");
                                            }
                                            continue;
                                        }
                                    },
                                    Err(_) => {
                                        if attempts > 3 {
                                            panic!("Failed to parse JSON after 3 attempts.");
                                        }
                                        continue;
                                    }
                                }
                            },
                            Err(_) => {
                                if attempts > 3 {
                                    panic!("Failed to read response text after 3 attempts.");
                                }
                                continue;
                            }
                        }
                    },
                    Err(_) => {
                        if attempts > 3 {
                            panic!("Failed to execute Kraken request after 3 attempts.");
                        }
                        continue;
                    }
                }
            },
            Err(_) => {
                if attempts > 3 {
                    panic!("Failed to build Kraken request after 3 attempts.");
                }
                continue;
            }
        }
    }







    println!("xrp 4 kraken coinbase : 8 sec delay");
    let when = tokio::time::Instant::now() + Duration::from_secs(8);
    //02/09/21 - tokio update. changed from delay_until to sleep_until
    tokio::time::sleep_until(when).await;






    //------------COINBASE------------//
    let now = Utc::now();
    let time_stamp = now.timestamp().to_string();
    let method = "GET";
    let request_path = "/api/v3/brokerage/best_bid_ask";
    let body = "";
    let message = format!("{}{}{}{}", &time_stamp, 
    &method, &request_path, &body);
    type HmacSha256 = Hmac<Sha256>;
    fn sign(message: &str, coinbase_secret: &str) -> String {
    let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                .expect("HMAC can take key of any size");
    mac.update(message.as_bytes());
    let result = mac.finalize();
    let code_bytes = result.into_bytes();
    hex::encode(code_bytes)
    }
    let coinbase_signature = sign(&message, &coinbase_secret);

    //01/30/24 - added:
    //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
    //      instead, it will try to do any of the following things it failed 3 times.
    //      if it still doesn't work, then yeah panic.
        //new variables
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        let mut success = true;
    loop {
        attempts +=1;
        let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build();
        //.expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};
        match request {
            Ok(req) => {
        //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                let response = client.execute(req).await;
                match response {
                    Ok(resp) => {
                        let response_text = resp.text().await;
                        match response_text {
                            Ok(text) => {
                                match serde_json::from_str::<Value>(&text) {
                                    Ok(v) => {
                                        if let Some(pricebooks) = v["pricebooks"].as_array() {
                                            for pricebook in pricebooks {
                                                //let product_id = pricebook["product_id"].as_str();
                                                let bids = &pricebook["bids"][0];
                                                //let asks = &pricebook["asks"][0];
                                                let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
    
                                                match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                    (Some(bid_str), /*Some(ask_str)*/) => {
                                                        match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                            (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                coinbase_sell_price_bid = Some(bid_str);
                                                                //coinbase_buy_price_ask = Some(ask_str);

                                                                // Place your calculations and updates here
                                                                    let kraken_taker_fee = 0.0026;
                                                                    let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
                                                                    let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                    let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                    *kraken_wallet -= money_going_to_xrp_after_fees;
                                                                    let amount_of_xrp_before_withdraw_fee = 
                                                                                    money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                        .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                        even though to get to this point it had to be Some. 
                                                                                        Kraken_buy_price_ask: {:?}
                                                                                        Honestly restart the program from the last saved state. 
                                                                                        The most likely error is a bit got flipped after the loop", 
                                                                                        &kraken_buy_price_ask));
                                                                    let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                    //coinbase calculations for sell

                                                                    let coinbase_taker_fee = 0.008;
                                                                    let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                    let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                    *coinbase_wallet += money_from_sell_after_fees;
                                                                    value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
                                                                    println!("in loop print statement. loop iteration:{} value_after = {:?}", &attempts, &value_after);

                                                                    //value_after = 60
                                                                    //coinbase = 61
                                                                    //bitstamp = 62
                                                                    //kraken = 63
                                                                    //gemini = 64
                                                                    //since this is coinbase and kraken being updated, I will update:
                                                                    //  60, 61, 63
                                                                    let indices = [60, 61, 63];
                                                                    let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
                                                                    let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                    neural_network.update_input(&indices, &scaled_values).await;

                                                                    success = true;
                                                            },
                                                            _ => {
                                                                if attempts > 3 {
                                                                    panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                                }
                                                                continue ;
                                                            }
                                                        }
                                                    },
                                                    _ => {
                                                        if attempts > 3 {
                                                            panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
                                                            //panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_coinbase_sell_price_bid, before_parse_coinbase_buy_price_ask);
                                                        }
                                                        continue ;
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    Err(_) => {
                                        if attempts > 3 {
                                            panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                        }
                                        continue ; // Continue to the next iteration if parsing fails
                                    }
                                }
                            },
                            Err(_) => {
                                if attempts > 3 {
                                    panic!("Failed to get response text after 3 attempts");
                                }
                                continue ; // Continue to the next iteration if getting response text fails
                            }
                        }
                    },
                    Err(_) => {
                        if attempts > 3 {
                            panic!("Failed to execute request after 3 attempts");
                        }
                        continue; // Continue to the next iteration if executing request fails
                    }
                }
            },
            Err(_) => {
                if attempts > 3 {
                    panic!("Failed to build request after 3 attempts");
                }
                continue; // Continue to the next iteration if building request fails
            }
        }
        if success == true {
            break;
        }
    }
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


        //    let response_text = response.text().await.expect("Failed to build response_text from response");

        //    //added 12/29/23
        //    //this is the parsing
        //    //01/30/24 - improved error messages to be more detailed in let v: Value
        //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
        //    let mut coinbase_sell_price_bid = 0.0;
        //    let mut coinbase_buy_price_ask = 0.0;

        //    // Access the pricebooks array
        //    if let Some(pricebooks) = v["pricebooks"].as_array() {
        //        // Iterate over each pricebook
        //        for pricebook in pricebooks {
        //            // Access the product_id, bids, and asks
        //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //            let bids = &pricebook["bids"][0];
        //            let asks = &pricebook["asks"][0];
        //            // Access the price and size of the bids and asks
        //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
        //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
        //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
        //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
        //            //println!("Product ID: {}", product_id);
        //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //        }
        //    }
        //}
    //}








        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
        // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        // *kraken_wallet -= money_going_to_xrp_after_fees;
        // let amount_of_xrp_before_withdraw_fee = 
        //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
        // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;





        //coinbase calculations for sell

        // let coinbase_taker_fee = 0.008;
        // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *coinbase_wallet += money_from_sell_after_fees;
        // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


        //     //value_after = 60
        //     //coinbase = 61
        //     //bitstamp = 62
        //     //kraken = 63
        //     //gemini = 64
        //     //since this is coinbase and kraken being updated, I will update:
        //     //  60, 61, 63
        //     let indices = [60, 61, 63];
        //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;


        match value_after {
            Some(value) => return Ok(value),
            None => {
                //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
            }
        }
}

    pub async fn s_i175_xrp_5_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        
        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        //02/02/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    //02/02/24 - added in its place:
        let kraken_buy_price_ask: Option<f64>;
        //let mut kraken_sell_price_bid: Option<f64> = None;
        let mut attempts = 0;

        loop {
            attempts += 1;
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build();

            match kraken_basic_request {
                Ok(req) => {
                    let kraken_response = client.execute(req).await;
                    match kraken_response {
                        Ok(resp) => {
                            let kraken_response_text = resp.text().await;
                            match kraken_response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
                                                // Access the ask and bid prices
                                                kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                //kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                break;
                                            } else {
                                                if attempts > 3 {
                                                    panic!("Failed to parse Kraken response after 3 attempts.");
                                                }
                                                continue;
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts.");
                                            }
                                            continue;
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to read response text after 3 attempts.");
                                    }
                                    continue;
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute Kraken request after 3 attempts.");
                            }
                            continue;
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build Kraken request after 3 attempts.");
                    }
                    continue;
                }
            }
        }







        println!("xrp 5 kraken coinbase : 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;






        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        //01/30/24 - added:
        //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
        //      instead, it will try to do any of the following things it failed 3 times.
        //      if it still doesn't work, then yeah panic.
            //new variables
            let mut attempts = 0;
            let mut coinbase_sell_price_bid: Option<f64> = None;
            //let coinbase_buy_price_ask: Option<f64>;
            let mut value_after: Option<f64> = None;
            let mut success = true;
        loop {
            attempts +=1;
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let kraken_taker_fee = 0.0026;
                                                                        let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                        let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *kraken_wallet -= money_going_to_xrp_after_fees;
                                                                        let amount_of_xrp_before_withdraw_fee = 
                                                                                        money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                            .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                            even though to get to this point it had to be Some. 
                                                                                            Kraken_buy_price_ask: {:?}
                                                                                            Honestly restart the program from the last saved state. 
                                                                                            The most likely error is a bit got flipped after the loop", 
                                                                                            &kraken_buy_price_ask));
                                                                        let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
                                                                        println!("in loop print statement. loop iteration:{} value_after = {:?}", &attempts, &value_after);

                                                                        //value_after = 60
                                                                        //coinbase = 61
                                                                        //bitstamp = 62
                                                                        //kraken = 63
                                                                        //gemini = 64
                                                                        //since this is coinbase and kraken being updated, I will update:
                                                                        //  60, 61, 63
                                                                        let indices = [60, 61, 63];
                                                                        let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
                                                                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                        neural_network.update_input(&indices, &scaled_values).await;

                                                                        success = true;
                                                                },
                                                                _ => {
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                                    }
                                                                    continue ;
                                                                }
                                                            }
                                                        },
                                                        _ => {
                                                            if attempts > 3 {
                                                                panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
                                                                //panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_coinbase_sell_price_bid, before_parse_coinbase_buy_price_ask);
                                                            }
                                                            continue ;
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                            }
                                            continue ; // Continue to the next iteration if parsing fails
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts");
                                    }
                                    continue ; // Continue to the next iteration if getting response text fails
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts");
                            }
                            continue; // Continue to the next iteration if executing request fails
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts");
                    }
                    continue; // Continue to the next iteration if building request fails
                }
            }
            if success == true {
                break;
            }
        }
                //let response = match response {
                //    Ok(resp) => resp,
                //    Err(e) => {
                //        eprintln!("Failed to execute request: \n{}", e);
                //        return Err(e);
                //    }
                //};


            //    let response_text = response.text().await.expect("Failed to build response_text from response");

            //    //added 12/29/23
            //    //this is the parsing
            //    //01/30/24 - improved error messages to be more detailed in let v: Value
            //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
            //    let mut coinbase_sell_price_bid = 0.0;
            //    let mut coinbase_buy_price_ask = 0.0;

            //    // Access the pricebooks array
            //    if let Some(pricebooks) = v["pricebooks"].as_array() {
            //        // Iterate over each pricebook
            //        for pricebook in pricebooks {
            //            // Access the product_id, bids, and asks
            //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //            let bids = &pricebook["bids"][0];
            //            let asks = &pricebook["asks"][0];
            //            // Access the price and size of the bids and asks
            //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
            //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
            //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
            //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
            //            //println!("Product ID: {}", product_id);
            //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //        }
            //    }
            //}
        //}
    
    






            // //kraken calculations - buy
            // let kraken_taker_fee = 0.0026;
            // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
            // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            // let fee_for_purchase = total_spent*kraken_taker_fee;
            // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            // *kraken_wallet -= money_going_to_xrp_after_fees;
            // let amount_of_xrp_before_withdraw_fee = 
            //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
            // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;



    
    
            //coinbase calculations for sell

            // let coinbase_taker_fee = 0.008;
            // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            // *coinbase_wallet += money_from_sell_after_fees;
            // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


            //     //value_after = 60
            //     //coinbase = 61
            //     //bitstamp = 62
            //     //kraken = 63
            //     //gemini = 64
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  60, 61, 63
            //     let indices = [60, 61, 63];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            // //01/24/24 - removed and added:
            //     //neural_network.update_input(&indices, &new_values);
            //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //     //neural_network.update_input(&indices, &transformed_values).await;
            //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //     neural_network.update_input(&indices, &scaled_values).await;


            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
                }
            }
    }

    pub async fn s_i176_xrp_6_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        
        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        //02/02/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    //02/02/24 - added in its place:
        let kraken_buy_price_ask: Option<f64>;
        //let mut kraken_sell_price_bid: Option<f64> = None;
        let mut attempts = 0;

        loop {
            attempts += 1;
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build();

            match kraken_basic_request {
                Ok(req) => {
                    let kraken_response = client.execute(req).await;
                    match kraken_response {
                        Ok(resp) => {
                            let kraken_response_text = resp.text().await;
                            match kraken_response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
                                                // Access the ask and bid prices
                                                kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                //kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                break;
                                            } else {
                                                if attempts > 3 {
                                                    panic!("Failed to parse Kraken response after 3 attempts.");
                                                }
                                                continue;
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts.");
                                            }
                                            continue;
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to read response text after 3 attempts.");
                                    }
                                    continue;
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute Kraken request after 3 attempts.");
                            }
                            continue;
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build Kraken request after 3 attempts.");
                    }
                    continue;
                }
            }
        }







        println!("xrp 6 kraken coinbase : 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;






        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        //01/30/24 - added:
        //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
        //      instead, it will try to do any of the following things it failed 3 times.
        //      if it still doesn't work, then yeah panic.
            //new variables
            let mut attempts = 0;
            let mut coinbase_sell_price_bid: Option<f64> = None;
            //let coinbase_buy_price_ask: Option<f64>;
            let mut value_after: Option<f64> = None;
            let mut success = true;
        loop {
            attempts +=1;
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let kraken_taker_fee = 0.0026;
                                                                        let fraction_of_wallet_im_using = 0.06;  //aka 6 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                        let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *kraken_wallet -= money_going_to_xrp_after_fees;
                                                                        let amount_of_xrp_before_withdraw_fee = 
                                                                                        money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                            .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                            even though to get to this point it had to be Some. 
                                                                                            Kraken_buy_price_ask: {:?}
                                                                                            Honestly restart the program from the last saved state. 
                                                                                            The most likely error is a bit got flipped after the loop", 
                                                                                            &kraken_buy_price_ask));
                                                                        let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
                                                                        println!("in loop print statement. loop iteration:{} value_after = {:?}", &attempts, &value_after);

                                                                        //value_after = 60
                                                                        //coinbase = 61
                                                                        //bitstamp = 62
                                                                        //kraken = 63
                                                                        //gemini = 64
                                                                        //since this is coinbase and kraken being updated, I will update:
                                                                        //  60, 61, 63
                                                                        let indices = [60, 61, 63];
                                                                        let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
                                                                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                        neural_network.update_input(&indices, &scaled_values).await;

                                                                        success = true;
                                                                },
                                                                _ => {
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                                    }
                                                                    continue ;
                                                                }
                                                            }
                                                        },
                                                        _ => {
                                                            if attempts > 3 {
                                                                panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
                                                                //panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_coinbase_sell_price_bid, before_parse_coinbase_buy_price_ask);
                                                            }
                                                            continue ;
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                            }
                                            continue ; // Continue to the next iteration if parsing fails
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts");
                                    }
                                    continue ; // Continue to the next iteration if getting response text fails
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts");
                            }
                            continue; // Continue to the next iteration if executing request fails
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts");
                    }
                    continue; // Continue to the next iteration if building request fails
                }
            }
            if success == true {
                break;
            }
        }
                //let response = match response {
                //    Ok(resp) => resp,
                //    Err(e) => {
                //        eprintln!("Failed to execute request: \n{}", e);
                //        return Err(e);
                //    }
                //};


            //    let response_text = response.text().await.expect("Failed to build response_text from response");

            //    //added 12/29/23
            //    //this is the parsing
            //    //01/30/24 - improved error messages to be more detailed in let v: Value
            //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
            //    let mut coinbase_sell_price_bid = 0.0;
            //    let mut coinbase_buy_price_ask = 0.0;

            //    // Access the pricebooks array
            //    if let Some(pricebooks) = v["pricebooks"].as_array() {
            //        // Iterate over each pricebook
            //        for pricebook in pricebooks {
            //            // Access the product_id, bids, and asks
            //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //            let bids = &pricebook["bids"][0];
            //            let asks = &pricebook["asks"][0];
            //            // Access the price and size of the bids and asks
            //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
            //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
            //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
            //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
            //            //println!("Product ID: {}", product_id);
            //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //        }
            //    }
            //}
        //}
    
    






            // //kraken calculations - buy
            // let kraken_taker_fee = 0.0026;
            // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
            // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            // let fee_for_purchase = total_spent*kraken_taker_fee;
            // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            // *kraken_wallet -= money_going_to_xrp_after_fees;
            // let amount_of_xrp_before_withdraw_fee = 
            //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
            // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;



    
    
            //coinbase calculations for sell

            // let coinbase_taker_fee = 0.008;
            // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            // *coinbase_wallet += money_from_sell_after_fees;
            // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


            //     //value_after = 60
            //     //coinbase = 61
            //     //bitstamp = 62
            //     //kraken = 63
            //     //gemini = 64
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  60, 61, 63
            //     let indices = [60, 61, 63];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            // //01/24/24 - removed and added:
            //     //neural_network.update_input(&indices, &new_values);
            //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //     //neural_network.update_input(&indices, &transformed_values).await;
            //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //     neural_network.update_input(&indices, &scaled_values).await;


            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
                }
            }
    }

    pub async fn s_i177_xrp_7_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        
        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        //02/02/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    //02/02/24 - added in its place:
        let kraken_buy_price_ask: Option<f64>;
        //let mut kraken_sell_price_bid: Option<f64> = None;
        let mut attempts = 0;

        loop {
            attempts += 1;
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build();

            match kraken_basic_request {
                Ok(req) => {
                    let kraken_response = client.execute(req).await;
                    match kraken_response {
                        Ok(resp) => {
                            let kraken_response_text = resp.text().await;
                            match kraken_response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
                                                // Access the ask and bid prices
                                                kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                //kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                break;
                                            } else {
                                                if attempts > 3 {
                                                    panic!("Failed to parse Kraken response after 3 attempts.");
                                                }
                                                continue;
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts.");
                                            }
                                            continue;
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to read response text after 3 attempts.");
                                    }
                                    continue;
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute Kraken request after 3 attempts.");
                            }
                            continue;
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build Kraken request after 3 attempts.");
                    }
                    continue;
                }
            }
        }







        println!("xrp 7 kraken coinbase : 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;






        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        //01/30/24 - added:
        //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
        //      instead, it will try to do any of the following things it failed 3 times.
        //      if it still doesn't work, then yeah panic.
            //new variables
            let mut attempts = 0;
            let mut coinbase_sell_price_bid: Option<f64> = None;
            //let coinbase_buy_price_ask: Option<f64>;
            let mut value_after: Option<f64> = None;
            let mut success = true;
        loop {
            attempts +=1;
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let kraken_taker_fee = 0.0026;
                                                                        let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                        let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *kraken_wallet -= money_going_to_xrp_after_fees;
                                                                        let amount_of_xrp_before_withdraw_fee = 
                                                                                        money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                            .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                            even though to get to this point it had to be Some. 
                                                                                            Kraken_buy_price_ask: {:?}
                                                                                            Honestly restart the program from the last saved state. 
                                                                                            The most likely error is a bit got flipped after the loop", 
                                                                                            &kraken_buy_price_ask));
                                                                        let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
                                                                        println!("in loop print statement. loop iteration:{} value_after = {:?}", &attempts, &value_after);

                                                                        //value_after = 60
                                                                        //coinbase = 61
                                                                        //bitstamp = 62
                                                                        //kraken = 63
                                                                        //gemini = 64
                                                                        //since this is coinbase and kraken being updated, I will update:
                                                                        //  60, 61, 63
                                                                        let indices = [60, 61, 63];
                                                                        let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
                                                                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                        neural_network.update_input(&indices, &scaled_values).await;

                                                                        success = true;
                                                                },
                                                                _ => {
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                                    }
                                                                    continue ;
                                                                }
                                                            }
                                                        },
                                                        _ => {
                                                            if attempts > 3 {
                                                                panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
                                                                //panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_coinbase_sell_price_bid, before_parse_coinbase_buy_price_ask);
                                                            }
                                                            continue ;
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                            }
                                            continue ; // Continue to the next iteration if parsing fails
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts");
                                    }
                                    continue ; // Continue to the next iteration if getting response text fails
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts");
                            }
                            continue; // Continue to the next iteration if executing request fails
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts");
                    }
                    continue; // Continue to the next iteration if building request fails
                }
            }
            if success == true {
                break;
            }
        }
                //let response = match response {
                //    Ok(resp) => resp,
                //    Err(e) => {
                //        eprintln!("Failed to execute request: \n{}", e);
                //        return Err(e);
                //    }
                //};


            //    let response_text = response.text().await.expect("Failed to build response_text from response");

            //    //added 12/29/23
            //    //this is the parsing
            //    //01/30/24 - improved error messages to be more detailed in let v: Value
            //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
            //    let mut coinbase_sell_price_bid = 0.0;
            //    let mut coinbase_buy_price_ask = 0.0;

            //    // Access the pricebooks array
            //    if let Some(pricebooks) = v["pricebooks"].as_array() {
            //        // Iterate over each pricebook
            //        for pricebook in pricebooks {
            //            // Access the product_id, bids, and asks
            //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //            let bids = &pricebook["bids"][0];
            //            let asks = &pricebook["asks"][0];
            //            // Access the price and size of the bids and asks
            //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
            //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
            //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
            //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
            //            //println!("Product ID: {}", product_id);
            //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //        }
            //    }
            //}
        //}
    
    






            // //kraken calculations - buy
            // let kraken_taker_fee = 0.0026;
            // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
            // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            // let fee_for_purchase = total_spent*kraken_taker_fee;
            // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            // *kraken_wallet -= money_going_to_xrp_after_fees;
            // let amount_of_xrp_before_withdraw_fee = 
            //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
            // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;



    
    
            //coinbase calculations for sell

            // let coinbase_taker_fee = 0.008;
            // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            // *coinbase_wallet += money_from_sell_after_fees;
            // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


            //     //value_after = 60
            //     //coinbase = 61
            //     //bitstamp = 62
            //     //kraken = 63
            //     //gemini = 64
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  60, 61, 63
            //     let indices = [60, 61, 63];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            // //01/24/24 - removed and added:
            //     //neural_network.update_input(&indices, &new_values);
            //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //     //neural_network.update_input(&indices, &transformed_values).await;
            //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //     neural_network.update_input(&indices, &scaled_values).await;


            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
                }
            }
    }

    pub async fn s_i178_xrp_8_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        
        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        //02/02/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    //02/02/24 - added in its place:
        let kraken_buy_price_ask: Option<f64>;
        //let mut kraken_sell_price_bid: Option<f64> = None;
        let mut attempts = 0;

        loop {
            attempts += 1;
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build();

            match kraken_basic_request {
                Ok(req) => {
                    let kraken_response = client.execute(req).await;
                    match kraken_response {
                        Ok(resp) => {
                            let kraken_response_text = resp.text().await;
                            match kraken_response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
                                                // Access the ask and bid prices
                                                kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                //kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                break;
                                            } else {
                                                if attempts > 3 {
                                                    panic!("Failed to parse Kraken response after 3 attempts.");
                                                }
                                                continue;
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts.");
                                            }
                                            continue;
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to read response text after 3 attempts.");
                                    }
                                    continue;
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute Kraken request after 3 attempts.");
                            }
                            continue;
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build Kraken request after 3 attempts.");
                    }
                    continue;
                }
            }
        }







        println!("xrp 8 kraken coinbase : 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;






        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        //01/30/24 - added:
        //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
        //      instead, it will try to do any of the following things it failed 3 times.
        //      if it still doesn't work, then yeah panic.
            //new variables
            let mut attempts = 0;
            let mut coinbase_sell_price_bid: Option<f64> = None;
            //let coinbase_buy_price_ask: Option<f64>;
            let mut value_after: Option<f64> = None;
            let mut success = true;
        loop {
            attempts +=1;
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let kraken_taker_fee = 0.0026;
                                                                        let fraction_of_wallet_im_using = 0.08;  //aka 8 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                        let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *kraken_wallet -= money_going_to_xrp_after_fees;
                                                                        let amount_of_xrp_before_withdraw_fee = 
                                                                                        money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                            .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                            even though to get to this point it had to be Some. 
                                                                                            Kraken_buy_price_ask: {:?}
                                                                                            Honestly restart the program from the last saved state. 
                                                                                            The most likely error is a bit got flipped after the loop", 
                                                                                            &kraken_buy_price_ask));
                                                                        let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
                                                                        println!("in loop print statement. loop iteration:{} value_after = {:?}", &attempts, &value_after);

                                                                        //value_after = 60
                                                                        //coinbase = 61
                                                                        //bitstamp = 62
                                                                        //kraken = 63
                                                                        //gemini = 64
                                                                        //since this is coinbase and kraken being updated, I will update:
                                                                        //  60, 61, 63
                                                                        let indices = [60, 61, 63];
                                                                        let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
                                                                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                        neural_network.update_input(&indices, &scaled_values).await;

                                                                        success = true;
                                                                },
                                                                _ => {
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                                    }
                                                                    continue ;
                                                                }
                                                            }
                                                        },
                                                        _ => {
                                                            if attempts > 3 {
                                                                panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
                                                                //panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_coinbase_sell_price_bid, before_parse_coinbase_buy_price_ask);
                                                            }
                                                            continue ;
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                            }
                                            continue ; // Continue to the next iteration if parsing fails
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts");
                                    }
                                    continue ; // Continue to the next iteration if getting response text fails
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts");
                            }
                            continue; // Continue to the next iteration if executing request fails
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts");
                    }
                    continue; // Continue to the next iteration if building request fails
                }
            }
            if success == true {
                break;
            }
        }
                //let response = match response {
                //    Ok(resp) => resp,
                //    Err(e) => {
                //        eprintln!("Failed to execute request: \n{}", e);
                //        return Err(e);
                //    }
                //};


            //    let response_text = response.text().await.expect("Failed to build response_text from response");

            //    //added 12/29/23
            //    //this is the parsing
            //    //01/30/24 - improved error messages to be more detailed in let v: Value
            //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
            //    let mut coinbase_sell_price_bid = 0.0;
            //    let mut coinbase_buy_price_ask = 0.0;

            //    // Access the pricebooks array
            //    if let Some(pricebooks) = v["pricebooks"].as_array() {
            //        // Iterate over each pricebook
            //        for pricebook in pricebooks {
            //            // Access the product_id, bids, and asks
            //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //            let bids = &pricebook["bids"][0];
            //            let asks = &pricebook["asks"][0];
            //            // Access the price and size of the bids and asks
            //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
            //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
            //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
            //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
            //            //println!("Product ID: {}", product_id);
            //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //        }
            //    }
            //}
        //}
    
    






            // //kraken calculations - buy
            // let kraken_taker_fee = 0.0026;
            // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
            // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            // let fee_for_purchase = total_spent*kraken_taker_fee;
            // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            // *kraken_wallet -= money_going_to_xrp_after_fees;
            // let amount_of_xrp_before_withdraw_fee = 
            //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
            // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;



    
    
            //coinbase calculations for sell

            // let coinbase_taker_fee = 0.008;
            // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            // *coinbase_wallet += money_from_sell_after_fees;
            // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


            //     //value_after = 60
            //     //coinbase = 61
            //     //bitstamp = 62
            //     //kraken = 63
            //     //gemini = 64
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  60, 61, 63
            //     let indices = [60, 61, 63];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            // //01/24/24 - removed and added:
            //     //neural_network.update_input(&indices, &new_values);
            //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //     //neural_network.update_input(&indices, &transformed_values).await;
            //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //     neural_network.update_input(&indices, &scaled_values).await;


            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
                }
            }
    }

    pub async fn s_i179_xrp_9_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        
        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        //02/02/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    //02/02/24 - added in its place:
        let kraken_buy_price_ask: Option<f64>;
        //let mut kraken_sell_price_bid: Option<f64> = None;
        let mut attempts = 0;

        loop {
            attempts += 1;
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build();

            match kraken_basic_request {
                Ok(req) => {
                    let kraken_response = client.execute(req).await;
                    match kraken_response {
                        Ok(resp) => {
                            let kraken_response_text = resp.text().await;
                            match kraken_response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
                                                // Access the ask and bid prices
                                                kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                //kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                break;
                                            } else {
                                                if attempts > 3 {
                                                    panic!("Failed to parse Kraken response after 3 attempts.");
                                                }
                                                continue;
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts.");
                                            }
                                            continue;
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to read response text after 3 attempts.");
                                    }
                                    continue;
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute Kraken request after 3 attempts.");
                            }
                            continue;
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build Kraken request after 3 attempts.");
                    }
                    continue;
                }
            }
        }







        println!("xrp 9 kraken coinbase : 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;






        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        //01/30/24 - added:
        //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
        //      instead, it will try to do any of the following things it failed 3 times.
        //      if it still doesn't work, then yeah panic.
            //new variables
            let mut attempts = 0;
            let mut coinbase_sell_price_bid: Option<f64> = None;
            //let coinbase_buy_price_ask: Option<f64>;
            let mut value_after: Option<f64> = None;
            let mut success = true;
        loop {
            attempts +=1;
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let kraken_taker_fee = 0.0026;
                                                                        let fraction_of_wallet_im_using = 0.09;  //aka 9 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                        let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *kraken_wallet -= money_going_to_xrp_after_fees;
                                                                        let amount_of_xrp_before_withdraw_fee = 
                                                                                        money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                            .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                            even though to get to this point it had to be Some. 
                                                                                            Kraken_buy_price_ask: {:?}
                                                                                            Honestly restart the program from the last saved state. 
                                                                                            The most likely error is a bit got flipped after the loop", 
                                                                                            &kraken_buy_price_ask));
                                                                        let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
                                                                        println!("in loop print statement. loop iteration:{} value_after = {:?}", &attempts, &value_after);

                                                                        //value_after = 60
                                                                        //coinbase = 61
                                                                        //bitstamp = 62
                                                                        //kraken = 63
                                                                        //gemini = 64
                                                                        //since this is coinbase and kraken being updated, I will update:
                                                                        //  60, 61, 63
                                                                        let indices = [60, 61, 63];
                                                                        let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
                                                                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                        neural_network.update_input(&indices, &scaled_values).await;

                                                                        success = true;
                                                                },
                                                                _ => {
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                                    }
                                                                    continue ;
                                                                }
                                                            }
                                                        },
                                                        _ => {
                                                            if attempts > 3 {
                                                                panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
                                                                //panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_coinbase_sell_price_bid, before_parse_coinbase_buy_price_ask);
                                                            }
                                                            continue ;
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                            }
                                            continue ; // Continue to the next iteration if parsing fails
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts");
                                    }
                                    continue ; // Continue to the next iteration if getting response text fails
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts");
                            }
                            continue; // Continue to the next iteration if executing request fails
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts");
                    }
                    continue; // Continue to the next iteration if building request fails
                }
            }
            if success == true {
                break;
            }
        }
                //let response = match response {
                //    Ok(resp) => resp,
                //    Err(e) => {
                //        eprintln!("Failed to execute request: \n{}", e);
                //        return Err(e);
                //    }
                //};


            //    let response_text = response.text().await.expect("Failed to build response_text from response");

            //    //added 12/29/23
            //    //this is the parsing
            //    //01/30/24 - improved error messages to be more detailed in let v: Value
            //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
            //    let mut coinbase_sell_price_bid = 0.0;
            //    let mut coinbase_buy_price_ask = 0.0;

            //    // Access the pricebooks array
            //    if let Some(pricebooks) = v["pricebooks"].as_array() {
            //        // Iterate over each pricebook
            //        for pricebook in pricebooks {
            //            // Access the product_id, bids, and asks
            //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //            let bids = &pricebook["bids"][0];
            //            let asks = &pricebook["asks"][0];
            //            // Access the price and size of the bids and asks
            //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
            //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
            //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
            //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
            //            //println!("Product ID: {}", product_id);
            //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //        }
            //    }
            //}
        //}
    
    






            // //kraken calculations - buy
            // let kraken_taker_fee = 0.0026;
            // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
            // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            // let fee_for_purchase = total_spent*kraken_taker_fee;
            // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            // *kraken_wallet -= money_going_to_xrp_after_fees;
            // let amount_of_xrp_before_withdraw_fee = 
            //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
            // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;



    
    
            //coinbase calculations for sell

            // let coinbase_taker_fee = 0.008;
            // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            // *coinbase_wallet += money_from_sell_after_fees;
            // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


            //     //value_after = 60
            //     //coinbase = 61
            //     //bitstamp = 62
            //     //kraken = 63
            //     //gemini = 64
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  60, 61, 63
            //     let indices = [60, 61, 63];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            // //01/24/24 - removed and added:
            //     //neural_network.update_input(&indices, &new_values);
            //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //     //neural_network.update_input(&indices, &transformed_values).await;
            //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //     neural_network.update_input(&indices, &scaled_values).await;


            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
                }
            }
    }

    pub async fn s_i180_xrp_10_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork, divisor: &f64   )-> Result<f64, Box<dyn Error + Send>> {

        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        
        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        //02/02/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    //02/02/24 - added in its place:
        let kraken_buy_price_ask: Option<f64>;
        //let mut kraken_sell_price_bid: Option<f64> = None;
        let mut attempts = 0;

        loop {
            attempts += 1;
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build();

            match kraken_basic_request {
                Ok(req) => {
                    let kraken_response = client.execute(req).await;
                    match kraken_response {
                        Ok(resp) => {
                            let kraken_response_text = resp.text().await;
                            match kraken_response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
                                                // Access the ask and bid prices
                                                kraken_buy_price_ask = xrpusd["a"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                //kraken_sell_price_bid = xrpusd["b"][0].as_str().and_then(|s| s.parse::<f64>().ok());
                                                break;
                                            } else {
                                                if attempts > 3 {
                                                    panic!("Failed to parse Kraken response after 3 attempts.");
                                                }
                                                continue;
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts.");
                                            }
                                            continue;
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to read response text after 3 attempts.");
                                    }
                                    continue;
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute Kraken request after 3 attempts.");
                            }
                            continue;
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build Kraken request after 3 attempts.");
                    }
                    continue;
                }
            }
        }







        println!("xrp 10 kraken coinbase : 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;






        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        //01/30/24 - added:
        //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
        //      instead, it will try to do any of the following things it failed 3 times.
        //      if it still doesn't work, then yeah panic.
            //new variables
            let mut attempts = 0;
            let mut coinbase_sell_price_bid: Option<f64> = None;
            //let coinbase_buy_price_ask: Option<f64>;
            let mut value_after: Option<f64> = None;
            let mut success = true;
        loop {
            attempts +=1;
            let request = client.get("https://coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let kraken_taker_fee = 0.0026;
                                                                        let fraction_of_wallet_im_using = 0.10;  //aka 10 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                        let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *kraken_wallet -= money_going_to_xrp_after_fees;
                                                                        let amount_of_xrp_before_withdraw_fee = 
                                                                                        money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                            .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                            even though to get to this point it had to be Some. 
                                                                                            Kraken_buy_price_ask: {:?}
                                                                                            Honestly restart the program from the last saved state. 
                                                                                            The most likely error is a bit got flipped after the loop", 
                                                                                            &kraken_buy_price_ask));
                                                                        let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
                                                                        println!("in loop print statement. loop iteration:{} value_after = {:?}", &attempts, &value_after);

                                                                        //value_after = 60
                                                                        //coinbase = 61
                                                                        //bitstamp = 62
                                                                        //kraken = 63
                                                                        //gemini = 64
                                                                        //since this is coinbase and kraken being updated, I will update:
                                                                        //  60, 61, 63
                                                                        let indices = [60, 61, 63];
                                                                        let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
                                                                        let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                        neural_network.update_input(&indices, &scaled_values).await;

                                                                        success = true;
                                                                },
                                                                _ => {
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                                    }
                                                                    continue ;
                                                                }
                                                            }
                                                        },
                                                        _ => {
                                                            if attempts > 3 {
                                                                panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
                                                                //panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_coinbase_sell_price_bid, before_parse_coinbase_buy_price_ask);
                                                            }
                                                            continue ;
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        Err(_) => {
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                            }
                                            continue ; // Continue to the next iteration if parsing fails
                                        }
                                    }
                                },
                                Err(_) => {
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts");
                                    }
                                    continue ; // Continue to the next iteration if getting response text fails
                                }
                            }
                        },
                        Err(_) => {
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts");
                            }
                            continue; // Continue to the next iteration if executing request fails
                        }
                    }
                },
                Err(_) => {
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts");
                    }
                    continue; // Continue to the next iteration if building request fails
                }
            }
            if success == true {
                break;
            }
        }
                //let response = match response {
                //    Ok(resp) => resp,
                //    Err(e) => {
                //        eprintln!("Failed to execute request: \n{}", e);
                //        return Err(e);
                //    }
                //};


            //    let response_text = response.text().await.expect("Failed to build response_text from response");

            //    //added 12/29/23
            //    //this is the parsing
            //    //01/30/24 - improved error messages to be more detailed in let v: Value
            //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
            //    let mut coinbase_sell_price_bid = 0.0;
            //    let mut coinbase_buy_price_ask = 0.0;

            //    // Access the pricebooks array
            //    if let Some(pricebooks) = v["pricebooks"].as_array() {
            //        // Iterate over each pricebook
            //        for pricebook in pricebooks {
            //            // Access the product_id, bids, and asks
            //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //            let bids = &pricebook["bids"][0];
            //            let asks = &pricebook["asks"][0];
            //            // Access the price and size of the bids and asks
            //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
            //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
            //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
            //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
            //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
            //            //println!("Product ID: {}", product_id);
            //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //        }
            //    }
            //}
        //}
    
    






            // //kraken calculations - buy
            // let kraken_taker_fee = 0.0026;
            // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
            // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            // let fee_for_purchase = total_spent*kraken_taker_fee;
            // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            // *kraken_wallet -= money_going_to_xrp_after_fees;
            // let amount_of_xrp_before_withdraw_fee = 
            //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
            // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;



    
    
            //coinbase calculations for sell

            // let coinbase_taker_fee = 0.008;
            // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            // *coinbase_wallet += money_from_sell_after_fees;
            // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


            //     //value_after = 60
            //     //coinbase = 61
            //     //bitstamp = 62
            //     //kraken = 63
            //     //gemini = 64
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  60, 61, 63
            //     let indices = [60, 61, 63];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            // //01/24/24 - removed and added:
            //     //neural_network.update_input(&indices, &new_values);
            //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //     //neural_network.update_input(&indices, &transformed_values).await;
            //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //     neural_network.update_input(&indices, &scaled_values).await;


            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
                }
            }
    }



//coinbase - xrp works with just changing the letters XLM or SOL to XRP - 

//kraken - xrp works with minor changes. - 

//bitstamp - xrp works with changes made just to xlm to xrp it seems like. 

//gemini - xrp works with just changing letter












