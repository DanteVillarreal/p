
use chrono::Utc;            //to get time
use hmac::{Hmac, Mac,};	                            //so I can do the signature stuff
use sha2::{Sha256, Sha384, Sha512, Digest};	        //so I can do signature stuff
use hex;
//use reqwest::Client;                                //to actually make the request itself
//use serde_json::Result;                             //for parsing
//use serde::{Deserialize, Serialize};                //for the deserialization/serialization that I need
use serde_json::Value;
use std::error::Error;
use url::form_urlencoded;
use base64;
use base64::encode;
use serde_json::json;                               //use for gemini formatting
use uuid::Uuid;										//this is for bitstamp. part of the input for the signature needs to have a weird nonce
//use std::time::Instant;                             //this is to record time for execution
//02/09/24 - changed from std::time to tokio::time
use tokio::time::Duration;                            //for "sleep"
//use std::thread::sleep;                          
//use tokio::time::delay_for;                       //02/09/24 - tokip updated. not in it

use crate::network::NeuralNetwork;                         //to take in neuralNetwork as parameter
use crate::standardization_functions;

/*
    pub fn nothing() {
        //runs the action according to the index
        //i need to make this wait until the next state begins and then give it a reward?


    }
    //all my functions from this point on are going to be in this format:
    //pub fn [coin]_[percentage, floored]_[exchange to buy]_[exchange to sell] () {}
    pub fn eos_two_coinbase_kraken () -> f64 {
        //this will go to the [coinbase] api, get how much [2%] of my total usd is in it, buy [eos] from there
        //transfer it to [kraken] wallet api, and immediately sell all of it
        //





//------------------I MIGHT PUT THIS IN ANOTHER FUNCTION-----------------------/////
        //----I WILL HAVE TO CHANGE RETURN TYPE OF ABOVE FUNCTION OF COURSE----//
        //then it will calculate how much I spent on the coins.
        //Calculate how much my wallet in the 2nd exchange went up by
        //then subtract 2nd number - 1st number
        //to return a f64 that I will then use in my reward function

        //the reason I made it type    Option<f64> is because I don't want to prematurely
        //    assign a value to it, so if somehow it never gets assigned a value,
        //    I can then handle the situation.
        let how_much_i_spent: Option<f64>;
        match how_much_i_spent {
            Some(_) => (),
            None => panic!("how_much_i_spent   is none"),
        }
        let how_much_2nd_wallet_changed: Option<f64>;           //same thing as above^^
        match how_much_2nd_wallet_changed {
            Some(_) => (),
            None => panic!("how_much_2nd_wallet_changed    is none"),
        }

        //can't directly subtract Option types. So I need to handle the possiblity that
        //how_much_i_spent    and/or    how_much_2nd_wallet_changed    could carry no value
        //adds another layer of redundancy, which is always good
        let total_gained = match(how_much_i_spent, how_much_2nd_wallet_changed) {
            (Some(spent), Some(gained)) => Some(gained-spent),
            _ => None,
        };

        //at this point in the code, I have now returned the f64 I waned
        //now I will use this f64 for the reward function

//-----------ABOVE----------------------------------------------------------///////

    }

    pub fn eos_two_coinbase_pionex () {

    }

    pub fn eos_two_kraken_coinbase () {

    }
    //rest of eos_two
    pub fn eos_three
    //rest of eos_three

    pub fn eos_four
    //rest of eos_four

    pub fn eos_five
    //rest of eos_five

    pub fn eos_six
    //rest of eos_six

    pub fn eos_seven
    //rest of eos_seven







*/
    //function format:
    //s = sandbox
    //i# = index followed by the number
    //then coin name
    //then percentage
    //then [exchange buy]
    //then [exchange sell]

    pub fn s_i0_do_nothing(value_prior: &f64) -> Result<f64, Box<dyn Error + Send>>{
        //03/10/24 - removed standardization function because we only standardize it when
        //      we want to update the input. since the input doesnt change, nothing to update
		    //Ok(standardization_functions::normal_value_prior_standardization(&value_prior))
        Ok(*value_prior)
    }
    //cant use 1 through 4 because minimum Kraken buy is 0.2 SOL
    /*
    pub async fn s_i1_sol_1_coinbase_kraken(coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        let right_now = Instant::now();   //to measure execution time
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        //let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                //let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                //coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                //println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);










        //this will serve as the 2.5 second transfer speed to kraken
        //will do 3 seconds though so I have 500 miliseconds window that will make my
        //       AI be even better
        //sleep(Duration::from_secs(3));
        delay_for(Duration::from_secs(3)).await;











        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        //let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            //kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            let coinbase_taker_fee = 0.008;

            let total_spent = 0.01*(*coinbase_wallet);
            let fee_for_purchase = total_spent*coinbase_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            *coinbase_wallet -= total_spent;
            let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            let kraken_taker_fee = 0.0026;
            
            let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            *kraken_wallet += money_from_sell_after_fees;

            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


        //this will count as value after

            let elapsed = right_now.elapsed();
            println!("Elapsed: {:?}", elapsed);

            return Ok(value_after)

     }

     pub async fn s_i2_sol_2_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
    
            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            //let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text)?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.02*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
    
    
                return Ok(value_after)
        
    }

    pub async fn s_i3_sol_3_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            //let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text)?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.03*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
    
    
                return Ok(value_after)

    }

    pub async fn s_i4_sol_4_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            //let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    //let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    //let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    //coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    //let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    //println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
            let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build()
                    .expect("Failed to build kraken request");
    
    
            let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            let v: Value = serde_json::from_str(&kraken_response_text)?;
            //let mut kraken_buy_price_ask = 0.0;
            let mut kraken_sell_price_bid = 0.0;
            if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
                // Access the ask and bid prices
                //kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
                kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
                //println!("Ask price: {}", kraken_buy_price_ask);
                //println!("Bid price: {}", kraken_sell_price_bid );
            }
            else {
                println!("didnt parse kraken correctly.");
            }
    
            //println!("response:\n{:?}", kraken_response_text);
            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.04*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            //this will count as value after
    
    
    
            return Ok(value_after)

    }
    */
    pub async fn s_i5_sol_5_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
		//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    

	//03/02/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match  before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match  ask_str.parse::<f64>() {
																 Ok(ask_str) => {
																	coinbase_buy_price_ask = Some(ask_str);

																		success = true;
																},
																Err(e) => {
																	log::error!("i5: coinbase: failed to parse JSON. attempt: {} Response text: {}
                                                                    error: {}", &attempts, text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
																	}
                                                                    log::error!("10secwait");
                                                                    let when = tokio::time::Instant::now() +
                                                                        tokio::time::Duration::from_secs(10);
                                                                    tokio::time::sleep_until(when).await;
																	continue ;
																}
															}
														},
														None => {
															log::error!("i5: coinbase: failed to to get ask price. attempt: {} Response text: {}", &attempts, text);
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get ask price after {} attempts. Ask: {:?}", &attempts, before_parse_coinbase_buy_price_ask);
															}
                                                            log::error!("i5 coinbase: 10 sec wait for coinbase ask price error");
                                                            let when = tokio::time::Instant::now() +
                                                                tokio::time::Duration::from_secs(10);
                                                            tokio::time::sleep_until(when).await;
															continue ;
														}
													}
												}
											} else {
												log::error!("i5: coinbase: Failed to get pricebooks as array. attempt: {} Response text: {}",&attempts, text);
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after {} attempts. Response text: {}", &attempts, text);
												}
                                                log::error!("i5 coinbase: 10 sec wait for coinbase pricebooks error. current attempt #: {}", &attempts);
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue;
											}
										},
										Err(e) => {
											log::error!("i5: coinbase: failed to parse JSON outer. attempt: {} Response text: {}
                                            error: {}", &attempts, text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
											}
                                            log::error!("10 sec wait for i5 error. current attempt #: {}", &attempts);
                                            let when = tokio::time::Instant::now() +
                                                tokio::time::Duration::from_secs(10);
                                            tokio::time::sleep_until(when).await;
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i5: coinbase: Failed to get response text. attempt: {}. error: {}", &attempts, e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. ", &attempts);
									}
                                    log::error!("10 sec wait for i5 coinbase error. current attempt #: {}", &attempts);
                                    let when = tokio::time::Instant::now() +
                                        tokio::time::Duration::from_secs(10);
                                    tokio::time::sleep_until(when).await;
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i5: coinbase: Failed to execute request. attempt: {}. error: {}", &attempts, e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts", &attempts);
							}
                            log::error!("10 sec wait for i5 coinbase error. current attempt #: {}", &attempts);
                            let when = tokio::time::Instant::now() +
                                tokio::time::Duration::from_secs(10);
                            tokio::time::sleep_until(when).await;
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i5: coinbase: Failed to build request {} attempts. error: {}", &attempts, e);
					if attempts > 3 {
						panic!("Failed to build request after {} attempts", &attempts);
					}
                    log::error!("10 sec wait for i5 coinbase loop. current attempt #: {}", &attempts);
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}

		}










    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 5 coinbase kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
		//03/02/24 - removed:	
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match  bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.05; //aka 5 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after

																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {
																					//03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;


																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					

																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is kraken and gemini being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																	}
																	else {
																		log::error!("i5: Kraken sell price is None. attempt: {} Response text was: {}", &attempts, kraken_response_text);
																	}
																} 
																else {
																	log::error!("i5: Coinbase buy ask is None.attempt: {} Response text was: {}", &attempts, kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i5: Failed to parse ask or bid as f64 {} attempts\nError: {}
                                                            response text: {}", &attempts, e, kraken_response_text),
														}
													},
													None => log::error!("i5: Failed to get bid as string{} attempts
                                                    response text: {}", &attempts, kraken_response_text),
												}										
											} 
											else {
												log::error!("i5: Didn't parse Kraken correctly. attempt: {} Response text was: {}", &attempts, kraken_response_text);
											}
										},
										Err(e) => log::error!("i5: Failed to parse JSON. attempt: {} Error was: {}. Response text was: {}", &attempts, e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i5: Failed to read response text. attempt: {} Error was: {}", &attempts, e),
							}
						},
						Err(e) => log::error!("i5: Failed to execute Kraken request. attempt: {}Error was: {}", &attempts, e),
					}
				},
				Err(e) => log::error!("i5: Failed to build kraken request. attempt: {}Error was: {}", &attempts, e),
			}
            //03/13/24 - removed. not needed since it will only break if it returns
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10 sec wait for i5 kraken loop error.");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


















		//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
    
            //     let total_spent = 0.05*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            // //this will count as value after
    
    
    
            //     return Ok(value_after)
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }
    }

    pub async fn s_i6_sol_6_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
		//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    

	//03/02/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match  before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match  ask_str.parse::<f64>() {
																 Ok(ask_str) => {
																	coinbase_buy_price_ask = Some(ask_str);

																		success = true;
																},
																Err(e) => {
																	log::error!("i6: coinbase: failed to parse JSON. attempt: {} Response text: {}
                                                                    error: {}", &attempts, text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
																	}
                                                                    log::error!("10secwait");
                                                                    let when = tokio::time::Instant::now() +
                                                                        tokio::time::Duration::from_secs(10);
                                                                    tokio::time::sleep_until(when).await;
																	continue ;
																}
															}
														},
														None => {
															log::error!("i6: coinbase: failed to to get ask price. attempt: {} Response text: {}", &attempts, text);
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get ask price after {} attempts. Ask: {:?}", &attempts, before_parse_coinbase_buy_price_ask);
															}
                                                            log::error!("i5 coinbase: 10 sec wait for coinbase ask price error");
                                                            let when = tokio::time::Instant::now() +
                                                                tokio::time::Duration::from_secs(10);
                                                            tokio::time::sleep_until(when).await;
															continue ;
														}
													}
												}
											} else {
												log::error!("i6: coinbase: Failed to get pricebooks as array. attempt: {} Response text: {}",&attempts, text);
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after {} attempts. Response text: {}", &attempts, text);
												}
                                                log::error!("10 sec wait ");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue;
											}
										},
										Err(e) => {
											log::error!("i6: coinbase: failed to parse JSON outer. attempt: {} Response text: {}
                                            error: {}", &attempts, text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
											}
                                            log::error!("10 sec wait ");
                                            let when = tokio::time::Instant::now() +
                                                tokio::time::Duration::from_secs(10);
                                            tokio::time::sleep_until(when).await;
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i6: coinbase: Failed to get response text. attempt: {}. error: {}", &attempts, e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. ", &attempts);
									}
                                    log::error!("10 sec wait");
                                    let when = tokio::time::Instant::now() +
                                        tokio::time::Duration::from_secs(10);
                                    tokio::time::sleep_until(when).await;
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i6: coinbase: Failed to execute request. attempt: {}. error: {}", &attempts, e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts", &attempts);
							}
                            log::error!("10 sec wait for i6 coinbase error. current attempt #: {}", &attempts);
                            let when = tokio::time::Instant::now() +
                                tokio::time::Duration::from_secs(10);
                            tokio::time::sleep_until(when).await;
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i6: coinbase: Failed to build request {} attempts. error: {}", &attempts, e);
					if attempts > 3 {
						panic!("Failed to build request after {} attempts", &attempts);
					}
                    log::error!("10 sec wait for i6 coinbase loop. current attempt #: {}", &attempts);
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}

		}










    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 6 coinbase kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
		//03/02/24 - removed:	
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match  bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.06; //aka 6 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after

																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {
																					//03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;


																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					

																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is kraken and gemini being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																	}
																	else {
																		log::error!("i6: Kraken sell price is None. attempt: {} Response text was: {}", &attempts, kraken_response_text);
																	}
																} 
																else {
																	log::error!("i6: Coinbase buy ask is None.attempt: {} Response text was: {}", &attempts, kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i6: Failed to parse ask or bid as f64 {} attempts\nError: {}
                                                            response text: {}", &attempts, e, kraken_response_text),
														}
													},
													None => log::error!("i6: Failed to get bid as string{} attempts
                                                    response text: {}", &attempts, kraken_response_text),
												}										
											} 
											else {
												log::error!("i6: Didn't parse Kraken correctly. attempt: {} Response text was: {}", &attempts, kraken_response_text);
											}
										},
										Err(e) => log::error!("i6: Failed to parse JSON. attempt: {} Error was: {}. Response text was: {}", &attempts, e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i6: Failed to read response text. attempt: {} Error was: {}", &attempts, e),
							}
						},
						Err(e) => log::error!("i6: Failed to execute Kraken request. attempt: {}Error was: {}", &attempts, e),
					}
				},
				Err(e) => log::error!("i6: Failed to build kraken request. attempt: {}Error was: {}", &attempts, e),
			}
            //03/13/24 - removed. not needed since it will only break if it returns
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10 sec wait for i6 kraken loop error.");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


















		//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
    
            //     let total_spent = 0.05*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            // //this will count as value after
    
    
    
            //     return Ok(value_after)
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }
    }

    pub async fn s_i7_sol_7_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
		//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    

	//03/02/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match  before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match  ask_str.parse::<f64>() {
																 Ok(ask_str) => {
																	coinbase_buy_price_ask = Some(ask_str);

																		success = true;
																},
																Err(e) => {
																	log::error!("i7: coinbase: failed to parse JSON. attempt: {} Response text: {}
                                                                    error: {}", &attempts, text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
																	}
                                                                    log::error!("10secwait");
                                                                    let when = tokio::time::Instant::now() +
                                                                        tokio::time::Duration::from_secs(10);
                                                                    tokio::time::sleep_until(when).await;
																	continue ;
																}
															}
														},
														None => {
															log::error!("i7: coinbase: failed to to get ask price. attempt: {} Response text: {}", &attempts, text);
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get ask price after {} attempts. Ask: {:?}", &attempts, before_parse_coinbase_buy_price_ask);
															}
                                                            log::error!("10SECWAIT");
                                                            let when = tokio::time::Instant::now() +
                                                                tokio::time::Duration::from_secs(10);
                                                            tokio::time::sleep_until(when).await;
															continue ;
														}
													}
												}
											} else {
												log::error!("i7: coinbase: Failed to get pricebooks as array. attempt: {} Response text: {}",&attempts, text);
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after {} attempts. Response text: {}", &attempts, text);
												}
                                                log::error!("10 sec wait ");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue;
											}
										},
										Err(e) => {
											log::error!("i7: coinbase: failed to parse JSON outer. attempt: {} Response text: {}
                                            error: {}", &attempts, text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
											}
                                            log::error!("10 sec wait ");
                                            let when = tokio::time::Instant::now() +
                                                tokio::time::Duration::from_secs(10);
                                            tokio::time::sleep_until(when).await;
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i7: coinbase: Failed to get response text. attempt: {}. error: {}", &attempts, e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. ", &attempts);
									}
                                    log::error!("10 sec wait");
                                    let when = tokio::time::Instant::now() +
                                        tokio::time::Duration::from_secs(10);
                                    tokio::time::sleep_until(when).await;
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i7: coinbase: Failed to execute request. attempt: {}. error: {}", &attempts, e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts", &attempts);
							}
                            log::error!("10 sec wait for i6 coinbase error. current attempt #: {}", &attempts);
                            let when = tokio::time::Instant::now() +
                                tokio::time::Duration::from_secs(10);
                            tokio::time::sleep_until(when).await;
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i7: coinbase: Failed to build request {} attempts. error: {}", &attempts, e);
					if attempts > 3 {
						panic!("Failed to build request after {} attempts", &attempts);
					}
                    log::error!("10 sec wait for i7 coinbase loop. current attempt #: {}", &attempts);
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}

		}










    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 7 coinbase kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
		//03/02/24 - removed:	
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match  bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.07; //aka 7 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after

																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {
																					//03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;


																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					

																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is kraken and gemini being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																	}
																	else {
																		log::error!("i7: Kraken sell price is None. attempt: {} Response text was: {}", &attempts, kraken_response_text);
																	}
																} 
																else {
																	log::error!("i7: Coinbase buy ask is None.attempt: {} Response text was: {}", &attempts, kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i7: Failed to parse ask or bid as f64 {} attempts\nError: {}
                                                            response text: {}", &attempts, e, kraken_response_text),
														}
													},
													None => log::error!("i7: Failed to get bid as string{} attempts
                                                    response text: {}", &attempts, kraken_response_text),
												}										
											} 
											else {
												log::error!("i7: Didn't parse Kraken correctly. attempt: {} Response text was: {}", &attempts, kraken_response_text);
											}
										},
										Err(e) => log::error!("i7: Failed to parse JSON. attempt: {} Error was: {}. Response text was: {}", &attempts, e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i7: Failed to read response text. attempt: {} Error was: {}", &attempts, e),
							}
						},
						Err(e) => log::error!("i7: Failed to execute Kraken request. attempt: {}Error was: {}", &attempts, e),
					}
				},
				Err(e) => log::error!("i7: Failed to build kraken request. attempt: {}Error was: {}", &attempts, e),
			}
            //03/13/24 - removed. not needed since it will only break if it returns
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10 sec wait for i7 kraken loop error.");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


















		//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
    
            //     let total_spent = 0.05*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            // //this will count as value after
    
    
    
            //     return Ok(value_after)
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }
    }

    pub async fn s_i8_sol_8_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
		//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    

	//03/02/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match  before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match  ask_str.parse::<f64>() {
																 Ok(ask_str) => {
																	coinbase_buy_price_ask = Some(ask_str);

																		success = true;
																},
																Err(e) => {
																	log::error!("i8: coinbase: failed to parse JSON. attempt: {} Response text: {}
                                                                    error: {}", &attempts, text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
																	}
                                                                    log::error!("10secwait");
                                                                    let when = tokio::time::Instant::now() +
                                                                        tokio::time::Duration::from_secs(10);
                                                                    tokio::time::sleep_until(when).await;
																	continue ;
																}
															}
														},
														None => {
															log::error!("i8: coinbase: failed to to get ask price. attempt: {} Response text: {}", &attempts, text);
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get ask price after {} attempts. Ask: {:?}", &attempts, before_parse_coinbase_buy_price_ask);
															}
                                                            log::error!("10SECWAIT");
                                                            let when = tokio::time::Instant::now() +
                                                                tokio::time::Duration::from_secs(10);
                                                            tokio::time::sleep_until(when).await;
															continue ;
														}
													}
												}
											} else {
												log::error!("i8: coinbase: Failed to get pricebooks as array. attempt: {} Response text: {}",&attempts, text);
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after {} attempts. Response text: {}", &attempts, text);
												}
                                                log::error!("10 sec wait ");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue;
											}
										},
										Err(e) => {
											log::error!("i8: coinbase: failed to parse JSON outer. attempt: {} Response text: {}
                                            error: {}", &attempts, text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
											}
                                            log::error!("10 sec wait ");
                                            let when = tokio::time::Instant::now() +
                                                tokio::time::Duration::from_secs(10);
                                            tokio::time::sleep_until(when).await;
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i8: coinbase: Failed to get response text. attempt: {}. error: {}", &attempts, e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. ", &attempts);
									}
                                    log::error!("10 sec wait");
                                    let when = tokio::time::Instant::now() +
                                        tokio::time::Duration::from_secs(10);
                                    tokio::time::sleep_until(when).await;
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i8: coinbase: Failed to execute request. attempt: {}. error: {}", &attempts, e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts", &attempts);
							}
                            log::error!("10 sec wait for i6 coinbase error. current attempt #: {}", &attempts);
                            let when = tokio::time::Instant::now() +
                                tokio::time::Duration::from_secs(10);
                            tokio::time::sleep_until(when).await;
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i8: coinbase: Failed to build request {} attempts. error: {}", &attempts, e);
					if attempts > 3 {
						panic!("Failed to build request after {} attempts", &attempts);
					}
                    log::error!("10 sec wait for i7 coinbase loop. current attempt #: {}", &attempts);
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}

		}










    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 8 coinbase kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
		//03/02/24 - removed:	
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match  bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.08; //aka 8 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after

																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {
																					//03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;


																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					

																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is kraken and gemini being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																	}
																	else {
																		log::error!("i8: Kraken sell price is None. attempt: {} Response text was: {}", &attempts, kraken_response_text);
																	}
																} 
																else {
																	log::error!("i8: Coinbase buy ask is None.attempt: {} Response text was: {}", &attempts, kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i7: Failed to parse ask or bid as f64 {} attempts\nError: {}
                                                            response text: {}", &attempts, e, kraken_response_text),
														}
													},
													None => log::error!("i8: Failed to get bid as string{} attempts
                                                    response text: {}", &attempts, kraken_response_text),
												}										
											} 
											else {
												log::error!("i8: Didn't parse Kraken correctly. attempt: {} Response text was: {}", &attempts, kraken_response_text);
											}
										},
										Err(e) => log::error!("i8: Failed to parse JSON. attempt: {} Error was: {}. Response text was: {}", &attempts, e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i8: Failed to read response text. attempt: {} Error was: {}", &attempts, e),
							}
						},
						Err(e) => log::error!("i8: Failed to execute Kraken request. attempt: {}Error was: {}", &attempts, e),
					}
				},
				Err(e) => log::error!("i8: Failed to build kraken request. attempt: {}Error was: {}", &attempts, e),
			}
            //03/13/24 - removed. not needed since it will only break if it returns
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10 sec wait for i8 kraken loop error.");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


















		//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
    
            //     let total_spent = 0.05*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            // //this will count as value after
    
    
    
            //     return Ok(value_after)
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }
    }

    pub async fn s_i9_sol_9_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
		//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    

	//03/02/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match  before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match  ask_str.parse::<f64>() {
																 Ok(ask_str) => {
																	coinbase_buy_price_ask = Some(ask_str);

																		success = true;
																},
																Err(e) => {
																	log::error!("i9: coinbase: failed to parse JSON. attempt: {} Response text: {}
                                                                    error: {}", &attempts, text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
																	}
                                                                    log::error!("10secwait");
                                                                    let when = tokio::time::Instant::now() +
                                                                        tokio::time::Duration::from_secs(10);
                                                                    tokio::time::sleep_until(when).await;
																	continue ;
																}
															}
														},
														None => {
															log::error!("i9: coinbase: failed to to get ask price. attempt: {} Response text: {}", &attempts, text);
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get ask price after {} attempts. Ask: {:?}", &attempts, before_parse_coinbase_buy_price_ask);
															}
                                                            log::error!("10SECWAIT");
                                                            let when = tokio::time::Instant::now() +
                                                                tokio::time::Duration::from_secs(10);
                                                            tokio::time::sleep_until(when).await;
															continue ;
														}
													}
												}
											} else {
												log::error!("i9: coinbase: Failed to get pricebooks as array. attempt: {} Response text: {}",&attempts, text);
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after {} attempts. Response text: {}", &attempts, text);
												}
                                                log::error!("10 sec wait ");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue;
											}
										},
										Err(e) => {
											log::error!("i9: coinbase: failed to parse JSON outer. attempt: {} Response text: {}
                                            error: {}", &attempts, text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
											}
                                            log::error!("10 sec wait ");
                                            let when = tokio::time::Instant::now() +
                                                tokio::time::Duration::from_secs(10);
                                            tokio::time::sleep_until(when).await;
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i9: coinbase: Failed to get response text. attempt: {}. error: {}", &attempts, e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. ", &attempts);
									}
                                    log::error!("10 sec wait");
                                    let when = tokio::time::Instant::now() +
                                        tokio::time::Duration::from_secs(10);
                                    tokio::time::sleep_until(when).await;
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i9: coinbase: Failed to execute request. attempt: {}. error: {}", &attempts, e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts", &attempts);
							}
                            log::error!("10 sec wait for i6 coinbase error. current attempt #: {}", &attempts);
                            let when = tokio::time::Instant::now() +
                                tokio::time::Duration::from_secs(10);
                            tokio::time::sleep_until(when).await;
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i9: coinbase: Failed to build request {} attempts. error: {}", &attempts, e);
					if attempts > 3 {
						panic!("Failed to build request after {} attempts", &attempts);
					}
                    log::error!("10 sec wait for i9 coinbase loop. current attempt #: {}", &attempts);
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}

		}










    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 9 coinbase kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
		//03/02/24 - removed:	
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match  bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.09; //aka 9 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after

																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {
																					//03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;


																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					

																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is kraken and gemini being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																	}
																	else {
																		log::error!("i9: Kraken sell price is None. attempt: {} Response text was: {}", &attempts, kraken_response_text);
																	}
																} 
																else {
																	log::error!("i9: Coinbase buy ask is None.attempt: {} Response text was: {}", &attempts, kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i9: Failed to parse ask or bid as f64 {} attempts\nError: {}
                                                            response text: {}", &attempts, e, kraken_response_text),
														}
													},
													None => log::error!("i9: Failed to get bid as string{} attempts
                                                    response text: {}", &attempts, kraken_response_text),
												}										
											} 
											else {
												log::error!("i7: Didn't parse Kraken correctly. attempt: {} Response text was: {}", &attempts, kraken_response_text);
											}
										},
										Err(e) => log::error!("i9: Failed to parse JSON. attempt: {} Error was: {}. Response text was: {}", &attempts, e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i9: Failed to read response text. attempt: {} Error was: {}", &attempts, e),
							}
						},
						Err(e) => log::error!("i9: Failed to execute Kraken request. attempt: {}Error was: {}", &attempts, e),
					}
				},
				Err(e) => log::error!("i9: Failed to build kraken request. attempt: {}Error was: {}", &attempts, e),
			}
            //03/13/24 - removed. not needed since it will only break if it returns
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10 sec wait for i9 kraken loop error.");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


















		//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
    
            //     let total_spent = 0.05*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            // //this will count as value after
    
    
    
            //     return Ok(value_after)
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }
    }

    pub async fn s_i10_sol_10_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
		//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    

	//03/02/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match  before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match  ask_str.parse::<f64>() {
																 Ok(ask_str) => {
																	coinbase_buy_price_ask = Some(ask_str);

																		success = true;
																},
																Err(e) => {
																	log::error!("i10: coinbase: failed to parse JSON. attempt: {} Response text: {}
                                                                    error: {}", &attempts, text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
																	}
                                                                    log::error!("10secwait");
                                                                    let when = tokio::time::Instant::now() +
                                                                        tokio::time::Duration::from_secs(10);
                                                                    tokio::time::sleep_until(when).await;
																	continue ;
																}
															}
														},
														None => {
															log::error!("i10: coinbase: failed to to get ask price. attempt: {} Response text: {}", &attempts, text);
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get ask price after {} attempts. Ask: {:?}", &attempts, before_parse_coinbase_buy_price_ask);
															}
                                                            log::error!("10SECWAIT");
                                                            let when = tokio::time::Instant::now() +
                                                                tokio::time::Duration::from_secs(10);
                                                            tokio::time::sleep_until(when).await;
															continue ;
														}
													}
												}
											} else {
												log::error!("i10: coinbase: Failed to get pricebooks as array. attempt: {} Response text: {}",&attempts, text);
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after {} attempts. Response text: {}", &attempts, text);
												}
                                                log::error!("10 sec wait ");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue;
											}
										},
										Err(e) => {
											log::error!("i10: coinbase: failed to parse JSON outer. attempt: {} Response text: {}
                                            error: {}", &attempts, text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}", &attempts, text);
											}
                                            log::error!("10 sec wait ");
                                            let when = tokio::time::Instant::now() +
                                                tokio::time::Duration::from_secs(10);
                                            tokio::time::sleep_until(when).await;
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i10: coinbase: Failed to get response text. attempt: {}. error: {}", &attempts, e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. ", &attempts);
									}
                                    log::error!("10 sec wait");
                                    let when = tokio::time::Instant::now() +
                                        tokio::time::Duration::from_secs(10);
                                    tokio::time::sleep_until(when).await;
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i10: coinbase: Failed to execute request. attempt: {}. error: {}", &attempts, e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts", &attempts);
							}
                            log::error!("10 sec wait for i6 coinbase error. current attempt #: {}", &attempts);
                            let when = tokio::time::Instant::now() +
                                tokio::time::Duration::from_secs(10);
                            tokio::time::sleep_until(when).await;
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i10: coinbase: Failed to build request {} attempts. error: {}", &attempts, e);
					if attempts > 3 {
						panic!("Failed to build request after {} attempts", &attempts);
					}
                    log::error!("10 sec wait for i10 coinbase loop. current attempt #: {}", &attempts);
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}

		}










    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 10 coinbase kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;
    
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=SOLUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                println!("Nonce:\n{}", nonce_str);
                println!("Encoded payload:\n{}", post_data);
                println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
		//03/02/24 - removed:	
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
    
            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match  bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.10; //aka 10 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after

																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {
																					//03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;


																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					

																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is kraken and gemini being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																	}
																	else {
																		log::error!("i10: Kraken sell price is None. attempt: {} Response text was: {}", &attempts, kraken_response_text);
																	}
																} 
																else {
																	log::error!("i10: Coinbase buy ask is None.attempt: {} Response text was: {}", &attempts, kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i10: Failed to parse ask or bid as f64 {} attempts\nError: {}
                                                            response text: {}", &attempts, e, kraken_response_text),
														}
													},
													None => log::error!("i10: Failed to get bid as string{} attempts
                                                    response text: {}", &attempts, kraken_response_text),
												}										
											} 
											else {
												log::error!("i10: Didn't parse Kraken correctly. attempt: {} Response text was: {}", &attempts, kraken_response_text);
											}
										},
										Err(e) => log::error!("i10: Failed to parse JSON. attempt: {} Error was: {}. Response text was: {}", &attempts, e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i10: Failed to read response text. attempt: {} Error was: {}", &attempts, e),
							}
						},
						Err(e) => log::error!("i10: Failed to execute Kraken request. attempt: {}Error was: {}", &attempts, e),
					}
				},
				Err(e) => log::error!("i10: Failed to build kraken request. attempt: {}Error was: {}", &attempts, e),
			}
            //03/13/24 - removed. not needed since it will only break if it returns
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10 sec wait for i10 kraken loop error.");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


















		//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
    
            //     let total_spent = 0.05*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            // //this will count as value after
    
    
    
            //     return Ok(value_after)
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }
    }
    //coinbase has 10 dollar minimum order size:
//https://www.businessinsider.com/personal-finance/bitstamp-crypto-exchange-review#:~:text=Bitstamp%20has%20a%20%240%20minimum,of%20more%20than%20%24100%20million).
    /*
    pub async fn s_i11_sol_1_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.01*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
    
                return Ok(value_after)

    }

    pub async fn s_i12_sol_2_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
            delay_for(Duration::from_secs(3)).await;
    
    
    
    
    
    
    
    
    
    
    
    //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------Account-balances------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	println!("Bitstamp:\n{:?}", bitstamp_response_text);
            
    


            //coinbase calculations
                let coinbase_taker_fee = 0.008;
    
                let total_spent = 0.02*(*coinbase_wallet);
                let fee_for_purchase = total_spent*coinbase_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of coinbase wallet below
                *coinbase_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
    
                return Ok(value_after)

    }
    */
    //begin removal
//     pub async fn s_i13_sol_3_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
//         gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
// 			//03/02/24 - added:
//             // let now = Utc::now();
//             // let time_stamp = now.timestamp().to_string();
//             // let method = "GET";
//             // let request_path = "/api/v3/brokerage/best_bid_ask";
//             // let body = "";
//             // let message = format!("{}{}{}{}", &time_stamp, 
//             // &method, &request_path, &body);
//             // type HmacSha256 = Hmac<Sha256>;
//             // fn sign(message: &str, coinbase_secret: &str) -> String {
//             // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
//             //             .expect("HMAC can take key of any size");
//             // mac.update(message.as_bytes());
//             // let result = mac.finalize();
//             // let code_bytes = result.into_bytes();
//             // hex::encode(code_bytes)
//             // }
//             // let coinbase_signature = sign(&message, &coinbase_secret);    
//             // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
//             // .header("CB-ACCESS-KEY", coinbase_api_key)
//             // .header("CB-ACCESS-SIGN", &coinbase_signature)
//             // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
//             // .build()
//             // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //manages the error I described above
//             // //let request = match request {
//             // //Ok(req) => req,
//             // //Err(e) => {
//             // //eprintln!("Failed to build request: \n{}", e);
//             // //return Err(e);
//             // //}
//             // //};    
//             // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //let response = match response {
//             // //    Ok(resp) => resp,
//             // //    Err(e) => {
//             // //        eprintln!("Failed to execute request: \n{}", e);
//             // //        return Err(e);
//             // //    }
//             // //};   
//             // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;    
//             // //added 12/29/23
//             // //this is the parsing
//             // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // let mut coinbase_sell_price = 0.0;
//             // let mut coinbase_buy_price = 0.0;    
//             // // Access the pricebooks array
//             // if let Some(pricebooks) = v["pricebooks"].as_array() {
//             //     // Iterate over each pricebook
//             //     for pricebook in pricebooks {
//             //         // Access the product_id, bids, and asks
//             //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
//             //         let bids = &pricebook["bids"][0];
//             //         let asks = &pricebook["asks"][0];            
//             //         // Access the price and size of the bids and asks
//             //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
//             //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");            
//             //         println!("Product ID: {}", product_id);
//             //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
//             //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
//             //     }
//             // }    
//             //manages any errors from line above
//             //let response_text = match response_text {
//             //    Ok(t) => t,
//             //    Err(e) => {
//             //        eprintln!("Failed to read response text: \n{}", e);
//             //        return;
//             //    }
//             //};    
//             //prints the actual response
//             //println!("list accounts response\n{:?}", &response_text);
// 	//03/02/24 - added:
// 		let now = Utc::now();
// 		let time_stamp = now.timestamp().to_string();
// 		let method = "GET";
// 		let request_path = "/api/v3/brokerage/best_bid_ask";
// 		let body = "";
// 		let message = format!("{}{}{}{}", &time_stamp, 
// 			&method, &request_path, &body);
// 		type HmacSha256 = Hmac<Sha256>;
// 		fn sign(message: &str, coinbase_secret: &str) -> String {
// 			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
// 					.expect("HMAC can take key of any size");
// 			mac.update(message.as_bytes());
// 			let result = mac.finalize();
// 			let code_bytes = result.into_bytes();
// 			hex::encode(code_bytes)
// 		}
// 		let coinbase_signature = sign(&message, &coinbase_secret);		
// 		let mut coinbase_buy_price_ask: Option<f64> = None;
// 		let mut attempts = 0;
// 		let mut success = false;
// 		loop {
// 			attempts +=1;
// 			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
// 			.header("CB-ACCESS-KEY", coinbase_api_key)
// 			.header("CB-ACCESS-SIGN", &coinbase_signature)
// 			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
// 			.build();
// 			match request {
// 				Ok(req) => {
// 					let response = client.execute(req).await;
// 					match response {
// 						Ok(resp) => {
// 							let response_text = resp.text().await;
// 							match response_text {
// 								Ok(text) => {
// 									match serde_json::from_str::<Value>(&text) {
// 										Ok(v) => {
// 											if let Some(pricebooks) = v["pricebooks"].as_array() {
// 												for pricebook in pricebooks {
// 													//let product_id = pricebook["product_id"].as_str();
// 													//let bids = &pricebook["bids"][0];
// 													let asks = &pricebook["asks"][0];
// 													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
// 													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();		
// 													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
// 														(/*Some(bid_str),*/ Some(ask_str)) => {
// 															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
// 																(/*Ok(bid_str),*/ Ok(ask_str)) => {
// 																	//coinbase_sell_price_bid = Some(bid_str);
// 																	coinbase_buy_price_ask = Some(ask_str);	
// 																		success = true;
// 																},
// 																_ => {
// 																	log::error!("i13:  coinbase:  Failed to f64 parse JSON");
// 																	if attempts > 3 {
// 																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 																	}
// 																	continue ;
// 																}
// 															}
// 														},
// 														_ => {
// 															log::error!("i13:  coinbase:  Failed to get ask price");
// 															if attempts > 3 {
// 																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
// 																panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
// 															}
// 															continue ;
// 														}
// 													}
// 												}
// 											//03/02/24 - added else condition
// 											} else {
// 												log::error!("i13:  coinbase:  Failed to get pricebooks as array.");
// 												if attempts > 3 {
// 													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
// 												}
// 												continue;
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i13:  coinbase:  Failed to parse outer JSON as str.");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 											}
// 											continue ; // Continue to the next iteration if parsing fails
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i13:  coinbase:  Failed to get response text.");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue ; // Continue to the next iteration if getting response text fails
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i13:  coinbase:  Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue; // Continue to the next iteration if executing request fails
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i13:  coinbase:  Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue; // Continue to the next iteration if building request fails
// 				}
// 			}
// 			if success == true {
// 				break;
// 			}
// 		}
//             //02/09/24 - updated tokio. removed:  
//                 //delay_for(Duration::from_secs(3)).await;
//             //02/09/24 - updated tokio. added in its place:
//             println!("sol 3 coinbase bitstamp: 3 sec delay");
//             let when = tokio::time::Instant::now() + Duration::from_secs(3);
//             tokio::time::sleep_until(when).await;   
//     //-------------------------Bitstamp---------------------------//
//                 //Bitstamp for some reason needs nonce to be 36 characters long. 
// 	//	nonce is basically a unique id that needs to be different every time you make a request. 
// 	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
// 	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
// 	//	and just make it a random 36 char string from it.
// 	//the exact same as the Coinbase signature. we'll see if it works
// 	//apparently it doesnt so I will code comment it out for now
// 	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 	//											.expect("HMAC can take key of any size");
// 	//	mac.update(bitstamp_message.as_bytes());
// 	//	let result = mac.finalize();
// 	//	let code_bytes = result.into_bytes();
// 	//	hex::encode(code_bytes)
// 	//}
// 	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 			.expect("HMAC can take key of any size");
// 		mac.update(bitstamp_message.as_bytes());
// 		let result = mac.finalize();
// 		let code_bytes = result.into_bytes();
// 		hex::encode(code_bytes)
// 	}
// 	let content_type = "application/x-www-form-urlencoded";
// 	let payload_string = "offset=1";
// 	//if we needed content_type, it is here
// 	//let content_type = "application/json";
// 	//this is the bitstamp message IF we needed content_type
// 	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
// 	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// //--------------------Account-balances------------------------------------------//
// 	let the_uuid = Uuid::new_v4();
// 	let bitstamp_nonce = the_uuid.to_string();
// 	let bitstamp_timestamp = now.timestamp_millis().to_string();
// 	//let content_type = "application/x-www-form-urlencoded";
// 	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
// 			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// 	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
// 	//03/02/24 - removed:
// 	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 	// 		.header("X-Auth-Signature", bitstamp_signature)
// 	// 		.header("X-Auth-Nonce", bitstamp_nonce)
// 	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
// 	// 		.header("X-Auth-Version", "v2")
// 	// 		//.header("Content-Type", content_type)
// 	// 		//.body(payload_string)
// 	// 		.build()
// 	// 		.expect("\ncould not build bitstamp_request");
// 	// 	let bitstamp_response = client.execute(bitstamp_request).await
// 	// 		.expect("Failed to execute Bitstamp request");
// 	// 	let bitstamp_response_text = bitstamp_response.text().await
// 	// 		.expect("Failed to turn response into text");
// 	// 	//probably dont need "bitstamp" once we transfer this to the actual function
// 	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
// 	//     .expect("Failed to parse JSON");
// 	// // Extract the bid and ask values
// 	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
// 	// 	println!("Bitstamp:\n{:?}", bitstamp_response_text);
// 	//03/02/24 - added:
// 		let mut success = false;
// 		let mut attempts = 0;
// 		let mut value_after: Option<f64> = None;
// 		while !success && attempts <=3 {
// 			attempts += 1;
// 			match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 				.header("X-Auth-Signature", &bitstamp_signature)
// 				.header("X-Auth-Nonce", &bitstamp_nonce)
// 				.header("X-Auth-Timestamp", &bitstamp_timestamp)
// 				.header("X-Auth-Version", "v2")
// 				.build() {
// 				Ok(bitstamp_request) => {
// 					match client.execute(bitstamp_request).await {
// 						Ok(bitstamp_response) => {
// 							match bitstamp_response.text().await {
// 								Ok(bitstamp_response_text) => {
// 									match serde_json::from_str::<Value>(&bitstamp_response_text) {
// 										Ok(v) => {
// 											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
// 											let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
// 											match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
// 												(Some(bid_str), Some(ask_str)) => {
// 													match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
// 														(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
// 															// Place your calculations and updates here
// 															//coinbase calculations to buy
// 															let coinbase_taker_fee = 0.008;
// 															let fraction_of_wallet_im_using = 0.03; //aka 3 percent
// 															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
// 															let fee_for_purchase = total_spent*coinbase_taker_fee;
// 															let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
// 															*coinbase_wallet -= total_spent;
// 															let amount_of_sol = 
// 															money_going_to_sol_after_fees/coinbase_buy_price_ask
// 																							.expect(&format!("i13: coinbase_buy_price_ask is somehow Not Some. 
// 																							even though to get to this point it had to be Some. 
// 																							coinbase_buy_price_ask: {:?}
// 																							Honestly restart the program from the last saved state. 
// 																							The most likely error is a bit got flipped after the loop",
// 																							&coinbase_buy_price_ask));
// 															//bitstamp calculations for sell
// 															let bitstamp_taker_fee = 0.004;
// 															let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
// 															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
// 															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
// 															*bitstamp_wallet += money_from_sell_after_fees;
// 															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
// 															if let Some(mut value_after) = value_after {
// 																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
// 																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
// 																value_after = standardization_functions::normal_value_prior_standardization(&value_after);																
// 																//value_after = 56
// 																//coinbase = 57
// 																//bitstamp = 58
// 																//kraken = 59
// 																//gemini = 60
// 																//since this is coinbase and bitstamp being updated, I will update:
// 																//  56, 57, 58
// 																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
// 																let indices = [56, 57, 58];
// 																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
// 																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 																neural_network.update_input(&indices, &scaled_values).await;
// 															}
// 															//03/08/24 - removed:
// 															// //value_after = 56
// 															// //coinbase = 57
// 															// //bitstamp = 58
// 															// //kraken = 59
// 															// //gemini = 60
// 															// //since this is coinbase and bitstamp being updated, I will update:
// 															// //  56, 57, 58
// 															// let indices = [56, 57, 58];
// 															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
// 															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 															// neural_network.update_input(&indices, &scaled_values).await;
// 															success = true;
// 														},
// 														_ => {
// 															log::error!("i13: Failed to f64 parse bid or ask price");
// 															if attempts > 3 {
// 																panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 															}
// 															continue;
// 														}
// 													}
// 												},
// 												_ => {
// 													log::error!("i13: Failed to originally parse bid or ask price");
// 													if attempts > 3 {
// 														panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 													}
// 													continue;
// 												}
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i13: Failed to parse JSON");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
// 											}
// 											continue;
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i13: failed to get response text");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue;
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i13: Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue;
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i13: Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue;
// 				}
// 			}
// 		}
// 		match value_after {
// 			Some(value) => return Ok(value),
// 			None => {
// 				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
// 				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
// 			}
// 		}
// 			//03/02/24 - removed:
//             // //coinbase calculations
//             //     let coinbase_taker_fee = 0.008;
//             //     let total_spent = 0.03*(*coinbase_wallet);
//             //     let fee_for_purchase = total_spent*coinbase_taker_fee;
//             //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
//             //     //new state of coinbase wallet below
//             //     *coinbase_wallet -= total_spent;
//             //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
//             // //kraken calculations
//             //     //let kraken_taker_fee = 0.0026;        
//             //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
//             //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
//             //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
//             //     //*kraken_wallet += money_from_sell_after_fees;
//             //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             // //bitstamp calculations
//             //     let bitstamp_taker_fee = 0.004;
//             //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
//             //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
//             //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
//             //     *bitstamp_wallet += money_from_sell_after_fees;
//             // //this will count as value after
//             //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             //     //value_after = 56
//             //     //coinbase = 57
//             //     //bitstamp = 58
//             //     //kraken = 59
//             //     //gemini = 60
//             //     //since this is coinbase and kraken being updated, I will update:
//             //     //  56, 57, 59
//             //     let indices = [56, 57, 58];
//             //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
//             //     //01/24/24 - removed and added:
//             //         //neural_network.update_input(&indices, &new_values);
//             //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
//             //         //neural_network.update_input(&indices, &transformed_values).await;
//             //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
//             //         neural_network.update_input(&indices, &scaled_values).await;
//             //     return Ok(value_after)
//     }
//     pub async fn s_i14_sol_4_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
//         gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
// 			//03/02/24 - added:
//             // let now = Utc::now();
//             // let time_stamp = now.timestamp().to_string();
//             // let method = "GET";
//             // let request_path = "/api/v3/brokerage/best_bid_ask";
//             // let body = "";
//             // let message = format!("{}{}{}{}", &time_stamp, 
//             // &method, &request_path, &body);
//             // type HmacSha256 = Hmac<Sha256>;
//             // fn sign(message: &str, coinbase_secret: &str) -> String {
//             // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
//             //             .expect("HMAC can take key of any size");
//             // mac.update(message.as_bytes());
//             // let result = mac.finalize();
//             // let code_bytes = result.into_bytes();
//             // hex::encode(code_bytes)
//             // }
//             // let coinbase_signature = sign(&message, &coinbase_secret); 
//             // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
//             // .header("CB-ACCESS-KEY", coinbase_api_key)
//             // .header("CB-ACCESS-SIGN", &coinbase_signature)
//             // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
//             // .build()
//             // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //manages the error I described above
//             // //let request = match request {
//             // //Ok(req) => req,
//             // //Err(e) => {
//             // //eprintln!("Failed to build request: \n{}", e);
//             // //return Err(e);
//             // //}
//             // //};
//             // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //let response = match response {
//             // //    Ok(resp) => resp,
//             // //    Err(e) => {
//             // //        eprintln!("Failed to execute request: \n{}", e);
//             // //        return Err(e);
//             // //    }
//             // //};
//             // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //added 12/29/23
//             // //this is the parsing
//             // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // let mut coinbase_sell_price = 0.0;
//             // let mut coinbase_buy_price = 0.0;
//             // // Access the pricebooks array
//             // if let Some(pricebooks) = v["pricebooks"].as_array() {
//             //     // Iterate over each pricebook
//             //     for pricebook in pricebooks {
//             //         // Access the product_id, bids, and asks
//             //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
//             //         let bids = &pricebook["bids"][0];
//             //         let asks = &pricebook["asks"][0];      
//             //         // Access the price and size of the bids and asks
//             //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
//             //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");       
//             //         println!("Product ID: {}", product_id);
//             //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
//             //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
//             //     }
//             // }
//             //manages any errors from line above
//             //let response_text = match response_text {
//             //    Ok(t) => t,
//             //    Err(e) => {
//             //        eprintln!("Failed to read response text: \n{}", e);
//             //        return;
//             //    }
//             //};
//             //prints the actual response
//             //println!("list accounts response\n{:?}", &response_text);
// 	//03/02/24 - added:
// 		let now = Utc::now();
// 		let time_stamp = now.timestamp().to_string();
// 		let method = "GET";
// 		let request_path = "/api/v3/brokerage/best_bid_ask";
// 		let body = "";
// 		let message = format!("{}{}{}{}", &time_stamp, 
// 			&method, &request_path, &body);
// 		type HmacSha256 = Hmac<Sha256>;
// 		fn sign(message: &str, coinbase_secret: &str) -> String {
// 			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
// 					.expect("HMAC can take key of any size");
// 			mac.update(message.as_bytes());
// 			let result = mac.finalize();
// 			let code_bytes = result.into_bytes();
// 			hex::encode(code_bytes)
// 		}
// 		let coinbase_signature = sign(&message, &coinbase_secret);
// 		let mut coinbase_buy_price_ask: Option<f64> = None;
// 		let mut attempts = 0;
// 		let mut success = false;
// 		loop {
// 			attempts +=1;
// 			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
// 			.header("CB-ACCESS-KEY", coinbase_api_key)
// 			.header("CB-ACCESS-SIGN", &coinbase_signature)
// 			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
// 			.build();
// 			match request {
// 				Ok(req) => {
// 					let response = client.execute(req).await;
// 					match response {
// 						Ok(resp) => {
// 							let response_text = resp.text().await;
// 							match response_text {
// 								Ok(text) => {
// 									match serde_json::from_str::<Value>(&text) {
// 										Ok(v) => {
// 											if let Some(pricebooks) = v["pricebooks"].as_array() {
// 												for pricebook in pricebooks {
// 													//let product_id = pricebook["product_id"].as_str();
// 													//let bids = &pricebook["bids"][0];
// 													let asks = &pricebook["asks"][0];
// 													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
// 													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();	
// 													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
// 														(/*Some(bid_str),*/ Some(ask_str)) => {
// 															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
// 																(/*Ok(bid_str),*/ Ok(ask_str)) => {
// 																	//coinbase_sell_price_bid = Some(bid_str);
// 																	coinbase_buy_price_ask = Some(ask_str);
// 																		success = true;
// 																},
// 																_ => {
// 																	log::error!("i14:  coinbase:  Failed to f64 parse JSON");
// 																	if attempts > 3 {
// 																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 																	}
// 																	continue ;
// 																}
// 															}
// 														},
// 														_ => {
// 															log::error!("i14:  coinbase:  Failed to get ask price");
// 															if attempts > 3 {
// 																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
// 																panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
// 															}
// 															continue ;
// 														}
// 													}
// 												}
// 											//03/02/24 - added else condition
// 											} else {
// 												log::error!("i14:  coinbase:  Failed to get pricebooks as array.");
// 												if attempts > 3 {
// 													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
// 												}
// 												continue;
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i14:  coinbase:  Failed to parse outer JSON as str.");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 											}
// 											continue ; // Continue to the next iteration if parsing fails
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i14:  coinbase:  Failed to get response text.");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue ; // Continue to the next iteration if getting response text fails
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i14:  coinbase:  Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue; // Continue to the next iteration if executing request fails
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i14:  coinbase:  Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue; // Continue to the next iteration if building request fails
// 				}
// 			}
// 			if success == true {
// 				break;
// 			}
// 		}
//             //02/09/24 - updated tokio. removed:  
//                 //delay_for(Duration::from_secs(3)).await;
//             //02/09/24 - updated tokio. added in its place:
//             println!("sol 4 coinbase bitstamp: 3 sec delay");
//             let when = tokio::time::Instant::now() + Duration::from_secs(3);
//             tokio::time::sleep_until(when).await;
//     //-------------------------Bitstamp---------------------------//
//                 //Bitstamp for some reason needs nonce to be 36 characters long. 
// 	//	nonce is basically a unique id that needs to be different every time you make a request. 
// 	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
// 	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
// 	//	and just make it a random 36 char string from it.
// 	//the exact same as the Coinbase signature. we'll see if it works
// 	//apparently it doesnt so I will code comment it out for now
// 	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 	//											.expect("HMAC can take key of any size");
// 	//	mac.update(bitstamp_message.as_bytes());
// 	//	let result = mac.finalize();
// 	//	let code_bytes = result.into_bytes();
// 	//	hex::encode(code_bytes)
// 	//}
// 	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 			.expect("HMAC can take key of any size");
// 		mac.update(bitstamp_message.as_bytes());
// 		let result = mac.finalize();
// 		let code_bytes = result.into_bytes();
// 		hex::encode(code_bytes)
// 	}
// 	let content_type = "application/x-www-form-urlencoded";
// 	let payload_string = "offset=1";
// 	//if we needed content_type, it is here
// 	//let content_type = "application/json";
// 	//this is the bitstamp message IF we needed content_type
// 	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
// 	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// //--------------------Account-balances------------------------------------------//
// 	let the_uuid = Uuid::new_v4();
// 	let bitstamp_nonce = the_uuid.to_string();
// 	let bitstamp_timestamp = now.timestamp_millis().to_string();
// 	//let content_type = "application/x-www-form-urlencoded";
// 	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
// 			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// 	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
// 	//03/02/24 - removed:
// 	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 	// 		.header("X-Auth-Signature", bitstamp_signature)
// 	// 		.header("X-Auth-Nonce", bitstamp_nonce)
// 	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
// 	// 		.header("X-Auth-Version", "v2")
// 	// 		//.header("Content-Type", content_type)
// 	// 		//.body(payload_string)
// 	// 		.build()
// 	// 		.expect("\ncould not build bitstamp_request");
// 	// 	let bitstamp_response = client.execute(bitstamp_request).await
// 	// 		.expect("Failed to execute Bitstamp request");
// 	// 	let bitstamp_response_text = bitstamp_response.text().await
// 	// 		.expect("Failed to turn response into text");
// 	// 	//probably dont need "bitstamp" once we transfer this to the actual function
// 	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
// 	//     .expect("Failed to parse JSON");
// 	// // Extract the bid and ask values
// 	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
// 	// 	println!("Bitstamp:\n{:?}", bitstamp_response_text);
// 	//03/02/24 - added:
// 		let mut success = false;
// 		let mut attempts = 0;
// 		let mut value_after: Option<f64> = None;
// 		while !success && attempts <=3 {
// 			attempts += 1;
// 			match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 				.header("X-Auth-Signature", &bitstamp_signature)
// 				.header("X-Auth-Nonce", &bitstamp_nonce)
// 				.header("X-Auth-Timestamp", &bitstamp_timestamp)
// 				.header("X-Auth-Version", "v2")
// 				.build() {
// 				Ok(bitstamp_request) => {
// 					match client.execute(bitstamp_request).await {
// 						Ok(bitstamp_response) => {
// 							match bitstamp_response.text().await {
// 								Ok(bitstamp_response_text) => {
// 									match serde_json::from_str::<Value>(&bitstamp_response_text) {
// 										Ok(v) => {
// 											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
// 											let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
// 											match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
// 												(Some(bid_str), Some(ask_str)) => {
// 													match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
// 														(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
// 															// Place your calculations and updates here
// 															//coinbase calculations to buy
// 															let coinbase_taker_fee = 0.008;
// 															let fraction_of_wallet_im_using = 0.04; //aka 4 percent
// 															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
// 															let fee_for_purchase = total_spent*coinbase_taker_fee;
// 															let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
// 															*coinbase_wallet -= total_spent;
// 															let amount_of_sol = 
// 															money_going_to_sol_after_fees/coinbase_buy_price_ask
// 																							.expect(&format!("i14: coinbase_buy_price_ask is somehow Not Some. 
// 																							even though to get to this point it had to be Some. 
// 																							coinbase_buy_price_ask: {:?}
// 																							Honestly restart the program from the last saved state. 
// 																							The most likely error is a bit got flipped after the loop",
// 																							&coinbase_buy_price_ask));
// 															//bitstamp calculations for sell
// 															let bitstamp_taker_fee = 0.004;
// 															let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
// 															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
// 															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
// 															*bitstamp_wallet += money_from_sell_after_fees;
// 															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
// 															if let Some(mut value_after) = value_after {
// 																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
// 																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
// 																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
// 																//value_after = 56
// 																//coinbase = 57
// 																//bitstamp = 58
// 																//kraken = 59
// 																//gemini = 60
// 																//since this is coinbase and bitstamp being updated, I will update:
// 																//  56, 57, 58
// 																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
// 																let indices = [56, 57, 58];
// 																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
// 																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 																neural_network.update_input(&indices, &scaled_values).await;
// 															}
// 															//03/08/24 - removed:
// 															// //value_after = 56
// 															// //coinbase = 57
// 															// //bitstamp = 58
// 															// //kraken = 59
// 															// //gemini = 60
// 															// //since this is coinbase and bitstamp being updated, I will update:
// 															// //  56, 57, 58
// 															// let indices = [56, 57, 58];
// 															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
// 															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 															// neural_network.update_input(&indices, &scaled_values).await;
// 															success = true;
// 														},
// 														_ => {
// 															log::error!("i14: Failed to f64 parse bid or ask price");
// 															if attempts > 3 {
// 																panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 															}
// 															continue;
// 														}
// 													}
// 												},
// 												_ => {
// 													log::error!("i14: Failed to originally parse bid or ask price");
// 													if attempts > 3 {
// 														panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 													}
// 													continue;
// 												}
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i14: Failed to parse JSON");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
// 											}
// 											continue;
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i14: failed to get response text");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue;
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i14: Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue;
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i14: Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue;
// 				}
// 			}
// 		}
// 		match value_after {
// 			Some(value) => return Ok(value),
// 			None => {
// 				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
// 				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
// 			}
// 		}
// 			//03/02/24 - removed:
//             // //coinbase calculations
//             //     let coinbase_taker_fee = 0.008;
//             //     let total_spent = 0.03*(*coinbase_wallet);
//             //     let fee_for_purchase = total_spent*coinbase_taker_fee;
//             //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
//             //     //new state of coinbase wallet below
//             //     *coinbase_wallet -= total_spent;
//             //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
//             // //kraken calculations
//             //     //let kraken_taker_fee = 0.0026;         
//             //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
//             //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
//             //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
//             //     //*kraken_wallet += money_from_sell_after_fees;
//             //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             // //bitstamp calculations
//             //     let bitstamp_taker_fee = 0.004;
//             //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
//             //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
//             //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
//             //     *bitstamp_wallet += money_from_sell_after_fees;
//             // //this will count as value after
//             //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             //     //value_after = 56
//             //     //coinbase = 57
//             //     //bitstamp = 58
//             //     //kraken = 59
//             //     //gemini = 60
//             //     //since this is coinbase and kraken being updated, I will update:
//             //     //  56, 57, 59
//             //     let indices = [56, 57, 58];
//             //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
//             //     //01/24/24 - removed and added:
//             //         //neural_network.update_input(&indices, &new_values);
//             //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
//             //         //neural_network.update_input(&indices, &transformed_values).await;
//             //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
//             //         neural_network.update_input(&indices, &scaled_values).await;
//             //     return Ok(value_after)
//     }
//     pub async fn s_i15_sol_5_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
//         gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
// 			//03/02/24 - added:
//             // let now = Utc::now();
//             // let time_stamp = now.timestamp().to_string();
//             // let method = "GET";
//             // let request_path = "/api/v3/brokerage/best_bid_ask";
//             // let body = "";
//             // let message = format!("{}{}{}{}", &time_stamp, 
//             // &method, &request_path, &body);
//             // type HmacSha256 = Hmac<Sha256>;
//             // fn sign(message: &str, coinbase_secret: &str) -> String {
//             // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
//             //             .expect("HMAC can take key of any size");
//             // mac.update(message.as_bytes());
//             // let result = mac.finalize();
//             // let code_bytes = result.into_bytes();
//             // hex::encode(code_bytes)
//             // }
//             // let coinbase_signature = sign(&message, &coinbase_secret);
//             // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
//             // .header("CB-ACCESS-KEY", coinbase_api_key)
//             // .header("CB-ACCESS-SIGN", &coinbase_signature)
//             // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
//             // .build()
//             // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //manages the error I described above
//             // //let request = match request {
//             // //Ok(req) => req,
//             // //Err(e) => {
//             // //eprintln!("Failed to build request: \n{}", e);
//             // //return Err(e);
//             // //}
//             // //};
//             // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //let response = match response {
//             // //    Ok(resp) => resp,
//             // //    Err(e) => {
//             // //        eprintln!("Failed to execute request: \n{}", e);
//             // //        return Err(e);
//             // //    }
//             // //};
//             // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //added 12/29/23
//             // //this is the parsing
//             // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // let mut coinbase_sell_price = 0.0;
//             // let mut coinbase_buy_price = 0.0;
//             // // Access the pricebooks array
//             // if let Some(pricebooks) = v["pricebooks"].as_array() {
//             //     // Iterate over each pricebook
//             //     for pricebook in pricebooks {
//             //         // Access the product_id, bids, and asks
//             //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
//             //         let bids = &pricebook["bids"][0];
//             //         let asks = &pricebook["asks"][0];    
//             //         // Access the price and size of the bids and asks
//             //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
//             //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");    
//             //         println!("Product ID: {}", product_id);
//             //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
//             //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
//             //     }
//             // }
//             //manages any errors from line above
//             //let response_text = match response_text {
//             //    Ok(t) => t,
//             //    Err(e) => {
//             //        eprintln!("Failed to read response text: \n{}", e);
//             //        return;
//             //    }
//             //};
//             //prints the actual response
//             //println!("list accounts response\n{:?}", &response_text);
// 	//03/02/24 - added:
// 		let now = Utc::now();
// 		let time_stamp = now.timestamp().to_string();
// 		let method = "GET";
// 		let request_path = "/api/v3/brokerage/best_bid_ask";
// 		let body = "";
// 		let message = format!("{}{}{}{}", &time_stamp, 
// 			&method, &request_path, &body);
// 		type HmacSha256 = Hmac<Sha256>;
// 		fn sign(message: &str, coinbase_secret: &str) -> String {
// 			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
// 					.expect("HMAC can take key of any size");
// 			mac.update(message.as_bytes());
// 			let result = mac.finalize();
// 			let code_bytes = result.into_bytes();
// 			hex::encode(code_bytes)
// 		}
// 		let coinbase_signature = sign(&message, &coinbase_secret);
// 		let mut coinbase_buy_price_ask: Option<f64> = None;
// 		let mut attempts = 0;
// 		let mut success = false;
// 		loop {
// 			attempts +=1;
// 			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
// 			.header("CB-ACCESS-KEY", coinbase_api_key)
// 			.header("CB-ACCESS-SIGN", &coinbase_signature)
// 			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
// 			.build();
// 			match request {
// 				Ok(req) => {
// 					let response = client.execute(req).await;
// 					match response {
// 						Ok(resp) => {
// 							let response_text = resp.text().await;
// 							match response_text {
// 								Ok(text) => {
// 									match serde_json::from_str::<Value>(&text) {
// 										Ok(v) => {
// 											if let Some(pricebooks) = v["pricebooks"].as_array() {
// 												for pricebook in pricebooks {
// 													//let product_id = pricebook["product_id"].as_str();
// 													//let bids = &pricebook["bids"][0];
// 													let asks = &pricebook["asks"][0];
// 													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
// 													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
// 													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
// 														(/*Some(bid_str),*/ Some(ask_str)) => {
// 															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
// 																(/*Ok(bid_str),*/ Ok(ask_str)) => {
// 																	//coinbase_sell_price_bid = Some(bid_str);
// 																	coinbase_buy_price_ask = Some(ask_str);
// 																		success = true;
// 																},
// 																_ => {
// 																	log::error!("i15:  coinbase:  Failed to f64 parse JSON");
// 																	if attempts > 3 {
// 																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 																	}
// 																	continue ;
// 																}
// 															}
// 														},
// 														_ => {
// 															log::error!("i15:  coinbase:  Failed to get ask price");
// 															if attempts > 3 {
// 																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
// 																panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
// 															}
// 															continue ;
// 														}
// 													}
// 												}
// 											//03/02/24 - added else condition
// 											} else {
// 												log::error!("i15:  coinbase:  Failed to get pricebooks as array.");
// 												if attempts > 3 {
// 													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
// 												}
// 												continue;
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i15:  coinbase:  Failed to parse outer JSON as str.");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 											}
// 											continue ; // Continue to the next iteration if parsing fails
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i15:  coinbase:  Failed to get response text.");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue ; // Continue to the next iteration if getting response text fails
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i15:  coinbase:  Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue; // Continue to the next iteration if executing request fails
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i15:  coinbase:  Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue; // Continue to the next iteration if building request fails
// 				}
// 			}
// 			if success == true {
// 				break;
// 			}
// 		}
//             //02/09/24 - updated tokio. removed:  
//                 //delay_for(Duration::from_secs(3)).await;
//             //02/09/24 - updated tokio. added in its place:
//             println!("sol 5 coinbase bitstamp: 3 sec delay");
//             let when = tokio::time::Instant::now() + Duration::from_secs(3);
//             tokio::time::sleep_until(when).await;
//     //-------------------------Bitstamp---------------------------//
//                 //Bitstamp for some reason needs nonce to be 36 characters long. 
// 	//	nonce is basically a unique id that needs to be different every time you make a request. 
// 	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
// 	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
// 	//	and just make it a random 36 char string from it.
// 	//the exact same as the Coinbase signature. we'll see if it works
// 	//apparently it doesnt so I will code comment it out for now
// 	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 	//											.expect("HMAC can take key of any size");
// 	//	mac.update(bitstamp_message.as_bytes());
// 	//	let result = mac.finalize();
// 	//	let code_bytes = result.into_bytes();
// 	//	hex::encode(code_bytes)
// 	//}
// 	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 			.expect("HMAC can take key of any size");
// 		mac.update(bitstamp_message.as_bytes());
// 		let result = mac.finalize();
// 		let code_bytes = result.into_bytes();
// 		hex::encode(code_bytes)
// 	}
// 	let content_type = "application/x-www-form-urlencoded";
// 	let payload_string = "offset=1";
// 	//if we needed content_type, it is here
// 	//let content_type = "application/json";
// 	//this is the bitstamp message IF we needed content_type
// 	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
// 	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// //--------------------Account-balances------------------------------------------//
// 	let the_uuid = Uuid::new_v4();
// 	let bitstamp_nonce = the_uuid.to_string();
// 	let bitstamp_timestamp = now.timestamp_millis().to_string();
// 	//let content_type = "application/x-www-form-urlencoded";
// 	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
// 			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// 	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
// 	//03/02/24 - removed:
// 	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 	// 		.header("X-Auth-Signature", bitstamp_signature)
// 	// 		.header("X-Auth-Nonce", bitstamp_nonce)
// 	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
// 	// 		.header("X-Auth-Version", "v2")
// 	// 		//.header("Content-Type", content_type)
// 	// 		//.body(payload_string)
// 	// 		.build()
// 	// 		.expect("\ncould not build bitstamp_request");
// 	// 	let bitstamp_response = client.execute(bitstamp_request).await
// 	// 		.expect("Failed to execute Bitstamp request");
// 	// 	let bitstamp_response_text = bitstamp_response.text().await
// 	// 		.expect("Failed to turn response into text");
// 	// 	//probably dont need "bitstamp" once we transfer this to the actual function
// 	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
// 	//     .expect("Failed to parse JSON");
// 	// // Extract the bid and ask values
// 	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
// 	// 	println!("Bitstamp:\n{:?}", bitstamp_response_text);
// 	//03/02/24 - added:
// 		let mut success = false;
// 		let mut attempts = 0;
// 		let mut value_after: Option<f64> = None;
// 		while !success && attempts <=3 {
// 			attempts += 1;
// 			match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 				.header("X-Auth-Signature", &bitstamp_signature)
// 				.header("X-Auth-Nonce", &bitstamp_nonce)
// 				.header("X-Auth-Timestamp", &bitstamp_timestamp)
// 				.header("X-Auth-Version", "v2")
// 				.build() {
// 				Ok(bitstamp_request) => {
// 					match client.execute(bitstamp_request).await {
// 						Ok(bitstamp_response) => {
// 							match bitstamp_response.text().await {
// 								Ok(bitstamp_response_text) => {
// 									match serde_json::from_str::<Value>(&bitstamp_response_text) {
// 										Ok(v) => {
// 											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
// 											let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
// 											match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
// 												(Some(bid_str), Some(ask_str)) => {
// 													match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
// 														(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
// 															// Place your calculations and updates here
// 															//coinbase calculations to buy
// 															let coinbase_taker_fee = 0.008;
// 															let fraction_of_wallet_im_using = 0.05; //aka 5 percent
// 															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
// 															let fee_for_purchase = total_spent*coinbase_taker_fee;
// 															let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
// 															*coinbase_wallet -= total_spent;
// 															let amount_of_sol = 
// 															money_going_to_sol_after_fees/coinbase_buy_price_ask
// 																							.expect(&format!("i15: coinbase_buy_price_ask is somehow Not Some. 
// 																							even though to get to this point it had to be Some. 
// 																							coinbase_buy_price_ask: {:?}
// 																							Honestly restart the program from the last saved state. 
// 																							The most likely error is a bit got flipped after the loop",
// 																							&coinbase_buy_price_ask));
// 															//bitstamp calculations for sell
// 															let bitstamp_taker_fee = 0.004;
// 															let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
// 															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
// 															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
// 															*bitstamp_wallet += money_from_sell_after_fees;
// 															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
// 															if let Some(mut value_after) = value_after {
// 																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
// 																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
// 																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
// 																//value_after = 56
// 																//coinbase = 57
// 																//bitstamp = 58
// 																//kraken = 59
// 																//gemini = 60
// 																//since this is coinbase and bitstamp being updated, I will update:
// 																//  56, 57, 58
// 																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
// 																let indices = [56, 57, 58];
// 																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
// 																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 																neural_network.update_input(&indices, &scaled_values).await;
// 															}
// 															//03/08/24 - removed:
// 															// //value_after = 56
// 															// //coinbase = 57
// 															// //bitstamp = 58
// 															// //kraken = 59
// 															// //gemini = 60
// 															// //since this is coinbase and bitstamp being updated, I will update:
// 															// //  56, 57, 58
// 															// let indices = [56, 57, 58];
// 															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
// 															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 															// neural_network.update_input(&indices, &scaled_values).await;
// 															success = true;
// 														},
// 														_ => {
// 															log::error!("i15: Failed to f64 parse bid or ask price");
// 															if attempts > 3 {
// 																panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 															}
// 															continue;
// 														}
// 													}
// 												},
// 												_ => {
// 													log::error!("i15: Failed to originally parse bid or ask price");
// 													if attempts > 3 {
// 														panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 													}
// 													continue;
// 												}
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i15: Failed to parse JSON");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
// 											}
// 											continue;
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i15: failed to get response text");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue;
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i15: Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue;
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i15: Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue;
// 				}
// 			}
// 		}
// 		match value_after {
// 			Some(value) => return Ok(value),
// 			None => {
// 				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
// 				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
// 			}
// 		}
// 			//03/02/24 - removed:
//             // //coinbase calculations
//             //     let coinbase_taker_fee = 0.008;
//             //     let total_spent = 0.03*(*coinbase_wallet);
//             //     let fee_for_purchase = total_spent*coinbase_taker_fee;
//             //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
//             //     //new state of coinbase wallet below
//             //     *coinbase_wallet -= total_spent;
//             //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
//             // //kraken calculations
//             //     //let kraken_taker_fee = 0.0026;
//             //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
//             //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
//             //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
//             //     //*kraken_wallet += money_from_sell_after_fees;
//             //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             // //bitstamp calculations
//             //     let bitstamp_taker_fee = 0.004;
//             //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
//             //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
//             //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
//             //     *bitstamp_wallet += money_from_sell_after_fees;
//             // //this will count as value after
//             //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             //     //value_after = 56
//             //     //coinbase = 57
//             //     //bitstamp = 58
//             //     //kraken = 59
//             //     //gemini = 60
//             //     //since this is coinbase and kraken being updated, I will update:
//             //     //  56, 57, 59
//             //     let indices = [56, 57, 58];
//             //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
//             //     //01/24/24 - removed and added:
//             //         //neural_network.update_input(&indices, &new_values);
//             //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
//             //         //neural_network.update_input(&indices, &transformed_values).await;
//             //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
//             //         neural_network.update_input(&indices, &scaled_values).await;
//             //     return Ok(value_after)
//     }
//     pub async fn s_i16_sol_6_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
//         gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
// 			//03/02/24 - added:
//             // let now = Utc::now();
//             // let time_stamp = now.timestamp().to_string();
//             // let method = "GET";
//             // let request_path = "/api/v3/brokerage/best_bid_ask";
//             // let body = "";
//             // let message = format!("{}{}{}{}", &time_stamp, 
//             // &method, &request_path, &body);
//             // type HmacSha256 = Hmac<Sha256>;
//             // fn sign(message: &str, coinbase_secret: &str) -> String {
//             // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
//             //             .expect("HMAC can take key of any size");
//             // mac.update(message.as_bytes());
//             // let result = mac.finalize();
//             // let code_bytes = result.into_bytes();
//             // hex::encode(code_bytes)
//             // }
//             // let coinbase_signature = sign(&message, &coinbase_secret);
//             // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
//             // .header("CB-ACCESS-KEY", coinbase_api_key)
//             // .header("CB-ACCESS-SIGN", &coinbase_signature)
//             // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
//             // .build()
//             // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //manages the error I described above
//             // //let request = match request {
//             // //Ok(req) => req,
//             // //Err(e) => {
//             // //eprintln!("Failed to build request: \n{}", e);
//             // //return Err(e);
//             // //}
//             // //};
//             // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //let response = match response {
//             // //    Ok(resp) => resp,
//             // //    Err(e) => {
//             // //        eprintln!("Failed to execute request: \n{}", e);
//             // //        return Err(e);
//             // //    }
//             // //};
//             // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //added 12/29/23
//             // //this is the parsing
//             // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // let mut coinbase_sell_price = 0.0;
//             // let mut coinbase_buy_price = 0.0;
//             // // Access the pricebooks array
//             // if let Some(pricebooks) = v["pricebooks"].as_array() {
//             //     // Iterate over each pricebook
//             //     for pricebook in pricebooks {
//             //         // Access the product_id, bids, and asks
//             //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
//             //         let bids = &pricebook["bids"][0];
//             //         let asks = &pricebook["asks"][0];
//             //         // Access the price and size of the bids and asks
//             //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
//             //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
//             //         println!("Product ID: {}", product_id);
//             //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
//             //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
//             //     }
//             // }
//             //manages any errors from line above
//             //let response_text = match response_text {
//             //    Ok(t) => t,
//             //    Err(e) => {
//             //        eprintln!("Failed to read response text: \n{}", e);
//             //        return;
//             //    }
//             //};
//             //prints the actual response
//             //println!("list accounts response\n{:?}", &response_text);
// 	//03/02/24 - added:
// 		let now = Utc::now();
// 		let time_stamp = now.timestamp().to_string();
// 		let method = "GET";
// 		let request_path = "/api/v3/brokerage/best_bid_ask";
// 		let body = "";
// 		let message = format!("{}{}{}{}", &time_stamp, 
// 			&method, &request_path, &body);
// 		type HmacSha256 = Hmac<Sha256>;
// 		fn sign(message: &str, coinbase_secret: &str) -> String {
// 			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
// 					.expect("HMAC can take key of any size");
// 			mac.update(message.as_bytes());
// 			let result = mac.finalize();
// 			let code_bytes = result.into_bytes();
// 			hex::encode(code_bytes)
// 		}
// 		let coinbase_signature = sign(&message, &coinbase_secret);
// 		let mut coinbase_buy_price_ask: Option<f64> = None;
// 		let mut attempts = 0;
// 		let mut success = false;
// 		loop {
// 			attempts +=1;
// 			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
// 			.header("CB-ACCESS-KEY", coinbase_api_key)
// 			.header("CB-ACCESS-SIGN", &coinbase_signature)
// 			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
// 			.build();
// 			match request {
// 				Ok(req) => {
// 					let response = client.execute(req).await;
// 					match response {
// 						Ok(resp) => {
// 							let response_text = resp.text().await;
// 							match response_text {
// 								Ok(text) => {
// 									match serde_json::from_str::<Value>(&text) {
// 										Ok(v) => {
// 											if let Some(pricebooks) = v["pricebooks"].as_array() {
// 												for pricebook in pricebooks {
// 													//let product_id = pricebook["product_id"].as_str();
// 													//let bids = &pricebook["bids"][0];
// 													let asks = &pricebook["asks"][0];
// 													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
// 													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
// 													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
// 														(/*Some(bid_str),*/ Some(ask_str)) => {
// 															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
// 																(/*Ok(bid_str),*/ Ok(ask_str)) => {
// 																	//coinbase_sell_price_bid = Some(bid_str);
// 																	coinbase_buy_price_ask = Some(ask_str);
// 																		success = true;
// 																},
// 																_ => {
// 																	log::error!("i16:  coinbase:  Failed to f64 parse JSON");
// 																	if attempts > 3 {
// 																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 																	}
// 																	continue ;
// 																}
// 															}
// 														},
// 														_ => {
// 															log::error!("i16:  coinbase:  Failed to get ask price");
// 															if attempts > 3 {
// 																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
// 																panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
// 															}
// 															continue ;
// 														}
// 													}
// 												}
// 											//03/02/24 - added else condition
// 											} else {
// 												log::error!("i16:  coinbase:  Failed to get pricebooks as array.");
// 												if attempts > 3 {
// 													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
// 												}
// 												continue;
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i16:  coinbase:  Failed to parse outer JSON as str.");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 											}
// 											continue ; // Continue to the next iteration if parsing fails
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i16:  coinbase:  Failed to get response text.");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue ; // Continue to the next iteration if getting response text fails
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i16:  coinbase:  Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue; // Continue to the next iteration if executing request fails
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i16:  coinbase:  Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue; // Continue to the next iteration if building request fails
// 				}
// 			}
// 			if success == true {
// 				break;
// 			}
// 		}
//             //02/09/24 - updated tokio. removed:  
//                 //delay_for(Duration::from_secs(3)).await;
//             //02/09/24 - updated tokio. added in its place:
//             println!("sol 6 coinbase bitstamp: 3 sec delay");
//             let when = tokio::time::Instant::now() + Duration::from_secs(3);
//             tokio::time::sleep_until(when).await;
//     //-------------------------Bitstamp---------------------------//
//                 //Bitstamp for some reason needs nonce to be 36 characters long. 
// 	//	nonce is basically a unique id that needs to be different every time you make a request. 
// 	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
// 	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
// 	//	and just make it a random 36 char string from it.
// 	//the exact same as the Coinbase signature. we'll see if it works
// 	//apparently it doesnt so I will code comment it out for now
// 	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 	//											.expect("HMAC can take key of any size");
// 	//	mac.update(bitstamp_message.as_bytes());
// 	//	let result = mac.finalize();
// 	//	let code_bytes = result.into_bytes();
// 	//	hex::encode(code_bytes)
// 	//}
// 	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 			.expect("HMAC can take key of any size");
// 		mac.update(bitstamp_message.as_bytes());
// 		let result = mac.finalize();
// 		let code_bytes = result.into_bytes();
// 		hex::encode(code_bytes)
// 	}
// 	let content_type = "application/x-www-form-urlencoded";
// 	let payload_string = "offset=1";
// 	//if we needed content_type, it is here
// 	//let content_type = "application/json";
// 	//this is the bitstamp message IF we needed content_type
// 	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
// 	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// //--------------------Account-balances------------------------------------------//
// 	let the_uuid = Uuid::new_v4();
// 	let bitstamp_nonce = the_uuid.to_string();
// 	let bitstamp_timestamp = now.timestamp_millis().to_string();
// 	//let content_type = "application/x-www-form-urlencoded";
// 	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
// 			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// 	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
// 	//03/02/24 - removed:
// 	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 	// 		.header("X-Auth-Signature", bitstamp_signature)
// 	// 		.header("X-Auth-Nonce", bitstamp_nonce)
// 	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
// 	// 		.header("X-Auth-Version", "v2")
// 	// 		//.header("Content-Type", content_type)
// 	// 		//.body(payload_string)
// 	// 		.build()
// 	// 		.expect("\ncould not build bitstamp_request");
// 	// 	let bitstamp_response = client.execute(bitstamp_request).await
// 	// 		.expect("Failed to execute Bitstamp request");
// 	// 	let bitstamp_response_text = bitstamp_response.text().await
// 	// 		.expect("Failed to turn response into text");
// 	// 	//probably dont need "bitstamp" once we transfer this to the actual function
// 	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
// 	//     .expect("Failed to parse JSON");
// 	// // Extract the bid and ask values
// 	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
// 	// 	println!("Bitstamp:\n{:?}", bitstamp_response_text);
// 	//03/02/24 - added:
// 		let mut success = false;
// 		let mut attempts = 0;
// 		let mut value_after: Option<f64> = None;
// 		while !success && attempts <=3 {
// 			attempts += 1;
// 			match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 				.header("X-Auth-Signature", &bitstamp_signature)
// 				.header("X-Auth-Nonce", &bitstamp_nonce)
// 				.header("X-Auth-Timestamp", &bitstamp_timestamp)
// 				.header("X-Auth-Version", "v2")
// 				.build() {
// 				Ok(bitstamp_request) => {
// 					match client.execute(bitstamp_request).await {
// 						Ok(bitstamp_response) => {
// 							match bitstamp_response.text().await {
// 								Ok(bitstamp_response_text) => {
// 									match serde_json::from_str::<Value>(&bitstamp_response_text) {
// 										Ok(v) => {
// 											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
// 											let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
// 											match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
// 												(Some(bid_str), Some(ask_str)) => {
// 													match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
// 														(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
// 															// Place your calculations and updates here
// 															//coinbase calculations to buy
// 															let coinbase_taker_fee = 0.008;
// 															let fraction_of_wallet_im_using = 0.06; //aka 6 percent
// 															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
// 															let fee_for_purchase = total_spent*coinbase_taker_fee;
// 															let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
// 															*coinbase_wallet -= total_spent;
// 															let amount_of_sol = 
// 															money_going_to_sol_after_fees/coinbase_buy_price_ask
// 																							.expect(&format!("i14: coinbase_buy_price_ask is somehow Not Some. 
// 																							even though to get to this point it had to be Some. 
// 																							coinbase_buy_price_ask: {:?}
// 																							Honestly restart the program from the last saved state. 
// 																							The most likely error is a bit got flipped after the loop",
// 																							&coinbase_buy_price_ask));
// 															//bitstamp calculations for sell
// 															let bitstamp_taker_fee = 0.004;
// 															let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
// 															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
// 															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
// 															*bitstamp_wallet += money_from_sell_after_fees;
// 															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
// 															if let Some(mut value_after) = value_after {
// 																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
// 																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
// 																value_after = standardization_functions::normal_value_prior_standardization(&value_after);																
// 																//value_after = 56
// 																//coinbase = 57
// 																//bitstamp = 58
// 																//kraken = 59
// 																//gemini = 60
// 																//since this is coinbase and bitstamp being updated, I will update:
// 																//  56, 57, 58
// 																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
// 																let indices = [56, 57, 58];
// 																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
// 																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 																neural_network.update_input(&indices, &scaled_values).await;
// 															}
// 															//03/08/24 - removed:
// 															// //value_after = 56
// 															// //coinbase = 57
// 															// //bitstamp = 58
// 															// //kraken = 59
// 															// //gemini = 60
// 															// //since this is coinbase and bitstamp being updated, I will update:
// 															// //  56, 57, 58
// 															// let indices = [56, 57, 58];
// 															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
// 															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 															// neural_network.update_input(&indices, &scaled_values).await;
// 															success = true;
// 														},
// 														_ => {
// 															log::error!("i16: Failed to f64 parse bid or ask price");
// 															if attempts > 3 {
// 																panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 															}
// 															continue;
// 														}
// 													}
// 												},
// 												_ => {
// 													log::error!("i16: Failed to originally parse bid or ask price");
// 													if attempts > 3 {
// 														panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 													}
// 													continue;
// 												}
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i16: Failed to parse JSON");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
// 											}
// 											continue;
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i16: failed to get response text");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue;
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i16: Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue;
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i16: Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue;
// 				}
// 			}
// 		}
// 		match value_after {
// 			Some(value) => return Ok(value),
// 			None => {
// 				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
// 				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
// 			}
// 		}
// 			//03/02/24 - removed:
//             // //coinbase calculations
//             //     let coinbase_taker_fee = 0.008;
//             //     let total_spent = 0.03*(*coinbase_wallet);
//             //     let fee_for_purchase = total_spent*coinbase_taker_fee;
//             //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
//             //     //new state of coinbase wallet below
//             //     *coinbase_wallet -= total_spent;
//             //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
//             // //kraken calculations
//             //     //let kraken_taker_fee = 0.0026;
//             //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
//             //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
//             //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
//             //     //*kraken_wallet += money_from_sell_after_fees;   
//             //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;   
//             // //bitstamp calculations
//             //     let bitstamp_taker_fee = 0.004;
//             //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
//             //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
//             //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
//             //     *bitstamp_wallet += money_from_sell_after_fees;
//             // //this will count as value after
//             //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             //     //value_after = 56
//             //     //coinbase = 57
//             //     //bitstamp = 58
//             //     //kraken = 59
//             //     //gemini = 60
//             //     //since this is coinbase and kraken being updated, I will update:
//             //     //  56, 57, 59
//             //     let indices = [56, 57, 58];
//             //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
//             //     //01/24/24 - removed and added:
//             //         //neural_network.update_input(&indices, &new_values);
//             //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
//             //         //neural_network.update_input(&indices, &transformed_values).await;
//             //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
//             //         neural_network.update_input(&indices, &scaled_values).await;
//             //     return Ok(value_after)
//     }
//     pub async fn s_i17_sol_7_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
//         gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
// 			//03/02/24 - added:
//             // let now = Utc::now();
//             // let time_stamp = now.timestamp().to_string();
//             // let method = "GET";
//             // let request_path = "/api/v3/brokerage/best_bid_ask";
//             // let body = "";
//             // let message = format!("{}{}{}{}", &time_stamp, 
//             // &method, &request_path, &body);
//             // type HmacSha256 = Hmac<Sha256>;
//             // fn sign(message: &str, coinbase_secret: &str) -> String {
//             // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
//             //             .expect("HMAC can take key of any size");
//             // mac.update(message.as_bytes());
//             // let result = mac.finalize();
//             // let code_bytes = result.into_bytes();
//             // hex::encode(code_bytes)
//             // }
//             // let coinbase_signature = sign(&message, &coinbase_secret);
//             // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
//             // .header("CB-ACCESS-KEY", coinbase_api_key)
//             // .header("CB-ACCESS-SIGN", &coinbase_signature)
//             // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
//             // .build()
//             // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //manages the error I described above
//             // //let request = match request {
//             // //Ok(req) => req,
//             // //Err(e) => {
//             // //eprintln!("Failed to build request: \n{}", e);
//             // //return Err(e);
//             // //}
//             // //};
//             // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //let response = match response {
//             // //    Ok(resp) => resp,
//             // //    Err(e) => {
//             // //        eprintln!("Failed to execute request: \n{}", e);
//             // //        return Err(e);
//             // //    }
//             // //};
//             // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //added 12/29/23
//             // //this is the parsing
//             // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // let mut coinbase_sell_price = 0.0;
//             // let mut coinbase_buy_price = 0.0;
//             // // Access the pricebooks array
//             // if let Some(pricebooks) = v["pricebooks"].as_array() {
//             //     // Iterate over each pricebook
//             //     for pricebook in pricebooks {
//             //         // Access the product_id, bids, and asks
//             //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
//             //         let bids = &pricebook["bids"][0];
//             //         let asks = &pricebook["asks"][0];     
//             //         // Access the price and size of the bids and asks
//             //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
//             //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");     
//             //         println!("Product ID: {}", product_id);
//             //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
//             //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
//             //     }
//             // }
//             //manages any errors from line above
//             //let response_text = match response_text {
//             //    Ok(t) => t,
//             //    Err(e) => {
//             //        eprintln!("Failed to read response text: \n{}", e);
//             //        return;
//             //    }
//             //};
//             //prints the actual response
//             //println!("list accounts response\n{:?}", &response_text);
// 	//03/02/24 - added:
// 		let now = Utc::now();
// 		let time_stamp = now.timestamp().to_string();
// 		let method = "GET";
// 		let request_path = "/api/v3/brokerage/best_bid_ask";
// 		let body = "";
// 		let message = format!("{}{}{}{}", &time_stamp, 
// 			&method, &request_path, &body);
// 		type HmacSha256 = Hmac<Sha256>;
// 		fn sign(message: &str, coinbase_secret: &str) -> String {
// 			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
// 					.expect("HMAC can take key of any size");
// 			mac.update(message.as_bytes());
// 			let result = mac.finalize();
// 			let code_bytes = result.into_bytes();
// 			hex::encode(code_bytes)
// 		}
// 		let coinbase_signature = sign(&message, &coinbase_secret);	
// 		let mut coinbase_buy_price_ask: Option<f64> = None;
// 		let mut attempts = 0;
// 		let mut success = false;
// 		loop {
// 			attempts +=1;
// 			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
// 			.header("CB-ACCESS-KEY", coinbase_api_key)
// 			.header("CB-ACCESS-SIGN", &coinbase_signature)
// 			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
// 			.build();
// 			match request {
// 				Ok(req) => {
// 					let response = client.execute(req).await;
// 					match response {
// 						Ok(resp) => {
// 							let response_text = resp.text().await;
// 							match response_text {
// 								Ok(text) => {
// 									match serde_json::from_str::<Value>(&text) {
// 										Ok(v) => {
// 											if let Some(pricebooks) = v["pricebooks"].as_array() {
// 												for pricebook in pricebooks {
// 													//let product_id = pricebook["product_id"].as_str();
// 													//let bids = &pricebook["bids"][0];
// 													let asks = &pricebook["asks"][0];
// 													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
// 													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
// 													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
// 														(/*Some(bid_str),*/ Some(ask_str)) => {
// 															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
// 																(/*Ok(bid_str),*/ Ok(ask_str)) => {
// 																	//coinbase_sell_price_bid = Some(bid_str);
// 																	coinbase_buy_price_ask = Some(ask_str);
// 																		success = true;
// 																},
// 																_ => {
// 																	log::error!("i17:  coinbase:  Failed to f64 parse JSON");
// 																	if attempts > 3 {
// 																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 																	}
// 																	continue ;
// 																}
// 															}
// 														},
// 														_ => {
// 															log::error!("i17:  coinbase:  Failed to get ask price");
// 															if attempts > 3 {
// 																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
// 																panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
// 															}
// 															continue ;
// 														}
// 													}
// 												}
// 											//03/02/24 - added else condition
// 											} else {
// 												log::error!("i17:  coinbase:  Failed to get pricebooks as array.");
// 												if attempts > 3 {
// 													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
// 												}
// 												continue;
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i17:  coinbase:  Failed to parse outer JSON as str.");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 											}
// 											continue ; // Continue to the next iteration if parsing fails
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i17:  coinbase:  Failed to get response text.");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue ; // Continue to the next iteration if getting response text fails
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i17:  coinbase:  Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue; // Continue to the next iteration if executing request fails
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i17:  coinbase:  Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue; // Continue to the next iteration if building request fails
// 				}
// 			}
// 			if success == true {
// 				break;
// 			}
// 		}
//             //02/09/24 - updated tokio. removed:  
//                 //delay_for(Duration::from_secs(3)).await;
//             //02/09/24 - updated tokio. added in its place:
//             println!("sol 7 coinbase bitstamp: 3 sec delay");
//             let when = tokio::time::Instant::now() + Duration::from_secs(3);
//             tokio::time::sleep_until(when).await;
//     //-------------------------Bitstamp---------------------------//
//                 //Bitstamp for some reason needs nonce to be 36 characters long. 
// 	//	nonce is basically a unique id that needs to be different every time you make a request. 
// 	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
// 	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
// 	//	and just make it a random 36 char string from it.
// 	//the exact same as the Coinbase signature. we'll see if it works
// 	//apparently it doesnt so I will code comment it out for now
// 	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 	//											.expect("HMAC can take key of any size");
// 	//	mac.update(bitstamp_message.as_bytes());
// 	//	let result = mac.finalize();
// 	//	let code_bytes = result.into_bytes();
// 	//	hex::encode(code_bytes)
// 	//}
// 	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 			.expect("HMAC can take key of any size");
// 		mac.update(bitstamp_message.as_bytes());
// 		let result = mac.finalize();
// 		let code_bytes = result.into_bytes();
// 		hex::encode(code_bytes)
// 	}
// 	let content_type = "application/x-www-form-urlencoded";
// 	let payload_string = "offset=1";
// 	//if we needed content_type, it is here
// 	//let content_type = "application/json";
// 	//this is the bitstamp message IF we needed content_type
// 	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
// 	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// //--------------------Account-balances------------------------------------------//
// 	let the_uuid = Uuid::new_v4();
// 	let bitstamp_nonce = the_uuid.to_string();
// 	let bitstamp_timestamp = now.timestamp_millis().to_string();
// 	//let content_type = "application/x-www-form-urlencoded";
// 	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
// 			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// 	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
// 	//03/02/24 - removed:
// 	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 	// 		.header("X-Auth-Signature", bitstamp_signature)
// 	// 		.header("X-Auth-Nonce", bitstamp_nonce)
// 	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
// 	// 		.header("X-Auth-Version", "v2")
// 	// 		//.header("Content-Type", content_type)
// 	// 		//.body(payload_string)
// 	// 		.build()
// 	// 		.expect("\ncould not build bitstamp_request");
// 	// 	let bitstamp_response = client.execute(bitstamp_request).await
// 	// 		.expect("Failed to execute Bitstamp request");
// 	// 	let bitstamp_response_text = bitstamp_response.text().await
// 	// 		.expect("Failed to turn response into text");
// 	// 	//probably dont need "bitstamp" once we transfer this to the actual function
// 	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
// 	//     .expect("Failed to parse JSON");
// 	// // Extract the bid and ask values
// 	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
// 	// 	println!("Bitstamp:\n{:?}", bitstamp_response_text);
// 	//03/02/24 - added:
// 		let mut success = false;
// 		let mut attempts = 0;
// 		let mut value_after: Option<f64> = None;
// 		while !success && attempts <=3 {
// 			attempts += 1;
// 			match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 				.header("X-Auth-Signature", &bitstamp_signature)
// 				.header("X-Auth-Nonce", &bitstamp_nonce)
// 				.header("X-Auth-Timestamp", &bitstamp_timestamp)
// 				.header("X-Auth-Version", "v2")
// 				.build() {
// 				Ok(bitstamp_request) => {
// 					match client.execute(bitstamp_request).await {
// 						Ok(bitstamp_response) => {
// 							match bitstamp_response.text().await {
// 								Ok(bitstamp_response_text) => {
// 									match serde_json::from_str::<Value>(&bitstamp_response_text) {
// 										Ok(v) => {
// 											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
// 											let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
// 											match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
// 												(Some(bid_str), Some(ask_str)) => {
// 													match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
// 														(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
// 															// Place your calculations and updates here
// 															//coinbase calculations to buy
// 															let coinbase_taker_fee = 0.008;
// 															let fraction_of_wallet_im_using = 0.07; //aka 7 percent
// 															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
// 															let fee_for_purchase = total_spent*coinbase_taker_fee;
// 															let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
// 															*coinbase_wallet -= total_spent;
// 															let amount_of_sol = 
// 															money_going_to_sol_after_fees/coinbase_buy_price_ask
// 																							.expect(&format!("i17: coinbase_buy_price_ask is somehow Not Some. 
// 																							even though to get to this point it had to be Some. 
// 																							coinbase_buy_price_ask: {:?}
// 																							Honestly restart the program from the last saved state. 
// 																							The most likely error is a bit got flipped after the loop",
// 																							&coinbase_buy_price_ask));
// 															//bitstamp calculations for sell
// 															let bitstamp_taker_fee = 0.004;
// 															let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
// 															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
// 															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
// 															*bitstamp_wallet += money_from_sell_after_fees;
// 															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
// 															if let Some(mut value_after) = value_after {
// 																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
// 																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
// 																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
// 																//value_after = 56
// 																//coinbase = 57
// 																//bitstamp = 58
// 																//kraken = 59
// 																//gemini = 60
// 																//since this is coinbase and bitstamp being updated, I will update:
// 																//  56, 57, 58
// 																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
// 																let indices = [56, 57, 58];
// 																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
// 																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 																neural_network.update_input(&indices, &scaled_values).await;
// 															}
// 															//03/08/24 - removed:
// 															// //value_after = 56
// 															// //coinbase = 57
// 															// //bitstamp = 58
// 															// //kraken = 59
// 															// //gemini = 60
// 															// //since this is coinbase and bitstamp being updated, I will update:
// 															// //  56, 57, 58
// 															// let indices = [56, 57, 58];
// 															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
// 															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 															// neural_network.update_input(&indices, &scaled_values).await;
// 															success = true;
// 														},
// 														_ => {
// 															log::error!("i17: Failed to f64 parse bid or ask price");
// 															if attempts > 3 {
// 																panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 															}
// 															continue;
// 														}
// 													}
// 												},
// 												_ => {
// 													log::error!("i17: Failed to originally parse bid or ask price");
// 													if attempts > 3 {
// 														panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 													}
// 													continue;
// 												}
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i17: Failed to parse JSON");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
// 											}
// 											continue;
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i17: failed to get response text");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue;
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i17: Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue;
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i17: Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue;
// 				}
// 			}
// 		}
// 		match value_after {
// 			Some(value) => return Ok(value),
// 			None => {
// 				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
// 				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
// 			}
// 		}
// 			//03/02/24 - removed:
//             // //coinbase calculations
//             //     let coinbase_taker_fee = 0.008;
//             //     let total_spent = 0.03*(*coinbase_wallet);
//             //     let fee_for_purchase = total_spent*coinbase_taker_fee;
//             //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
//             //     //new state of coinbase wallet below
//             //     *coinbase_wallet -= total_spent;
//             //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;  
//             // //kraken calculations
//             //     //let kraken_taker_fee = 0.0026;                
//             //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
//             //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
//             //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
//             //     //*kraken_wallet += money_from_sell_after_fees;    
//             //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;        
//             // //bitstamp calculations
//             //     let bitstamp_taker_fee = 0.004;
//             //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
//             //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
//             //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
//             //     *bitstamp_wallet += money_from_sell_after_fees;
//             // //this will count as value after
//             //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;   
//             //     //value_after = 56
//             //     //coinbase = 57
//             //     //bitstamp = 58
//             //     //kraken = 59
//             //     //gemini = 60
//             //     //since this is coinbase and kraken being updated, I will update:
//             //     //  56, 57, 59
//             //     let indices = [56, 57, 58];
//             //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
//             //     //01/24/24 - removed and added:
//             //         //neural_network.update_input(&indices, &new_values);
//             //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
//             //         //neural_network.update_input(&indices, &transformed_values).await;
//             //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
//             //         neural_network.update_input(&indices, &scaled_values).await;        
//             //     return Ok(value_after)
//     }
//     pub async fn s_i18_sol_8_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
//         gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
// 			//03/02/24 - added:
//             // let now = Utc::now();
//             // let time_stamp = now.timestamp().to_string();
//             // let method = "GET";
//             // let request_path = "/api/v3/brokerage/best_bid_ask";
//             // let body = "";
//             // let message = format!("{}{}{}{}", &time_stamp, 
//             // &method, &request_path, &body);
//             // type HmacSha256 = Hmac<Sha256>;
//             // fn sign(message: &str, coinbase_secret: &str) -> String {
//             // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
//             //             .expect("HMAC can take key of any size");
//             // mac.update(message.as_bytes());
//             // let result = mac.finalize();
//             // let code_bytes = result.into_bytes();
//             // hex::encode(code_bytes)
//             // }
//             // let coinbase_signature = sign(&message, &coinbase_secret);    
//             // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
//             // .header("CB-ACCESS-KEY", coinbase_api_key)
//             // .header("CB-ACCESS-SIGN", &coinbase_signature)
//             // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
//             // .build()
//             // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //manages the error I described above
//             // //let request = match request {
//             // //Ok(req) => req,
//             // //Err(e) => {
//             // //eprintln!("Failed to build request: \n{}", e);
//             // //return Err(e);
//             // //}
//             // //};    
//             // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //let response = match response {
//             // //    Ok(resp) => resp,
//             // //    Err(e) => {
//             // //        eprintln!("Failed to execute request: \n{}", e);
//             // //        return Err(e);
//             // //    }
//             // //};    
//             // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;    
//             // //added 12/29/23
//             // //this is the parsing
//             // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // let mut coinbase_sell_price = 0.0;
//             // let mut coinbase_buy_price = 0.0;    
//             // // Access the pricebooks array
//             // if let Some(pricebooks) = v["pricebooks"].as_array() {
//             //     // Iterate over each pricebook
//             //     for pricebook in pricebooks {
//             //         // Access the product_id, bids, and asks
//             //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
//             //         let bids = &pricebook["bids"][0];
//             //         let asks = &pricebook["asks"][0];            
//             //         // Access the price and size of the bids and asks
//             //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
//             //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");            
//             //         println!("Product ID: {}", product_id);
//             //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
//             //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
//             //     }
//             // }    
//             //manages any errors from line above
//             //let response_text = match response_text {
//             //    Ok(t) => t,
//             //    Err(e) => {
//             //        eprintln!("Failed to read response text: \n{}", e);
//             //        return;
//             //    }
//             //};    
//             //prints the actual response
//             //println!("list accounts response\n{:?}", &response_text);            
// 	//03/02/24 - added:
// 		let now = Utc::now();
// 		let time_stamp = now.timestamp().to_string();
// 		let method = "GET";
// 		let request_path = "/api/v3/brokerage/best_bid_ask";
// 		let body = "";
// 		let message = format!("{}{}{}{}", &time_stamp, 
// 			&method, &request_path, &body);
// 		type HmacSha256 = Hmac<Sha256>;
// 		fn sign(message: &str, coinbase_secret: &str) -> String {
// 			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
// 					.expect("HMAC can take key of any size");
// 			mac.update(message.as_bytes());
// 			let result = mac.finalize();
// 			let code_bytes = result.into_bytes();
// 			hex::encode(code_bytes)
// 		}
// 		let coinbase_signature = sign(&message, &coinbase_secret);		
// 		let mut coinbase_buy_price_ask: Option<f64> = None;
// 		let mut attempts = 0;
// 		let mut success = false;
// 		loop {
// 			attempts +=1;
// 			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
// 			.header("CB-ACCESS-KEY", coinbase_api_key)
// 			.header("CB-ACCESS-SIGN", &coinbase_signature)
// 			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
// 			.build();
// 			match request {
// 				Ok(req) => {
// 					let response = client.execute(req).await;
// 					match response {
// 						Ok(resp) => {
// 							let response_text = resp.text().await;
// 							match response_text {
// 								Ok(text) => {
// 									match serde_json::from_str::<Value>(&text) {
// 										Ok(v) => {
// 											if let Some(pricebooks) = v["pricebooks"].as_array() {
// 												for pricebook in pricebooks {
// 													//let product_id = pricebook["product_id"].as_str();
// 													//let bids = &pricebook["bids"][0];
// 													let asks = &pricebook["asks"][0];
// 													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
// 													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();		
// 													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
// 														(/*Some(bid_str),*/ Some(ask_str)) => {
// 															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
// 																(/*Ok(bid_str),*/ Ok(ask_str)) => {
// 																	//coinbase_sell_price_bid = Some(bid_str);
// 																	coinbase_buy_price_ask = Some(ask_str);	
// 																		success = true;
// 																},
// 																_ => {
// 																	log::error!("i18:  coinbase:  Failed to f64 parse JSON");
// 																	if attempts > 3 {
// 																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 																	}
// 																	continue ;
// 																}
// 															}
// 														},
// 														_ => {
// 															log::error!("i18:  coinbase:  Failed to get ask price");
// 															if attempts > 3 {
// 																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
// 																panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
// 															}
// 															continue ;
// 														}
// 													}
// 												}
// 											//03/02/24 - added else condition
// 											} else {
// 												log::error!("i18:  coinbase:  Failed to get pricebooks as array.");
// 												if attempts > 3 {
// 													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
// 												}
// 												continue;
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i18:  coinbase:  Failed to parse outer JSON as str.");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 											}
// 											continue ; // Continue to the next iteration if parsing fails
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i18:  coinbase:  Failed to get response text.");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue ; // Continue to the next iteration if getting response text fails
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i18:  coinbase:  Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue; // Continue to the next iteration if executing request fails
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i18:  coinbase:  Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue; // Continue to the next iteration if building request fails
// 				}
// 			}
// 			if success == true {
// 				break;
// 			}
// 		}
//             //02/09/24 - updated tokio. removed:  
//                 //delay_for(Duration::from_secs(3)).await;
//             //02/09/24 - updated tokio. added in its place:
//             println!("sol 8 coinbase bitstamp: 3 sec delay");
//             let when = tokio::time::Instant::now() + Duration::from_secs(3);
//             tokio::time::sleep_until(when).await;
//     //-------------------------Bitstamp---------------------------//
//                 //Bitstamp for some reason needs nonce to be 36 characters long. 
// 	//	nonce is basically a unique id that needs to be different every time you make a request. 
// 	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
// 	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
// 	//	and just make it a random 36 char string from it.
// 	//the exact same as the Coinbase signature. we'll see if it works
// 	//apparently it doesnt so I will code comment it out for now
// 	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 	//											.expect("HMAC can take key of any size");
// 	//	mac.update(bitstamp_message.as_bytes());
// 	//	let result = mac.finalize();
// 	//	let code_bytes = result.into_bytes();
// 	//	hex::encode(code_bytes)
// 	//}
// 	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 			.expect("HMAC can take key of any size");
// 		mac.update(bitstamp_message.as_bytes());
// 		let result = mac.finalize();
// 		let code_bytes = result.into_bytes();
// 		hex::encode(code_bytes)
// 	}
// 	let content_type = "application/x-www-form-urlencoded";
// 	let payload_string = "offset=1";
// 	//if we needed content_type, it is here
// 	//let content_type = "application/json";
// 	//this is the bitstamp message IF we needed content_type
// 	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
// 	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// //--------------------Account-balances------------------------------------------//
// 	let the_uuid = Uuid::new_v4();
// 	let bitstamp_nonce = the_uuid.to_string();
// 	let bitstamp_timestamp = now.timestamp_millis().to_string();
// 	//let content_type = "application/x-www-form-urlencoded";
// 	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
// 			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// 	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
// 	//03/02/24 - removed:
// 	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 	// 		.header("X-Auth-Signature", bitstamp_signature)
// 	// 		.header("X-Auth-Nonce", bitstamp_nonce)
// 	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
// 	// 		.header("X-Auth-Version", "v2")
// 	// 		//.header("Content-Type", content_type)
// 	// 		//.body(payload_string)
// 	// 		.build()
// 	// 		.expect("\ncould not build bitstamp_request");
// 	// 	let bitstamp_response = client.execute(bitstamp_request).await
// 	// 		.expect("Failed to execute Bitstamp request");
// 	// 	let bitstamp_response_text = bitstamp_response.text().await
// 	// 		.expect("Failed to turn response into text");
// 	// 	//probably dont need "bitstamp" once we transfer this to the actual function
// 	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
// 	//     .expect("Failed to parse JSON");
// 	// // Extract the bid and ask values
// 	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
// 	// 	println!("Bitstamp:\n{:?}", bitstamp_response_text);       
// 	//03/02/24 - added:
// 		let mut success = false;
// 		let mut attempts = 0;
// 		let mut value_after: Option<f64> = None;
// 		while !success && attempts <=3 {
// 			attempts += 1;
// 			match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 				.header("X-Auth-Signature", &bitstamp_signature)
// 				.header("X-Auth-Nonce", &bitstamp_nonce)
// 				.header("X-Auth-Timestamp", &bitstamp_timestamp)
// 				.header("X-Auth-Version", "v2")
// 				.build() {
// 				Ok(bitstamp_request) => {
// 					match client.execute(bitstamp_request).await {
// 						Ok(bitstamp_response) => {
// 							match bitstamp_response.text().await {
// 								Ok(bitstamp_response_text) => {
// 									match serde_json::from_str::<Value>(&bitstamp_response_text) {
// 										Ok(v) => {
// 											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
// 											let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
// 											match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
// 												(Some(bid_str), Some(ask_str)) => {
// 													match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
// 														(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
// 															// Place your calculations and updates here
// 															//coinbase calculations to buy
// 															let coinbase_taker_fee = 0.008;
// 															let fraction_of_wallet_im_using = 0.08; //aka 8 percent
// 															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
// 															let fee_for_purchase = total_spent*coinbase_taker_fee;
// 															let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
// 															*coinbase_wallet -= total_spent;
// 															let amount_of_sol = 
// 															money_going_to_sol_after_fees/coinbase_buy_price_ask
// 																							.expect(&format!("i18: coinbase_buy_price_ask is somehow Not Some. 
// 																							even though to get to this point it had to be Some. 
// 																							coinbase_buy_price_ask: {:?}
// 																							Honestly restart the program from the last saved state. 
// 																							The most likely error is a bit got flipped after the loop",
// 																							&coinbase_buy_price_ask));
// 															//bitstamp calculations for sell
// 															let bitstamp_taker_fee = 0.004;
// 															let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
// 															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
// 															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
// 															*bitstamp_wallet += money_from_sell_after_fees;
// 															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
// 															if let Some(mut value_after) = value_after {
// 																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
// 																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
// 																value_after = standardization_functions::normal_value_prior_standardization(&value_after);															
// 																//value_after = 56
// 																//coinbase = 57
// 																//bitstamp = 58
// 																//kraken = 59
// 																//gemini = 60
// 																//since this is coinbase and bitstamp being updated, I will update:
// 																//  56, 57, 58
// 																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
// 																let indices = [56, 57, 58];
// 																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
// 																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 																neural_network.update_input(&indices, &scaled_values).await;
// 															}
// 															//03/08/24 - removed:
// 															// //value_after = 56
// 															// //coinbase = 57
// 															// //bitstamp = 58
// 															// //kraken = 59
// 															// //gemini = 60
// 															// //since this is coinbase and bitstamp being updated, I will update:
// 															// //  56, 57, 58
// 															// let indices = [56, 57, 58];
// 															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
// 															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 															// neural_network.update_input(&indices, &scaled_values).await;
// 															success = true;
// 														},
// 														_ => {
// 															log::error!("i18: Failed to f64 parse bid or ask price");
// 															if attempts > 3 {
// 																panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 															}
// 															continue;
// 														}
// 													}
// 												},
// 												_ => {
// 													log::error!("i18: Failed to originally parse bid or ask price");
// 													if attempts > 3 {
// 														panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 													}
// 													continue;
// 												}
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i18: Failed to parse JSON");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
// 											}
// 											continue;
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i18: failed to get response text");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue;
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i18: Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue;
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i18: Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue;
// 				}
// 			}
// 		}
// 		match value_after {
// 			Some(value) => return Ok(value),
// 			None => {
// 				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
// 				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
// 			}
// 		}
// 			//03/02/24 - removed:
//             // //coinbase calculations
//             //     let coinbase_taker_fee = 0.008;   
//             //     let total_spent = 0.03*(*coinbase_wallet);
//             //     let fee_for_purchase = total_spent*coinbase_taker_fee;
//             //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
//             //     //new state of coinbase wallet below
//             //     *coinbase_wallet -= total_spent;
//             //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;    
//             // //kraken calculations
//             //     //let kraken_taker_fee = 0.0026;                
//             //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
//             //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
//             //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
//             //     //*kraken_wallet += money_from_sell_after_fees;    
//             //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;        
//             // //bitstamp calculations
//             //     let bitstamp_taker_fee = 0.004;
//             //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
//             //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
//             //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
//             //     *bitstamp_wallet += money_from_sell_after_fees;
//             // //this will count as value after
//             //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;    
//             //     //value_after = 56
//             //     //coinbase = 57
//             //     //bitstamp = 58
//             //     //kraken = 59
//             //     //gemini = 60
//             //     //since this is coinbase and kraken being updated, I will update:
//             //     //  56, 57, 59
//             //     let indices = [56, 57, 58];
//             //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
//             //     //01/24/24 - removed and added:
//             //         //neural_network.update_input(&indices, &new_values);
//             //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
//             //         //neural_network.update_input(&indices, &transformed_values).await;
//             //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
//             //         neural_network.update_input(&indices, &scaled_values).await;    
//             //     return Ok(value_after)
//     }
//     pub async fn s_i19_sol_9_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
//         gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
// 			//03/02/24 - added:
//             // let now = Utc::now();
//             // let time_stamp = now.timestamp().to_string();
//             // let method = "GET";
//             // let request_path = "/api/v3/brokerage/best_bid_ask";
//             // let body = "";
//             // let message = format!("{}{}{}{}", &time_stamp, 
//             // &method, &request_path, &body);
//             // type HmacSha256 = Hmac<Sha256>;
//             // fn sign(message: &str, coinbase_secret: &str) -> String {
//             // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
//             //             .expect("HMAC can take key of any size");
//             // mac.update(message.as_bytes());
//             // let result = mac.finalize();
//             // let code_bytes = result.into_bytes();
//             // hex::encode(code_bytes)
//             // }
//             // let coinbase_signature = sign(&message, &coinbase_secret);    
//             // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
//             // .header("CB-ACCESS-KEY", coinbase_api_key)
//             // .header("CB-ACCESS-SIGN", &coinbase_signature)
//             // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
//             // .build()
//             // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //manages the error I described above
//             // //let request = match request {
//             // //Ok(req) => req,
//             // //Err(e) => {
//             // //eprintln!("Failed to build request: \n{}", e);
//             // //return Err(e);
//             // //}
//             // //};    
//             // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //let response = match response {
//             // //    Ok(resp) => resp,
//             // //    Err(e) => {
//             // //        eprintln!("Failed to execute request: \n{}", e);
//             // //        return Err(e);
//             // //    }
//             // //};       
//             // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;    
//             // //added 12/29/23
//             // //this is the parsing
//             // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // let mut coinbase_sell_price = 0.0;
//             // let mut coinbase_buy_price = 0.0;    
//             // // Access the pricebooks array
//             // if let Some(pricebooks) = v["pricebooks"].as_array() {
//             //     // Iterate over each pricebook
//             //     for pricebook in pricebooks {
//             //         // Access the product_id, bids, and asks
//             //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
//             //         let bids = &pricebook["bids"][0];
//             //         let asks = &pricebook["asks"][0];            
//             //         // Access the price and size of the bids and asks
//             //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
//             //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");            
//             //         println!("Product ID: {}", product_id);
//             //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
//             //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
//             //     }
//             // }    
//             //manages any errors from line above
//             //let response_text = match response_text {
//             //    Ok(t) => t,
//             //    Err(e) => {
//             //        eprintln!("Failed to read response text: \n{}", e);
//             //        return;
//             //    }
//             //};    
//             //prints the actual response
//             //println!("list accounts response\n{:?}", &response_text);            
// 	//03/02/24 - added:
// 		let now = Utc::now();
// 		let time_stamp = now.timestamp().to_string();
// 		let method = "GET";
// 		let request_path = "/api/v3/brokerage/best_bid_ask";
// 		let body = "";
// 		let message = format!("{}{}{}{}", &time_stamp, 
// 			&method, &request_path, &body);
// 		type HmacSha256 = Hmac<Sha256>;
// 		fn sign(message: &str, coinbase_secret: &str) -> String {
// 			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
// 					.expect("HMAC can take key of any size");
// 			mac.update(message.as_bytes());
// 			let result = mac.finalize();
// 			let code_bytes = result.into_bytes();
// 			hex::encode(code_bytes)
// 		}
// 		let coinbase_signature = sign(&message, &coinbase_secret);		
// 		let mut coinbase_buy_price_ask: Option<f64> = None;
// 		let mut attempts = 0;
// 		let mut success = false;
// 		loop {
// 			attempts +=1;
// 			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
// 			.header("CB-ACCESS-KEY", coinbase_api_key)
// 			.header("CB-ACCESS-SIGN", &coinbase_signature)
// 			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
// 			.build();
// 			match request {
// 				Ok(req) => {
// 					let response = client.execute(req).await;
// 					match response {
// 						Ok(resp) => {
// 							let response_text = resp.text().await;
// 							match response_text {
// 								Ok(text) => {
// 									match serde_json::from_str::<Value>(&text) {
// 										Ok(v) => {
// 											if let Some(pricebooks) = v["pricebooks"].as_array() {
// 												for pricebook in pricebooks {
// 													//let product_id = pricebook["product_id"].as_str();
// 													//let bids = &pricebook["bids"][0];
// 													let asks = &pricebook["asks"][0];
// 													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
// 													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();		
// 													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
// 														(/*Some(bid_str),*/ Some(ask_str)) => {
// 															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
// 																(/*Ok(bid_str),*/ Ok(ask_str)) => {
// 																	//coinbase_sell_price_bid = Some(bid_str);
// 																	coinbase_buy_price_ask = Some(ask_str);	
// 																		success = true;
// 																},
// 																_ => {
// 																	log::error!("i19:  coinbase:  Failed to f64 parse JSON");
// 																	if attempts > 3 {
// 																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 																	}
// 																	continue ;
// 																}
// 															}
// 														},
// 														_ => {
// 															log::error!("i19:  coinbase:  Failed to get ask price");
// 															if attempts > 3 {
// 																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
// 																panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
// 															}
// 															continue ;
// 														}
// 													}
// 												}
// 											//03/02/24 - added else condition
// 											} else {
// 												log::error!("i19:  coinbase:  Failed to get pricebooks as array.");
// 												if attempts > 3 {
// 													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
// 												}
// 												continue;
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i19:  coinbase:  Failed to parse outer JSON as str.");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 											}
// 											continue ; // Continue to the next iteration if parsing fails
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i19:  coinbase:  Failed to get response text.");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue ; // Continue to the next iteration if getting response text fails
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i19:  coinbase:  Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue; // Continue to the next iteration if executing request fails
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i19:  coinbase:  Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue; // Continue to the next iteration if building request fails
// 				}
// 			}
// 			if success == true {
// 				break;
// 			}
// 		} 
//             //02/09/24 - updated tokio. removed:  
//                 //delay_for(Duration::from_secs(3)).await;
//             //02/09/24 - updated tokio. added in its place:
//             println!("sol 9 coinbase bitstamp: 3 sec delay");
//             let when = tokio::time::Instant::now() + Duration::from_secs(3);
//             tokio::time::sleep_until(when).await;
//     //-------------------------Bitstamp---------------------------//
//                 //Bitstamp for some reason needs nonce to be 36 characters long. 
// 	//	nonce is basically a unique id that needs to be different every time you make a request. 
// 	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
// 	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
// 	//	and just make it a random 36 char string from it.	
// 	//the exact same as the Coinbase signature. we'll see if it works
// 	//apparently it doesnt so I will code comment it out for now
// 	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 	//											.expect("HMAC can take key of any size");
// 	//	mac.update(bitstamp_message.as_bytes());
// 	//	let result = mac.finalize();
// 	//	let code_bytes = result.into_bytes();
// 	//	hex::encode(code_bytes)
// 	//}
// 	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 			.expect("HMAC can take key of any size");
// 		mac.update(bitstamp_message.as_bytes());
// 		let result = mac.finalize();
// 		let code_bytes = result.into_bytes();
// 		hex::encode(code_bytes)
// 	}
// 	let content_type = "application/x-www-form-urlencoded";
// 	let payload_string = "offset=1";
// 	//if we needed content_type, it is here
// 	//let content_type = "application/json";
// 	//this is the bitstamp message IF we needed content_type
// 	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
// 	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// //--------------------Account-balances------------------------------------------//
// 	let the_uuid = Uuid::new_v4();
// 	let bitstamp_nonce = the_uuid.to_string();
// 	let bitstamp_timestamp = now.timestamp_millis().to_string();
// 	//let content_type = "application/x-www-form-urlencoded";
// 	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
// 			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// 	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
// 	//03/02/24 - removed:
// 	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 	// 		.header("X-Auth-Signature", bitstamp_signature)
// 	// 		.header("X-Auth-Nonce", bitstamp_nonce)
// 	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
// 	// 		.header("X-Auth-Version", "v2")
// 	// 		//.header("Content-Type", content_type)
// 	// 		//.body(payload_string)
// 	// 		.build()
// 	// 		.expect("\ncould not build bitstamp_request");
// 	// 	let bitstamp_response = client.execute(bitstamp_request).await
// 	// 		.expect("Failed to execute Bitstamp request");
// 	// 	let bitstamp_response_text = bitstamp_response.text().await
// 	// 		.expect("Failed to turn response into text");
// 	// 	//probably dont need "bitstamp" once we transfer this to the actual function
// 	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
// 	//     .expect("Failed to parse JSON");
// 	// // Extract the bid and ask values
// 	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
// 	// 	println!("Bitstamp:\n{:?}", bitstamp_response_text);
// 	//03/02/24 - added:
// 		let mut success = false;
// 		let mut attempts = 0;
// 		let mut value_after: Option<f64> = None;
// 		while !success && attempts <=3 {
// 			attempts += 1;
// 			match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 				.header("X-Auth-Signature", &bitstamp_signature)
// 				.header("X-Auth-Nonce", &bitstamp_nonce)
// 				.header("X-Auth-Timestamp", &bitstamp_timestamp)
// 				.header("X-Auth-Version", "v2")
// 				.build() {
// 				Ok(bitstamp_request) => {
// 					match client.execute(bitstamp_request).await {
// 						Ok(bitstamp_response) => {
// 							match bitstamp_response.text().await {
// 								Ok(bitstamp_response_text) => {
// 									match serde_json::from_str::<Value>(&bitstamp_response_text) {
// 										Ok(v) => {
// 											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
// 											let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
// 											match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
// 												(Some(bid_str), Some(ask_str)) => {
// 													match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
// 														(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
// 															// Place your calculations and updates here
// 															//coinbase calculations to buy
// 															let coinbase_taker_fee = 0.008;
// 															let fraction_of_wallet_im_using = 0.09; //aka 9 percent
// 															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
// 															let fee_for_purchase = total_spent*coinbase_taker_fee;
// 															let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
// 															*coinbase_wallet -= total_spent;
// 															let amount_of_sol = 
// 															money_going_to_sol_after_fees/coinbase_buy_price_ask
// 																							.expect(&format!("i19: coinbase_buy_price_ask is somehow Not Some. 
// 																							even though to get to this point it had to be Some. 
// 																							coinbase_buy_price_ask: {:?}
// 																							Honestly restart the program from the last saved state. 
// 																							The most likely error is a bit got flipped after the loop",
// 																							&coinbase_buy_price_ask));
// 															//bitstamp calculations for sell
// 															let bitstamp_taker_fee = 0.004;
// 															let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
// 															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
// 															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
// 															*bitstamp_wallet += money_from_sell_after_fees;
// 															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
// 															if let Some(mut value_after) = value_after {
// 																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
// 																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
// 																value_after = standardization_functions::normal_value_prior_standardization(&value_after);																
// 																//value_after = 56
// 																//coinbase = 57
// 																//bitstamp = 58
// 																//kraken = 59
// 																//gemini = 60
// 																//since this is coinbase and bitstamp being updated, I will update:
// 																//  56, 57, 58
// 																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
// 																let indices = [56, 57, 58];
// 																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
// 																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 																neural_network.update_input(&indices, &scaled_values).await;
// 															}
// 															//03/08/24 - removed:
// 															// //value_after = 56
// 															// //coinbase = 57
// 															// //bitstamp = 58
// 															// //kraken = 59
// 															// //gemini = 60
// 															// //since this is coinbase and bitstamp being updated, I will update:
// 															// //  56, 57, 58
// 															// let indices = [56, 57, 58];
// 															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
// 															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 															// neural_network.update_input(&indices, &scaled_values).await;
// 															success = true;
// 														},
// 														_ => {
// 															log::error!("i19: Failed to f64 parse bid or ask price");
// 															if attempts > 3 {
// 																panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 															}
// 															continue;
// 														}
// 													}
// 												},
// 												_ => {
// 													log::error!("i19: Failed to originally parse bid or ask price");
// 													if attempts > 3 {
// 														panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 													}
// 													continue;
// 												}
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i19: Failed to parse JSON");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
// 											}
// 											continue;
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i19: failed to get response text");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue;
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i19: Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue;
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i19: Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue;
// 				}
// 			}
// 		}
// 		match value_after {
// 			Some(value) => return Ok(value),
// 			None => {
// 				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
// 				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
// 			}
// 		}
// 			//03/02/24 - removed:
//             // //coinbase calculations
//             //     let coinbase_taker_fee = 0.008;  
//             //     let total_spent = 0.03*(*coinbase_wallet);
//             //     let fee_for_purchase = total_spent*coinbase_taker_fee;
//             //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
//             //     //new state of coinbase wallet below
//             //     *coinbase_wallet -= total_spent;
//             //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;  
//             // //kraken calculations
//             //     //let kraken_taker_fee = 0.0026;              
//             //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
//             //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
//             //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
//             //     //*kraken_wallet += money_from_sell_after_fees;
//             //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             // //bitstamp calculations
//             //     let bitstamp_taker_fee = 0.004;
//             //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
//             //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
//             //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
//             //     *bitstamp_wallet += money_from_sell_after_fees;
//             // //this will count as value after
//             //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             //     //value_after = 56
//             //     //coinbase = 57
//             //     //bitstamp = 58
//             //     //kraken = 59
//             //     //gemini = 60
//             //     //since this is coinbase and kraken being updated, I will update:
//             //     //  56, 57, 59
//             //     let indices = [56, 57, 58];
//             //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
//             //     //01/24/24 - removed and added:
//             //         //neural_network.update_input(&indices, &new_values);
//             //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
//             //         //neural_network.update_input(&indices, &transformed_values).await;
//             //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
//             //         neural_network.update_input(&indices, &scaled_values).await;
//             //     return Ok(value_after)
//     }
//     pub async fn s_i20_sol_10_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
//         gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
// 			//03/02/24 - added:
//             // let now = Utc::now();
//             // let time_stamp = now.timestamp().to_string();
//             // let method = "GET";
//             // let request_path = "/api/v3/brokerage/best_bid_ask";
//             // let body = "";
//             // let message = format!("{}{}{}{}", &time_stamp, 
//             // &method, &request_path, &body);
//             // type HmacSha256 = Hmac<Sha256>;
//             // fn sign(message: &str, coinbase_secret: &str) -> String {
//             // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
//             //             .expect("HMAC can take key of any size");
//             // mac.update(message.as_bytes());
//             // let result = mac.finalize();
//             // let code_bytes = result.into_bytes();
//             // hex::encode(code_bytes)
//             // }
//             // let coinbase_signature = sign(&message, &coinbase_secret);
//             // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
//             // .header("CB-ACCESS-KEY", coinbase_api_key)
//             // .header("CB-ACCESS-SIGN", &coinbase_signature)
//             // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
//             // .build()
//             // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //manages the error I described above
//             // //let request = match request {
//             // //Ok(req) => req,
//             // //Err(e) => {
//             // //eprintln!("Failed to build request: \n{}", e);
//             // //return Err(e);
//             // //}
//             // //};   
//             // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // //let response = match response {
//             // //    Ok(resp) => resp,
//             // //    Err(e) => {
//             // //        eprintln!("Failed to execute request: \n{}", e);
//             // //        return Err(e);
//             // //    }
//             // //};       
//             // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;   
//             // //added 12/29/23
//             // //this is the parsing
//             // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
//             // let mut coinbase_sell_price = 0.0;
//             // let mut coinbase_buy_price = 0.0;   
//             // // Access the pricebooks array
//             // if let Some(pricebooks) = v["pricebooks"].as_array() {
//             //     // Iterate over each pricebook
//             //     for pricebook in pricebooks {
//             //         // Access the product_id, bids, and asks
//             //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
//             //         let bids = &pricebook["bids"][0];
//             //         let asks = &pricebook["asks"][0];       
//             //         // Access the price and size of the bids and asks
//             //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
//             //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
//             //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");      
//             //         println!("Product ID: {}", product_id);
//             //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
//             //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
//             //     }
//             // }
//             //manages any errors from line above
//             //let response_text = match response_text {
//             //    Ok(t) => t,
//             //    Err(e) => {
//             //        eprintln!("Failed to read response text: \n{}", e);
//             //        return;
//             //    }
//             //};
//             //prints the actual response
//             //println!("list accounts response\n{:?}", &response_text);
// 	//03/02/24 - added:
// 		let now = Utc::now();
// 		let time_stamp = now.timestamp().to_string();
// 		let method = "GET";
// 		let request_path = "/api/v3/brokerage/best_bid_ask";
// 		let body = "";
// 		let message = format!("{}{}{}{}", &time_stamp, 
// 			&method, &request_path, &body);
// 		type HmacSha256 = Hmac<Sha256>;
// 		fn sign(message: &str, coinbase_secret: &str) -> String {
// 			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
// 					.expect("HMAC can take key of any size");
// 			mac.update(message.as_bytes());
// 			let result = mac.finalize();
// 			let code_bytes = result.into_bytes();
// 			hex::encode(code_bytes)
// 		}
// 		let coinbase_signature = sign(&message, &coinbase_secret);
// 		let mut coinbase_buy_price_ask: Option<f64> = None;
// 		let mut attempts = 0;
// 		let mut success = false;
// 		loop {
// 			attempts +=1;
// 			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
// 			.header("CB-ACCESS-KEY", coinbase_api_key)
// 			.header("CB-ACCESS-SIGN", &coinbase_signature)
// 			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
// 			.build();
// 			match request {
// 				Ok(req) => {
// 					let response = client.execute(req).await;
// 					match response {
// 						Ok(resp) => {
// 							let response_text = resp.text().await;
// 							match response_text {
// 								Ok(text) => {
// 									match serde_json::from_str::<Value>(&text) {
// 										Ok(v) => {
// 											if let Some(pricebooks) = v["pricebooks"].as_array() {
// 												for pricebook in pricebooks {
// 													//let product_id = pricebook["product_id"].as_str();
// 													//let bids = &pricebook["bids"][0];
// 													let asks = &pricebook["asks"][0];
// 													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
// 													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
// 													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
// 														(/*Some(bid_str),*/ Some(ask_str)) => {
// 															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
// 																(/*Ok(bid_str),*/ Ok(ask_str)) => {
// 																	//coinbase_sell_price_bid = Some(bid_str);
// 																	coinbase_buy_price_ask = Some(ask_str);
// 																		success = true;
// 																},
// 																_ => {
// 																	log::error!("i20:  coinbase:  Failed to f64 parse JSON");
// 																	if attempts > 3 {
// 																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 																	}
// 																	continue ;
// 																}
// 															}
// 														},
// 														_ => {
// 															log::error!("i20:  coinbase:  Failed to get ask price");
// 															if attempts > 3 {
// 																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
// 																panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
// 															}
// 															continue ;
// 														}
// 													}
// 												}
// 											//03/02/24 - added else condition
// 											} else {
// 												log::error!("i20:  coinbase:  Failed to get pricebooks as array.");
// 												if attempts > 3 {
// 													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
// 												}
// 												continue;
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i20:  coinbase:  Failed to parse outer JSON as str.");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
// 											}
// 											continue ; // Continue to the next iteration if parsing fails
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i20:  coinbase:  Failed to get response text.");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue ; // Continue to the next iteration if getting response text fails
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i20:  coinbase:  Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue; // Continue to the next iteration if executing request fails
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i20:  coinbase:  Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue; // Continue to the next iteration if building request fails
// 				}
// 			}
// 			if success == true {
// 				break;
// 			}
// 		}
//             //02/09/24 - updated tokio. removed:  
//                 //delay_for(Duration::from_secs(3)).await;
//             //02/09/24 - updated tokio. added in its place:
//             println!("sol 10 coinbase bitstamp: 3 sec delay");
//             let when = tokio::time::Instant::now() + Duration::from_secs(3);
//             tokio::time::sleep_until(when).await;
//     //-------------------------Bitstamp---------------------------//
//                 //Bitstamp for some reason needs nonce to be 36 characters long. 
// 	//	nonce is basically a unique id that needs to be different every time you make a request. 
// 	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
// 	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
// 	//	and just make it a random 36 char string from it.
// 	//the exact same as the Coinbase signature. we'll see if it works
// 	//apparently it doesnt so I will code comment it out for now
// 	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 	//											.expect("HMAC can take key of any size");
// 	//	mac.update(bitstamp_message.as_bytes());
// 	//	let result = mac.finalize();
// 	//	let code_bytes = result.into_bytes();
// 	//	hex::encode(code_bytes)
// 	//}
// 	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
// 		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
// 			.expect("HMAC can take key of any size");
// 		mac.update(bitstamp_message.as_bytes());
// 		let result = mac.finalize();
// 		let code_bytes = result.into_bytes();
// 		hex::encode(code_bytes)
// 	}
// 	let content_type = "application/x-www-form-urlencoded";
// 	let payload_string = "offset=1";
// 	//if we needed content_type, it is here
// 	//let content_type = "application/json";
// 	//this is the bitstamp message IF we needed content_type
// 	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
// 	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// //--------------------Account-balances------------------------------------------//
// 	let the_uuid = Uuid::new_v4();
// 	let bitstamp_nonce = the_uuid.to_string();
// 	let bitstamp_timestamp = now.timestamp_millis().to_string();
// 	//let content_type = "application/x-www-form-urlencoded";
// 	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
// 			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
// 	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
// 	//03/02/24 - removed:
// 	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 	// 		.header("X-Auth-Signature", bitstamp_signature)
// 	// 		.header("X-Auth-Nonce", bitstamp_nonce)
// 	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
// 	// 		.header("X-Auth-Version", "v2")
// 	// 		//.header("Content-Type", content_type)
// 	// 		//.body(payload_string)
// 	// 		.build()
// 	// 		.expect("\ncould not build bitstamp_request");
// 	// 	let bitstamp_response = client.execute(bitstamp_request).await
// 	// 		.expect("Failed to execute Bitstamp request");
// 	// 	let bitstamp_response_text = bitstamp_response.text().await
// 	// 		.expect("Failed to turn response into text");
// 	// 	//probably dont need "bitstamp" once we transfer this to the actual function
// 	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
// 	//     .expect("Failed to parse JSON");
// 	// // Extract the bid and ask values
// 	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
// 	//     println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
// 	// 	println!("Bitstamp:\n{:?}", bitstamp_response_text);
// 	//03/02/24 - added:
// 		let mut success = false;
// 		let mut attempts = 0;
// 		let mut value_after: Option<f64> = None;
// 		while !success && attempts <=3 {
// 			attempts += 1;
// 			match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
// 				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
// 				.header("X-Auth-Signature", &bitstamp_signature)
// 				.header("X-Auth-Nonce", &bitstamp_nonce)
// 				.header("X-Auth-Timestamp", &bitstamp_timestamp)
// 				.header("X-Auth-Version", "v2")
// 				.build() {
// 				Ok(bitstamp_request) => {
// 					match client.execute(bitstamp_request).await {
// 						Ok(bitstamp_response) => {
// 							match bitstamp_response.text().await {
// 								Ok(bitstamp_response_text) => {
// 									match serde_json::from_str::<Value>(&bitstamp_response_text) {
// 										Ok(v) => {
// 											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
// 											let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
// 											match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
// 												(Some(bid_str), Some(ask_str)) => {
// 													match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
// 														(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
// 															// Place your calculations and updates here
// 															//coinbase calculations to buy
// 															let coinbase_taker_fee = 0.008;
// 															let fraction_of_wallet_im_using = 0.10; //aka 10 percent
// 															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
// 															let fee_for_purchase = total_spent*coinbase_taker_fee;
// 															let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
// 															*coinbase_wallet -= total_spent;
// 															let amount_of_sol = 
// 															money_going_to_sol_after_fees/coinbase_buy_price_ask
// 																							.expect(&format!("i20: coinbase_buy_price_ask is somehow Not Some. 
// 																							even though to get to this point it had to be Some. 
// 																							coinbase_buy_price_ask: {:?}
// 																							Honestly restart the program from the last saved state. 
// 																							The most likely error is a bit got flipped after the loop",
// 																							&coinbase_buy_price_ask));
// 															//bitstamp calculations for sell
// 															let bitstamp_taker_fee = 0.004;
// 															let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
// 															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
// 															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
// 															*bitstamp_wallet += money_from_sell_after_fees;
// 															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
// 															if let Some(mut value_after) = value_after {
// 																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
// 																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
// 																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
// 																//value_after = 56
// 																//coinbase = 57
// 																//bitstamp = 58
// 																//kraken = 59
// 																//gemini = 60
// 																//since this is coinbase and bitstamp being updated, I will update:
// 																//  56, 57, 58
// 																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
// 																let indices = [56, 57, 58];
// 																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
// 																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 																neural_network.update_input(&indices, &scaled_values).await;
// 															}
// 															//03/08/24 - removed:
// 															// //value_after = 56
// 															// //coinbase = 57
// 															// //bitstamp = 58
// 															// //kraken = 59
// 															// //gemini = 60
// 															// //since this is coinbase and bitstamp being updated, I will update:
// 															// //  56, 57, 58
// 															// let indices = [56, 57, 58];
// 															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
// 															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
// 															// neural_network.update_input(&indices, &scaled_values).await;
// 															success = true;
// 														},
// 														_ => {
// 															log::error!("i20: Failed to f64 parse bid or ask price");
// 															if attempts > 3 {
// 																panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 															}
// 															continue;
// 														}
// 													}
// 												},
// 												_ => {
// 													log::error!("i20: Failed to originally parse bid or ask price");
// 													if attempts > 3 {
// 														panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
// 													}
// 													continue;
// 												}
// 											}
// 										},
// 										Err(_) => {
// 											log::error!("i20: Failed to parse JSON");
// 											if attempts > 3 {
// 												panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
// 											}
// 											continue;
// 										}
// 									}
// 								},
// 								Err(_) => {
// 									log::error!("i20: failed to get response text");
// 									if attempts > 3 {
// 										panic!("Failed to get response text after 3 attempts");
// 									}
// 									continue;
// 								}
// 							}
// 						},
// 						Err(_) => {
// 							log::error!("i20: Failed to execute request");
// 							if attempts > 3 {
// 								panic!("Failed to execute request after 3 attempts");
// 							}
// 							continue;
// 						}
// 					}
// 				},
// 				Err(_) => {
// 					log::error!("i20: Failed to build request");
// 					if attempts > 3 {
// 						panic!("Failed to build request after 3 attempts");
// 					}
// 					continue;
// 				}
// 			}
// 		}
// 		match value_after {
// 			Some(value) => return Ok(value),
// 			None => {
// 				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
// 				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
// 			}
// 		}
// 			//03/02/24 - removed:
//             // //coinbase calculations
//             //     let coinbase_taker_fee = 0.008;
//             //     let total_spent = 0.03*(*coinbase_wallet);
//             //     let fee_for_purchase = total_spent*coinbase_taker_fee;
//             //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
//             //     //new state of coinbase wallet below
//             //     *coinbase_wallet -= total_spent;
//             //     let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
//             // //kraken calculations
//             //     //let kraken_taker_fee = 0.0026;        
//             //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
//             //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
//             //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
//             //     //*kraken_wallet += money_from_sell_after_fees;
//             //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             // //bitstamp calculations
//             //     let bitstamp_taker_fee = 0.004;
//             //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
//             //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
//             //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
//             //     *bitstamp_wallet += money_from_sell_after_fees;
//             // //this will count as value after
//             //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
//             //     //value_after = 56
//             //     //coinbase = 57
//             //     //bitstamp = 58
//             //     //kraken = 59
//             //     //gemini = 60
//             //     //since this is coinbase and kraken being updated, I will update:
//             //     //  56, 57, 59
//             //     let indices = [56, 57, 58];
//             //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
//             //     //01/24/24 - removed and added:
//             //         //neural_network.update_input(&indices, &new_values);
//             //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
//             //         //neural_network.update_input(&indices, &transformed_values).await;
//             //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
//             //         neural_network.update_input(&indices, &scaled_values).await;
//             //     return Ok(value_after)
//     }
//     //end removal
    //gemini has withdraw minimums of 10 dollars
    /*
    pub async fn s_i21_sol_1_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);




        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.01;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
    
                return Ok(value_after)

    }    

    pub async fn s_i22_sol_2_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build()?;
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
    
            let response = client.execute(request).await?;
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};
    
    
            let response_text = response.text().await?;
    
            //added 12/29/23
            //this is the parsing
            let v: Value = serde_json::from_str(&response_text)?;
            let mut coinbase_sell_price = 0.0;
            let mut coinbase_buy_price = 0.0;
    
            // Access the pricebooks array
            if let Some(pricebooks) = v["pricebooks"].as_array() {
                // Iterate over each pricebook
                for pricebook in pricebooks {
                    // Access the product_id, bids, and asks
                    let product_id = pricebook["product_id"].as_str().unwrap_or("");
                    let bids = &pricebook["bids"][0];
                    let asks = &pricebook["asks"][0];
            
                    // Access the price and size of the bids and asks
                    coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                    let bid_size = bids["size"].as_str().unwrap_or("size not found");
                    coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                    let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
                    println!("Product ID: {}", product_id);
                    //println!("Best bid: {} (size: {})", bid_price, bid_size);
                    //println!("Best ask: {} (size: {})", ask_price, ask_size);
                }
            }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.02;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                let coinbase_taker_fee = 0.008;
                let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
    
                return Ok(value_after)

    }
    */
    pub async fn s_i23_sol_3_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

		//03/02/24 - removed:
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);


        



		//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
	
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i23: gemini:  Failed to parse ask as f64: {}
                                                        response text: {}", e, &text),
													}
												},
												None => log::error!("i23: gemini:  Failed to get ask as string. text: {}", text),
											}
										},
										Err(e) => log::error!("i23: gemini:  Failed to parse JSON: {}
                                        response text: {}", e, &text),
									}
								},
								Err(e) => log::error!("i23: gemini:  Failed to turn response into text: {}", e),
							}
						},
						Err(e) => log::error!("i23: gemini:  Failed to execute Gemini request: {}", e),
					}
				},
				Err(e) => log::error!("i23: gemini:  Couldn't build gemini request: {}", e),
			}
            log::error!("10 sec wait for i23 error. current attempt #: {}", attempts);
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("i23: Failed after 3 attempts");
			}
		}

















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 3 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    

			//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    

		//03/02/24 - added:
			let mut attempts = 0;
			let mut coinbase_sell_price_bid: Option<f64> = None;
			//let coinbase_buy_price_ask: Option<f64>;
			let mut value_after: Option<f64> = None;
            //03/13/24 - removed:
			//let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {

						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														//let product_id = pricebook["product_id"].as_str();
														let bids = &pricebook["bids"][0];
														//let asks = &pricebook["asks"][0];
														let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
														//let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_sell_price_bid {
															Some(bid_str) => {
																match bid_str.parse::<f64>() {
																	Ok(bid_str) => {
																		coinbase_sell_price_bid = Some(bid_str);

	
																		// Place your calculations and updates here
																			let gemini_taker_fee = 0.004;
																			let fraction_of_wallet_im_using = 0.03; //aka 3 percent
																			let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																			let fee_for_purchase = total_spent*gemini_taker_fee;
																			let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																			*gemini_wallet -= total_spent;
	
																			let amount_of_sol = 
																			money_going_to_sol_after_fees/gemini_buy_ask
																											.expect(&format!("gemini_buy_ask is somehow Not Some. 
																											even though to get to this point it had to be Some. 
																											gemini_buy_ask: {:?}
																											Honestly restart the program from the last saved state. 
																											The most likely error is a bit got flipped after the loop",
																											&gemini_buy_ask));
	
																			//coinbase calculations for sell

																			let coinbase_taker_fee = 0.008;
																			let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																			let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*coinbase_wallet += money_from_sell_after_fees;
																			value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																			if let Some(mut value_after) = value_after {
                                                                                //03/10/24 - added for unscaling
																				let value_after_unscaled = value_after;
																				let gemini_wallet_unscaled = *gemini_wallet;
																				let coinbase_wallet_unscaled = *coinbase_wallet;

																				*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																				*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																				value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																				
				
																				//value_after = 56
																				//coinbase = 57
																				//bitstamp = 58
																				//kraken = 59
																				//gemini = 60
																				//since this is coinbase and gemini being updated, I will update:
																				//  56, 57, 60
																				//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																				let indices = [56, 57, 60];
																				let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																				//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				neural_network.update_input(&indices, &scaled_values).await;



                                                                                //03/10/24 - added for unscaling:
                                                                                value_after = value_after_unscaled;
                                                                                *gemini_wallet = gemini_wallet_unscaled;
                                                                                *coinbase_wallet = coinbase_wallet_unscaled;

                                                                                //03/13/24 - added:
                                                                                return Ok(value_after);
																			}
																			//03/08/24 - removed:
																			// //value_after = 56
																			// //coinbase = 57
																			// //bitstamp = 58
																			// //kraken = 59
																			// //gemini = 60
																			// //since this is coinbase and gemini being updated, I will update:
																			// //  56, 57, 60
																			// let indices = [56, 57, 60];
																			// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																			// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			// neural_network.update_input(&indices, &scaled_values).await;

                                                                            //03/13/24 - removed:
																			// success = true;
																	},
																	Err(e) => {
																		log::error!("i23: failed to parse JSON to f64. response text: {}
                                                                        erroR: {}", &text, e);
																		if attempts > 3 {
																			panic!("i23: Failed to parse JSON after 3 attempts. Response text: {}", &text);
																		}
                                                                        log::error!("10secwait");
                                                                        let when = tokio::time::Instant::now() +
                                                                            tokio::time::Duration::from_secs(10);
                                                                        tokio::time::sleep_until(when).await;
																		continue ;
																	}
																}
															},
															None => {
																log::error!("i23: Failed to get bid. response text: {} ", &text);
																if attempts > 3 {
																	panic!("i23: Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																}
                                                                log::error!("10secwait");
                                                                let when = tokio::time::Instant::now() +
                                                                    tokio::time::Duration::from_secs(10);
                                                                tokio::time::sleep_until(when).await;
																continue ;
															}
														}
													}
												}
											},
											Err(e) => {
												log::error!("i23: failed to parse JSON. response text: {}
                                                error: {}", &text, e);
												if attempts > 3 {
													panic!("i23: Failed to parse JSON after 3 attempts. Response text: {}", text);
												}
                                                log::error!("10secwait");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue ; // Continue to the next iteration if parsing fails
											}
										}
									},
									Err(e) => {
										log::error!("i23: failed to get response text. error: {}", e);
										if attempts > 3 {
											panic!("i23: Failed to get response text after 3 attempts");
										}
                                        log::error!("10secwait");
                                        let when = tokio::time::Instant::now() +
                                            tokio::time::Duration::from_secs(10);
                                        tokio::time::sleep_until(when).await;
										continue ; // Continue to the next iteration if getting response text fails
									}
								}
							},
							Err(e) => {
								log::error!("i23: Failed to execute request. error: {}", e);
								if attempts > 3 {
									panic!("i23: Failed to execute request after 3 attempts");
								}
                                log::error!("10secwait");
                                let when = tokio::time::Instant::now() +
                                    tokio::time::Duration::from_secs(10);
                                tokio::time::sleep_until(when).await;
								continue; // Continue to the next iteration if executing request fails
							}
						}
					},
					Err(e) => {
						log::error!("i23: Failed to build request. error: {}", e);
						if attempts > 3 {
							panic!("i23: Failed to build request after 3 attempts");
						}
                        log::error!("10secwait");
                        let when = tokio::time::Instant::now() +
                            tokio::time::Duration::from_secs(10);
                        tokio::time::sleep_until(when).await;
						continue; // Continue to the next iteration if building request fails
					}
				}
                //03/13/24 - removed:
				// if success == true {
				// 	break;
				// }
			}
            //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
			// 	}
			// }















    
    
    
    
    
    
    
    
			//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and gemini being updated, I will update:
            //     //  56, 57, 60
            //     let indices = [56, 57, 60];
            //     let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i24_sol_4_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

		//03/02/24 - removed:
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);


        



		//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
	
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i24: gemini:  Failed to parse ask as f64: {}
                                                        response text: {}", e, &text),
													}
												},
												None => log::error!("i24: gemini:  Failed to get ask as string. text: {}", text),
											}
										},
										Err(e) => log::error!("i24: gemini:  Failed to parse JSON: {}
                                        response text: {}", e, &text),
									}
								},
								Err(e) => log::error!("i24: gemini:  Failed to turn response into text: {}", e),
							}
						},
						Err(e) => log::error!("i24: gemini:  Failed to execute Gemini request: {}", e),
					}
				},
				Err(e) => log::error!("i24: gemini:  Couldn't build gemini request: {}", e),
			}
            log::error!("10 sec wait for i24 error. current attempt #: {}", attempts);
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("i24: Failed after 3 attempts");
			}
		}

















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 4 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    

			//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    

		//03/02/24 - added:
			let mut attempts = 0;
			let mut coinbase_sell_price_bid: Option<f64> = None;
			//let coinbase_buy_price_ask: Option<f64>;
			let mut value_after: Option<f64> = None;
            //03/13/24 - removed:
			//let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {

						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														//let product_id = pricebook["product_id"].as_str();
														let bids = &pricebook["bids"][0];
														//let asks = &pricebook["asks"][0];
														let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
														//let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_sell_price_bid {
															Some(bid_str) => {
																match bid_str.parse::<f64>() {
																	Ok(bid_str) => {
																		coinbase_sell_price_bid = Some(bid_str);

	
																		// Place your calculations and updates here
																			let gemini_taker_fee = 0.004;
																			let fraction_of_wallet_im_using = 0.04; //aka 4 percent
																			let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																			let fee_for_purchase = total_spent*gemini_taker_fee;
																			let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																			*gemini_wallet -= total_spent;
	
																			let amount_of_sol = 
																			money_going_to_sol_after_fees/gemini_buy_ask
																											.expect(&format!("gemini_buy_ask is somehow Not Some. 
																											even though to get to this point it had to be Some. 
																											gemini_buy_ask: {:?}
																											Honestly restart the program from the last saved state. 
																											The most likely error is a bit got flipped after the loop",
																											&gemini_buy_ask));
	
																			//coinbase calculations for sell

																			let coinbase_taker_fee = 0.008;
																			let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																			let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*coinbase_wallet += money_from_sell_after_fees;
																			value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																			if let Some(mut value_after) = value_after {
                                                                                //03/10/24 - added for unscaling
																				let value_after_unscaled = value_after;
																				let gemini_wallet_unscaled = *gemini_wallet;
																				let coinbase_wallet_unscaled = *coinbase_wallet;

																				*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																				*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																				value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																				
				
																				//value_after = 56
																				//coinbase = 57
																				//bitstamp = 58
																				//kraken = 59
																				//gemini = 60
																				//since this is coinbase and gemini being updated, I will update:
																				//  56, 57, 60
																				//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																				let indices = [56, 57, 60];
																				let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																				//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				neural_network.update_input(&indices, &scaled_values).await;



                                                                                //03/10/24 - added for unscaling:
                                                                                value_after = value_after_unscaled;
                                                                                *gemini_wallet = gemini_wallet_unscaled;
                                                                                *coinbase_wallet = coinbase_wallet_unscaled;

                                                                                //03/13/24 - added:
                                                                                return Ok(value_after);
																			}
																			//03/08/24 - removed:
																			// //value_after = 56
																			// //coinbase = 57
																			// //bitstamp = 58
																			// //kraken = 59
																			// //gemini = 60
																			// //since this is coinbase and gemini being updated, I will update:
																			// //  56, 57, 60
																			// let indices = [56, 57, 60];
																			// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																			// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			// neural_network.update_input(&indices, &scaled_values).await;

                                                                            //03/13/24 - removed:
																			// success = true;
																	},
																	Err(e) => {
																		log::error!("i24: failed to parse JSON to f64. response text: {}
                                                                        erroR: {}", &text, e);
																		if attempts > 3 {
																			panic!("i24: Failed to parse JSON after 3 attempts. Response text: {}", &text);
																		}
                                                                        log::error!("10secwait");
                                                                        let when = tokio::time::Instant::now() +
                                                                            tokio::time::Duration::from_secs(10);
                                                                        tokio::time::sleep_until(when).await;
																		continue ;
																	}
																}
															},
															None => {
																log::error!("i24: Failed to get bid. response text: {} ", &text);
																if attempts > 3 {
																	panic!("i24: Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																}
                                                                log::error!("10secwait");
                                                                let when = tokio::time::Instant::now() +
                                                                    tokio::time::Duration::from_secs(10);
                                                                tokio::time::sleep_until(when).await;
																continue ;
															}
														}
													}
												}
											},
											Err(e) => {
												log::error!("i24: failed to parse JSON. response text: {}
                                                error: {}", &text, e);
												if attempts > 3 {
													panic!("i24: Failed to parse JSON after 3 attempts. Response text: {}", text);
												}
                                                log::error!("10secwait");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue ; // Continue to the next iteration if parsing fails
											}
										}
									},
									Err(e) => {
										log::error!("i24: failed to get response text. error: {}", e);
										if attempts > 3 {
											panic!("i24: Failed to get response text after 3 attempts");
										}
                                        log::error!("10secwait");
                                        let when = tokio::time::Instant::now() +
                                            tokio::time::Duration::from_secs(10);
                                        tokio::time::sleep_until(when).await;
										continue ; // Continue to the next iteration if getting response text fails
									}
								}
							},
							Err(e) => {
								log::error!("i24: Failed to execute request. error: {}", e);
								if attempts > 3 {
									panic!("i24: Failed to execute request after 3 attempts");
								}
                                log::error!("10secwait");
                                let when = tokio::time::Instant::now() +
                                    tokio::time::Duration::from_secs(10);
                                tokio::time::sleep_until(when).await;
								continue; // Continue to the next iteration if executing request fails
							}
						}
					},
					Err(e) => {
						log::error!("i24: Failed to build request. error: {}", e);
						if attempts > 3 {
							panic!("i24: Failed to build request after 3 attempts");
						}
                        log::error!("10secwait");
                        let when = tokio::time::Instant::now() +
                            tokio::time::Duration::from_secs(10);
                        tokio::time::sleep_until(when).await;
						continue; // Continue to the next iteration if building request fails
					}
				}
                //03/13/24 - removed:
				// if success == true {
				// 	break;
				// }
			}
            //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
			// 	}
			// }















    
    
    
    
    
    
    
    
			//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and gemini being updated, I will update:
            //     //  56, 57, 60
            //     let indices = [56, 57, 60];
            //     let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i25_sol_5_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

		//03/02/24 - removed:
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);


        



		//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
	
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i25: gemini:  Failed to parse ask as f64: {}
                                                        response text: {}", e, &text),
													}
												},
												None => log::error!("i25: gemini:  Failed to get ask as string. text: {}", text),
											}
										},
										Err(e) => log::error!("i25: gemini:  Failed to parse JSON: {}
                                        response text: {}", e, &text),
									}
								},
								Err(e) => log::error!("i25: gemini:  Failed to turn response into text: {}", e),
							}
						},
						Err(e) => log::error!("i25: gemini:  Failed to execute Gemini request: {}", e),
					}
				},
				Err(e) => log::error!("i25: gemini:  Couldn't build gemini request: {}", e),
			}
            log::error!("10 sec wait for i25 error. current attempt #: {}", attempts);
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("i25: Failed after 3 attempts");
			}
		}

















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 5 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    

			//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    

		//03/02/24 - added:
			let mut attempts = 0;
			let mut coinbase_sell_price_bid: Option<f64> = None;
			//let coinbase_buy_price_ask: Option<f64>;
			let mut value_after: Option<f64> = None;
            //03/13/24 - removed:
			//let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {

						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														//let product_id = pricebook["product_id"].as_str();
														let bids = &pricebook["bids"][0];
														//let asks = &pricebook["asks"][0];
														let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
														//let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_sell_price_bid {
															Some(bid_str) => {
																match bid_str.parse::<f64>() {
																	Ok(bid_str) => {
																		coinbase_sell_price_bid = Some(bid_str);

	
																		// Place your calculations and updates here
																			let gemini_taker_fee = 0.004;
																			let fraction_of_wallet_im_using = 0.05; //aka 5 percent
																			let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																			let fee_for_purchase = total_spent*gemini_taker_fee;
																			let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																			*gemini_wallet -= total_spent;
	
																			let amount_of_sol = 
																			money_going_to_sol_after_fees/gemini_buy_ask
																											.expect(&format!("gemini_buy_ask is somehow Not Some. 
																											even though to get to this point it had to be Some. 
																											gemini_buy_ask: {:?}
																											Honestly restart the program from the last saved state. 
																											The most likely error is a bit got flipped after the loop",
																											&gemini_buy_ask));
	
																			//coinbase calculations for sell

																			let coinbase_taker_fee = 0.008;
																			let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																			let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*coinbase_wallet += money_from_sell_after_fees;
																			value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																			if let Some(mut value_after) = value_after {
                                                                                //03/10/24 - added for unscaling
																				let value_after_unscaled = value_after;
																				let gemini_wallet_unscaled = *gemini_wallet;
																				let coinbase_wallet_unscaled = *coinbase_wallet;

																				*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																				*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																				value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																				
				
																				//value_after = 56
																				//coinbase = 57
																				//bitstamp = 58
																				//kraken = 59
																				//gemini = 60
																				//since this is coinbase and gemini being updated, I will update:
																				//  56, 57, 60
																				//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																				let indices = [56, 57, 60];
																				let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																				//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				neural_network.update_input(&indices, &scaled_values).await;



                                                                                //03/10/24 - added for unscaling:
                                                                                value_after = value_after_unscaled;
                                                                                *gemini_wallet = gemini_wallet_unscaled;
                                                                                *coinbase_wallet = coinbase_wallet_unscaled;

                                                                                //03/13/24 - added:
                                                                                return Ok(value_after);
																			}
																			//03/08/24 - removed:
																			// //value_after = 56
																			// //coinbase = 57
																			// //bitstamp = 58
																			// //kraken = 59
																			// //gemini = 60
																			// //since this is coinbase and gemini being updated, I will update:
																			// //  56, 57, 60
																			// let indices = [56, 57, 60];
																			// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																			// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			// neural_network.update_input(&indices, &scaled_values).await;

                                                                            //03/13/24 - removed:
																			// success = true;
																	},
																	Err(e) => {
																		log::error!("i25: failed to parse JSON to f64. response text: {}
                                                                        erroR: {}", &text, e);
																		if attempts > 3 {
																			panic!("i25: Failed to parse JSON after 3 attempts. Response text: {}", &text);
																		}
                                                                        log::error!("10secwait");
                                                                        let when = tokio::time::Instant::now() +
                                                                            tokio::time::Duration::from_secs(10);
                                                                        tokio::time::sleep_until(when).await;
																		continue ;
																	}
																}
															},
															None => {
																log::error!("i25: Failed to get bid. response text: {} ", &text);
																if attempts > 3 {
																	panic!("i25: Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																}
                                                                log::error!("10secwait");
                                                                let when = tokio::time::Instant::now() +
                                                                    tokio::time::Duration::from_secs(10);
                                                                tokio::time::sleep_until(when).await;
																continue ;
															}
														}
													}
												}
											},
											Err(e) => {
												log::error!("i25: failed to parse JSON. response text: {}
                                                error: {}", &text, e);
												if attempts > 3 {
													panic!("i25: Failed to parse JSON after 3 attempts. Response text: {}", text);
												}
                                                log::error!("10secwait");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue ; // Continue to the next iteration if parsing fails
											}
										}
									},
									Err(e) => {
										log::error!("i25: failed to get response text. error: {}", e);
										if attempts > 3 {
											panic!("i25: Failed to get response text after 3 attempts");
										}
                                        log::error!("10secwait");
                                        let when = tokio::time::Instant::now() +
                                            tokio::time::Duration::from_secs(10);
                                        tokio::time::sleep_until(when).await;
										continue ; // Continue to the next iteration if getting response text fails
									}
								}
							},
							Err(e) => {
								log::error!("i25: Failed to execute request. error: {}", e);
								if attempts > 3 {
									panic!("i25: Failed to execute request after 3 attempts");
								}
                                log::error!("10secwait");
                                let when = tokio::time::Instant::now() +
                                    tokio::time::Duration::from_secs(10);
                                tokio::time::sleep_until(when).await;
								continue; // Continue to the next iteration if executing request fails
							}
						}
					},
					Err(e) => {
						log::error!("i25: Failed to build request. error: {}", e);
						if attempts > 3 {
							panic!("i25: Failed to build request after 3 attempts");
						}
                        log::error!("10secwait");
                        let when = tokio::time::Instant::now() +
                            tokio::time::Duration::from_secs(10);
                        tokio::time::sleep_until(when).await;
						continue; // Continue to the next iteration if building request fails
					}
				}
                //03/13/24 - removed:
				// if success == true {
				// 	break;
				// }
			}
            //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
			// 	}
			// }















    
    
    
    
    
    
    
    
			//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and gemini being updated, I will update:
            //     //  56, 57, 60
            //     let indices = [56, 57, 60];
            //     let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i26_sol_6_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

		//03/02/24 - removed:
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);


        



		//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
	
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i26: gemini:  Failed to parse ask as f64: {}
                                                        response text: {}", e, &text),
													}
												},
												None => log::error!("i26: gemini:  Failed to get ask as string. text: {}", text),
											}
										},
										Err(e) => log::error!("i26: gemini:  Failed to parse JSON: {}
                                        response text: {}", e, &text),
									}
								},
								Err(e) => log::error!("i26: gemini:  Failed to turn response into text: {}", e),
							}
						},
						Err(e) => log::error!("i26: gemini:  Failed to execute Gemini request: {}", e),
					}
				},
				Err(e) => log::error!("i26: gemini:  Couldn't build gemini request: {}", e),
			}
            log::error!("10 sec wait for i26 error. current attempt #: {}", attempts);
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("i26: Failed after 3 attempts");
			}
		}

















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 6 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    

			//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    

		//03/02/24 - added:
			let mut attempts = 0;
			let mut coinbase_sell_price_bid: Option<f64> = None;
			//let coinbase_buy_price_ask: Option<f64>;
			let mut value_after: Option<f64> = None;
            //03/13/24 - removed:
			//let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {

						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														//let product_id = pricebook["product_id"].as_str();
														let bids = &pricebook["bids"][0];
														//let asks = &pricebook["asks"][0];
														let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
														//let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_sell_price_bid {
															Some(bid_str) => {
																match bid_str.parse::<f64>() {
																	Ok(bid_str) => {
																		coinbase_sell_price_bid = Some(bid_str);

	
																		// Place your calculations and updates here
																			let gemini_taker_fee = 0.004;
																			let fraction_of_wallet_im_using = 0.06; //aka 6 percent
																			let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																			let fee_for_purchase = total_spent*gemini_taker_fee;
																			let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																			*gemini_wallet -= total_spent;
	
																			let amount_of_sol = 
																			money_going_to_sol_after_fees/gemini_buy_ask
																											.expect(&format!("gemini_buy_ask is somehow Not Some. 
																											even though to get to this point it had to be Some. 
																											gemini_buy_ask: {:?}
																											Honestly restart the program from the last saved state. 
																											The most likely error is a bit got flipped after the loop",
																											&gemini_buy_ask));
	
																			//coinbase calculations for sell

																			let coinbase_taker_fee = 0.008;
																			let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																			let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*coinbase_wallet += money_from_sell_after_fees;
																			value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																			if let Some(mut value_after) = value_after {
                                                                                //03/10/24 - added for unscaling
																				let value_after_unscaled = value_after;
																				let gemini_wallet_unscaled = *gemini_wallet;
																				let coinbase_wallet_unscaled = *coinbase_wallet;

																				*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																				*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																				value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																				
				
																				//value_after = 56
																				//coinbase = 57
																				//bitstamp = 58
																				//kraken = 59
																				//gemini = 60
																				//since this is coinbase and gemini being updated, I will update:
																				//  56, 57, 60
																				//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																				let indices = [56, 57, 60];
																				let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																				//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				neural_network.update_input(&indices, &scaled_values).await;



                                                                                //03/10/24 - added for unscaling:
                                                                                value_after = value_after_unscaled;
                                                                                *gemini_wallet = gemini_wallet_unscaled;
                                                                                *coinbase_wallet = coinbase_wallet_unscaled;

                                                                                //03/13/24 - added:
                                                                                return Ok(value_after);
																			}
																			//03/08/24 - removed:
																			// //value_after = 56
																			// //coinbase = 57
																			// //bitstamp = 58
																			// //kraken = 59
																			// //gemini = 60
																			// //since this is coinbase and gemini being updated, I will update:
																			// //  56, 57, 60
																			// let indices = [56, 57, 60];
																			// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																			// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			// neural_network.update_input(&indices, &scaled_values).await;

                                                                            //03/13/24 - removed:
																			// success = true;
																	},
																	Err(e) => {
																		log::error!("i26: failed to parse JSON to f64. response text: {}
                                                                        erroR: {}", &text, e);
																		if attempts > 3 {
																			panic!("i26: Failed to parse JSON after 3 attempts. Response text: {}", &text);
																		}
                                                                        log::error!("10secwait");
                                                                        let when = tokio::time::Instant::now() +
                                                                            tokio::time::Duration::from_secs(10);
                                                                        tokio::time::sleep_until(when).await;
																		continue ;
																	}
																}
															},
															None => {
																log::error!("i26: Failed to get bid. response text: {} ", &text);
																if attempts > 3 {
																	panic!("i26: Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																}
                                                                log::error!("10secwait");
                                                                let when = tokio::time::Instant::now() +
                                                                    tokio::time::Duration::from_secs(10);
                                                                tokio::time::sleep_until(when).await;
																continue ;
															}
														}
													}
												}
											},
											Err(e) => {
												log::error!("i26: failed to parse JSON. response text: {}
                                                error: {}", &text, e);
												if attempts > 3 {
													panic!("i26: Failed to parse JSON after 3 attempts. Response text: {}", text);
												}
                                                log::error!("10secwait");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue ; // Continue to the next iteration if parsing fails
											}
										}
									},
									Err(e) => {
										log::error!("i26: failed to get response text. error: {}", e);
										if attempts > 3 {
											panic!("i26: Failed to get response text after 3 attempts");
										}
                                        log::error!("10secwait");
                                        let when = tokio::time::Instant::now() +
                                            tokio::time::Duration::from_secs(10);
                                        tokio::time::sleep_until(when).await;
										continue ; // Continue to the next iteration if getting response text fails
									}
								}
							},
							Err(e) => {
								log::error!("i26: Failed to execute request. error: {}", e);
								if attempts > 3 {
									panic!("i26: Failed to execute request after 3 attempts");
								}
                                log::error!("10secwait");
                                let when = tokio::time::Instant::now() +
                                    tokio::time::Duration::from_secs(10);
                                tokio::time::sleep_until(when).await;
								continue; // Continue to the next iteration if executing request fails
							}
						}
					},
					Err(e) => {
						log::error!("i26: Failed to build request. error: {}", e);
						if attempts > 3 {
							panic!("i26: Failed to build request after 3 attempts");
						}
                        log::error!("10secwait");
                        let when = tokio::time::Instant::now() +
                            tokio::time::Duration::from_secs(10);
                        tokio::time::sleep_until(when).await;
						continue; // Continue to the next iteration if building request fails
					}
				}
                //03/13/24 - removed:
				// if success == true {
				// 	break;
				// }
			}
            //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
			// 	}
			// }















    
    
    
    
    
    
    
    
			//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and gemini being updated, I will update:
            //     //  56, 57, 60
            //     let indices = [56, 57, 60];
            //     let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i27_sol_7_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

		//03/02/24 - removed:
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);


        



		//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
	
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i27: gemini:  Failed to parse ask as f64: {}
                                                        response text: {}", e, &text),
													}
												},
												None => log::error!("i27: gemini:  Failed to get ask as string. text: {}", text),
											}
										},
										Err(e) => log::error!("i27: gemini:  Failed to parse JSON: {}
                                        response text: {}", e, &text),
									}
								},
								Err(e) => log::error!("i27: gemini:  Failed to turn response into text: {}", e),
							}
						},
						Err(e) => log::error!("i27: gemini:  Failed to execute Gemini request: {}", e),
					}
				},
				Err(e) => log::error!("i27: gemini:  Couldn't build gemini request: {}", e),
			}
            log::error!("1 sec wait for i27 error. current attempt #: {}", attempts);
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(1);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("i27: Failed after 3 attempts");
			}
		}

















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 7 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    

			//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    

		//03/02/24 - added:
			let mut attempts = 0;
			let mut coinbase_sell_price_bid: Option<f64> = None;
			//let coinbase_buy_price_ask: Option<f64>;
			let mut value_after: Option<f64> = None;
            //03/13/24 - removed:
			//let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {

						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														//let product_id = pricebook["product_id"].as_str();
														let bids = &pricebook["bids"][0];
														//let asks = &pricebook["asks"][0];
														let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
														//let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_sell_price_bid {
															Some(bid_str) => {
																match bid_str.parse::<f64>() {
																	Ok(bid_str) => {
																		coinbase_sell_price_bid = Some(bid_str);

	
																		// Place your calculations and updates here
																			let gemini_taker_fee = 0.004;
																			let fraction_of_wallet_im_using = 0.07; //aka 7 percent
																			let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																			let fee_for_purchase = total_spent*gemini_taker_fee;
																			let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																			*gemini_wallet -= total_spent;
	
																			let amount_of_sol = 
																			money_going_to_sol_after_fees/gemini_buy_ask
																											.expect(&format!("gemini_buy_ask is somehow Not Some. 
																											even though to get to this point it had to be Some. 
																											gemini_buy_ask: {:?}
																											Honestly restart the program from the last saved state. 
																											The most likely error is a bit got flipped after the loop",
																											&gemini_buy_ask));
	
																			//coinbase calculations for sell

																			let coinbase_taker_fee = 0.008;
																			let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																			let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*coinbase_wallet += money_from_sell_after_fees;
																			value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																			if let Some(mut value_after) = value_after {
                                                                                //03/10/24 - added for unscaling
																				let value_after_unscaled = value_after;
																				let gemini_wallet_unscaled = *gemini_wallet;
																				let coinbase_wallet_unscaled = *coinbase_wallet;

																				*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																				*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																				value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																				
				
																				//value_after = 56
																				//coinbase = 57
																				//bitstamp = 58
																				//kraken = 59
																				//gemini = 60
																				//since this is coinbase and gemini being updated, I will update:
																				//  56, 57, 60
																				//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																				let indices = [56, 57, 60];
																				let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																				//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				neural_network.update_input(&indices, &scaled_values).await;



                                                                                //03/10/24 - added for unscaling:
                                                                                value_after = value_after_unscaled;
                                                                                *gemini_wallet = gemini_wallet_unscaled;
                                                                                *coinbase_wallet = coinbase_wallet_unscaled;

                                                                                //03/13/24 - added:
                                                                                return Ok(value_after);
																			}
																			//03/08/24 - removed:
																			// //value_after = 56
																			// //coinbase = 57
																			// //bitstamp = 58
																			// //kraken = 59
																			// //gemini = 60
																			// //since this is coinbase and gemini being updated, I will update:
																			// //  56, 57, 60
																			// let indices = [56, 57, 60];
																			// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																			// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			// neural_network.update_input(&indices, &scaled_values).await;

                                                                            //03/13/24 - removed:
																			// success = true;
																	},
																	Err(e) => {
																		log::error!("i27: failed to parse JSON to f64. response text: {}
                                                                        erroR: {}", &text, e);
																		if attempts > 3 {
																			panic!("i27: Failed to parse JSON after 3 attempts. Response text: {}", &text);
																		}
                                                                        log::error!("10secwait");
                                                                        let when = tokio::time::Instant::now() +
                                                                            tokio::time::Duration::from_secs(10);
                                                                        tokio::time::sleep_until(when).await;
																		continue ;
																	}
																}
															},
															None => {
																log::error!("i27: Failed to get bid. response text: {} ", &text);
																if attempts > 3 {
																	panic!("i27: Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																}
                                                                log::error!("10secwait");
                                                                let when = tokio::time::Instant::now() +
                                                                    tokio::time::Duration::from_secs(10);
                                                                tokio::time::sleep_until(when).await;
																continue ;
															}
														}
													}
												}
											},
											Err(e) => {
												log::error!("i27: failed to parse JSON. response text: {}
                                                error: {}", &text, e);
												if attempts > 3 {
													panic!("i27: Failed to parse JSON after 3 attempts. Response text: {}", text);
												}
                                                log::error!("10secwait");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue ; // Continue to the next iteration if parsing fails
											}
										}
									},
									Err(e) => {
										log::error!("i27: failed to get response text. error: {}", e);
										if attempts > 3 {
											panic!("i27: Failed to get response text after 3 attempts");
										}
                                        log::error!("10secwait");
                                        let when = tokio::time::Instant::now() +
                                            tokio::time::Duration::from_secs(10);
                                        tokio::time::sleep_until(when).await;
										continue ; // Continue to the next iteration if getting response text fails
									}
								}
							},
							Err(e) => {
								log::error!("i27: Failed to execute request. error: {}", e);
								if attempts > 3 {
									panic!("i27: Failed to execute request after 3 attempts");
								}
                                log::error!("10secwait");
                                let when = tokio::time::Instant::now() +
                                    tokio::time::Duration::from_secs(10);
                                tokio::time::sleep_until(when).await;
								continue; // Continue to the next iteration if executing request fails
							}
						}
					},
					Err(e) => {
						log::error!("i27: Failed to build request. error: {}", e);
						if attempts > 3 {
							panic!("i27: Failed to build request after 3 attempts");
						}
                        log::error!("10secwait");
                        let when = tokio::time::Instant::now() +
                            tokio::time::Duration::from_secs(10);
                        tokio::time::sleep_until(when).await;
						continue; // Continue to the next iteration if building request fails
					}
				}
                //03/13/24 - removed:
				// if success == true {
				// 	break;
				// }
			}
            //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
			// 	}
			// }















    
    
    
    
    
    
    
    
			//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and gemini being updated, I will update:
            //     //  56, 57, 60
            //     let indices = [56, 57, 60];
            //     let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i28_sol_8_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

		//03/02/24 - removed:
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);


        



		//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
	
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i28: gemini:  Failed to parse ask as f64: {}
                                                        response text: {}", e, &text),
													}
												},
												None => log::error!("i28: gemini:  Failed to get ask as string. text: {}", text),
											}
										},
										Err(e) => log::error!("i28: gemini:  Failed to parse JSON: {}
                                        response text: {}", e, &text),
									}
								},
								Err(e) => log::error!("i28: gemini:  Failed to turn response into text: {}", e),
							}
						},
						Err(e) => log::error!("i28: gemini:  Failed to execute Gemini request: {}", e),
					}
				},
				Err(e) => log::error!("i28: gemini:  Couldn't build gemini request: {}", e),
			}
            log::error!("10 sec wait for i28 error. current attempt #: {}", attempts);
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("i28: Failed after 3 attempts");
			}
		}

















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 8 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    

			//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    

		//03/02/24 - added:
			let mut attempts = 0;
			let mut coinbase_sell_price_bid: Option<f64> = None;
			//let coinbase_buy_price_ask: Option<f64>;
			let mut value_after: Option<f64> = None;
            //03/13/24 - removed:
			//let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {

						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														//let product_id = pricebook["product_id"].as_str();
														let bids = &pricebook["bids"][0];
														//let asks = &pricebook["asks"][0];
														let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
														//let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_sell_price_bid {
															Some(bid_str) => {
																match bid_str.parse::<f64>() {
																	Ok(bid_str) => {
																		coinbase_sell_price_bid = Some(bid_str);

	
																		// Place your calculations and updates here
																			let gemini_taker_fee = 0.004;
																			let fraction_of_wallet_im_using = 0.08; //aka 8 percent
																			let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																			let fee_for_purchase = total_spent*gemini_taker_fee;
																			let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																			*gemini_wallet -= total_spent;
	
																			let amount_of_sol = 
																			money_going_to_sol_after_fees/gemini_buy_ask
																											.expect(&format!("gemini_buy_ask is somehow Not Some. 
																											even though to get to this point it had to be Some. 
																											gemini_buy_ask: {:?}
																											Honestly restart the program from the last saved state. 
																											The most likely error is a bit got flipped after the loop",
																											&gemini_buy_ask));
	
																			//coinbase calculations for sell

																			let coinbase_taker_fee = 0.008;
																			let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																			let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*coinbase_wallet += money_from_sell_after_fees;
																			value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																			if let Some(mut value_after) = value_after {
                                                                                //03/10/24 - added for unscaling
																				let value_after_unscaled = value_after;
																				let gemini_wallet_unscaled = *gemini_wallet;
																				let coinbase_wallet_unscaled = *coinbase_wallet;

																				*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																				*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																				value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																				
				
																				//value_after = 56
																				//coinbase = 57
																				//bitstamp = 58
																				//kraken = 59
																				//gemini = 60
																				//since this is coinbase and gemini being updated, I will update:
																				//  56, 57, 60
																				//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																				let indices = [56, 57, 60];
																				let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																				//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				neural_network.update_input(&indices, &scaled_values).await;



                                                                                //03/10/24 - added for unscaling:
                                                                                value_after = value_after_unscaled;
                                                                                *gemini_wallet = gemini_wallet_unscaled;
                                                                                *coinbase_wallet = coinbase_wallet_unscaled;

                                                                                //03/13/24 - added:
                                                                                return Ok(value_after);
																			}
																			//03/08/24 - removed:
																			// //value_after = 56
																			// //coinbase = 57
																			// //bitstamp = 58
																			// //kraken = 59
																			// //gemini = 60
																			// //since this is coinbase and gemini being updated, I will update:
																			// //  56, 57, 60
																			// let indices = [56, 57, 60];
																			// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																			// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			// neural_network.update_input(&indices, &scaled_values).await;

                                                                            //03/13/24 - removed:
																			// success = true;
																	},
																	Err(e) => {
																		log::error!("i28: failed to parse JSON to f64. response text: {}
                                                                        erroR: {}", &text, e);
																		if attempts > 3 {
																			panic!("i28: Failed to parse JSON after 3 attempts. Response text: {}", &text);
																		}
                                                                        log::error!("10secwait");
                                                                        let when = tokio::time::Instant::now() +
                                                                            tokio::time::Duration::from_secs(10);
                                                                        tokio::time::sleep_until(when).await;
																		continue ;
																	}
																}
															},
															None => {
																log::error!("i28: Failed to get bid. response text: {} ", &text);
																if attempts > 3 {
																	panic!("i28: Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																}
                                                                log::error!("10secwait");
                                                                let when = tokio::time::Instant::now() +
                                                                    tokio::time::Duration::from_secs(10);
                                                                tokio::time::sleep_until(when).await;
																continue ;
															}
														}
													}
												}
											},
											Err(e) => {
												log::error!("i28: failed to parse JSON. response text: {}
                                                error: {}", &text, e);
												if attempts > 3 {
													panic!("i28: Failed to parse JSON after 3 attempts. Response text: {}", text);
												}
                                                log::error!("10secwait");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue ; // Continue to the next iteration if parsing fails
											}
										}
									},
									Err(e) => {
										log::error!("i28: failed to get response text. error: {}", e);
										if attempts > 3 {
											panic!("i28: Failed to get response text after 3 attempts");
										}
                                        log::error!("10secwait");
                                        let when = tokio::time::Instant::now() +
                                            tokio::time::Duration::from_secs(10);
                                        tokio::time::sleep_until(when).await;
										continue ; // Continue to the next iteration if getting response text fails
									}
								}
							},
							Err(e) => {
								log::error!("i28: Failed to execute request. error: {}", e);
								if attempts > 3 {
									panic!("i28: Failed to execute request after 3 attempts");
								}
                                log::error!("10secwait");
                                let when = tokio::time::Instant::now() +
                                    tokio::time::Duration::from_secs(10);
                                tokio::time::sleep_until(when).await;
								continue; // Continue to the next iteration if executing request fails
							}
						}
					},
					Err(e) => {
						log::error!("i28: Failed to build request. error: {}", e);
						if attempts > 3 {
							panic!("i28: Failed to build request after 3 attempts");
						}
                        log::error!("10secwait");
                        let when = tokio::time::Instant::now() +
                            tokio::time::Duration::from_secs(10);
                        tokio::time::sleep_until(when).await;
						continue; // Continue to the next iteration if building request fails
					}
				}
                //03/13/24 - removed:
				// if success == true {
				// 	break;
				// }
			}
            //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
			// 	}
			// }















    
    
    
    
    
    
    
    
			//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and gemini being updated, I will update:
            //     //  56, 57, 60
            //     let indices = [56, 57, 60];
            //     let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i29_sol_9_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

		//03/02/24 - removed:
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);


        



		//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
	
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i29: gemini:  Failed to parse ask as f64: {}
                                                        response text: {}", e, &text),
													}
												},
												None => log::error!("i29: gemini:  Failed to get ask as string. text: {}", text),
											}
										},
										Err(e) => log::error!("i29: gemini:  Failed to parse JSON: {}
                                        response text: {}", e, &text),
									}
								},
								Err(e) => log::error!("i29: gemini:  Failed to turn response into text: {}", e),
							}
						},
						Err(e) => log::error!("i29: gemini:  Failed to execute Gemini request: {}", e),
					}
				},
				Err(e) => log::error!("i29: gemini:  Couldn't build gemini request: {}", e),
			}
            log::error!("10 sec wait for i29 error. current attempt #: {}", attempts);
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("i29: Failed after 3 attempts");
			}
		}

















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 9 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    

			//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    

		//03/02/24 - added:
			let mut attempts = 0;
			let mut coinbase_sell_price_bid: Option<f64> = None;
			//let coinbase_buy_price_ask: Option<f64>;
			let mut value_after: Option<f64> = None;
            //03/13/24 - removed:
			//let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {

						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														//let product_id = pricebook["product_id"].as_str();
														let bids = &pricebook["bids"][0];
														//let asks = &pricebook["asks"][0];
														let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
														//let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_sell_price_bid {
															Some(bid_str) => {
																match bid_str.parse::<f64>() {
																	Ok(bid_str) => {
																		coinbase_sell_price_bid = Some(bid_str);

	
																		// Place your calculations and updates here
																			let gemini_taker_fee = 0.004;
																			let fraction_of_wallet_im_using = 0.09; //aka 9 percent
																			let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																			let fee_for_purchase = total_spent*gemini_taker_fee;
																			let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																			*gemini_wallet -= total_spent;
	
																			let amount_of_sol = 
																			money_going_to_sol_after_fees/gemini_buy_ask
																											.expect(&format!("gemini_buy_ask is somehow Not Some. 
																											even though to get to this point it had to be Some. 
																											gemini_buy_ask: {:?}
																											Honestly restart the program from the last saved state. 
																											The most likely error is a bit got flipped after the loop",
																											&gemini_buy_ask));
	
																			//coinbase calculations for sell

																			let coinbase_taker_fee = 0.008;
																			let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																			let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*coinbase_wallet += money_from_sell_after_fees;
																			value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																			if let Some(mut value_after) = value_after {
                                                                                //03/10/24 - added for unscaling
																				let value_after_unscaled = value_after;
																				let gemini_wallet_unscaled = *gemini_wallet;
																				let coinbase_wallet_unscaled = *coinbase_wallet;

																				*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																				*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																				value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																				
				
																				//value_after = 56
																				//coinbase = 57
																				//bitstamp = 58
																				//kraken = 59
																				//gemini = 60
																				//since this is coinbase and gemini being updated, I will update:
																				//  56, 57, 60
																				//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																				let indices = [56, 57, 60];
																				let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																				//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				neural_network.update_input(&indices, &scaled_values).await;



                                                                                //03/10/24 - added for unscaling:
                                                                                value_after = value_after_unscaled;
                                                                                *gemini_wallet = gemini_wallet_unscaled;
                                                                                *coinbase_wallet = coinbase_wallet_unscaled;

                                                                                //03/13/24 - added:
                                                                                return Ok(value_after);
																			}
																			//03/08/24 - removed:
																			// //value_after = 56
																			// //coinbase = 57
																			// //bitstamp = 58
																			// //kraken = 59
																			// //gemini = 60
																			// //since this is coinbase and gemini being updated, I will update:
																			// //  56, 57, 60
																			// let indices = [56, 57, 60];
																			// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																			// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			// neural_network.update_input(&indices, &scaled_values).await;

                                                                            //03/13/24 - removed:
																			// success = true;
																	},
																	Err(e) => {
																		log::error!("i29: failed to parse JSON to f64. response text: {}
                                                                        erroR: {}", &text, e);
																		if attempts > 3 {
																			panic!("i29: Failed to parse JSON after 3 attempts. Response text: {}", &text);
																		}
                                                                        log::error!("10secwait");
                                                                        let when = tokio::time::Instant::now() +
                                                                            tokio::time::Duration::from_secs(10);
                                                                        tokio::time::sleep_until(when).await;
																		continue ;
																	}
																}
															},
															None => {
																log::error!("i29: Failed to get bid. response text: {} ", &text);
																if attempts > 3 {
																	panic!("i29: Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																}
                                                                log::error!("10secwait");
                                                                let when = tokio::time::Instant::now() +
                                                                    tokio::time::Duration::from_secs(10);
                                                                tokio::time::sleep_until(when).await;
																continue ;
															}
														}
													}
												}
											},
											Err(e) => {
												log::error!("i29: failed to parse JSON. response text: {}
                                                error: {}", &text, e);
												if attempts > 3 {
													panic!("i29: Failed to parse JSON after 3 attempts. Response text: {}", text);
												}
                                                log::error!("10secwait");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue ; // Continue to the next iteration if parsing fails
											}
										}
									},
									Err(e) => {
										log::error!("i29: failed to get response text. error: {}", e);
										if attempts > 3 {
											panic!("i29: Failed to get response text after 3 attempts");
										}
                                        log::error!("10secwait");
                                        let when = tokio::time::Instant::now() +
                                            tokio::time::Duration::from_secs(10);
                                        tokio::time::sleep_until(when).await;
										continue ; // Continue to the next iteration if getting response text fails
									}
								}
							},
							Err(e) => {
								log::error!("i29: Failed to execute request. error: {}", e);
								if attempts > 3 {
									panic!("i29: Failed to execute request after 3 attempts");
								}
                                log::error!("10secwait");
                                let when = tokio::time::Instant::now() +
                                    tokio::time::Duration::from_secs(10);
                                tokio::time::sleep_until(when).await;
								continue; // Continue to the next iteration if executing request fails
							}
						}
					},
					Err(e) => {
						log::error!("i29: Failed to build request. error: {}", e);
						if attempts > 3 {
							panic!("i29: Failed to build request after 3 attempts");
						}
                        log::error!("10secwait");
                        let when = tokio::time::Instant::now() +
                            tokio::time::Duration::from_secs(10);
                        tokio::time::sleep_until(when).await;
						continue; // Continue to the next iteration if building request fails
					}
				}
                //03/13/24 - removed:
				// if success == true {
				// 	break;
				// }
			}
            //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
			// 	}
			// }















    
    
    
    
    
    
    
    
			//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and gemini being updated, I will update:
            //     //  56, 57, 60
            //     let indices = [56, 57, 60];
            //     let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i30_sol_10_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

		//03/02/24 - removed:
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);


        



		//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
	
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i30: gemini:  Failed to parse ask as f64: {}
                                                        response text: {}", e, &text),
													}
												},
												None => log::error!("i30: gemini:  Failed to get ask as string. text: {}", text),
											}
										},
										Err(e) => log::error!("i30: gemini:  Failed to parse JSON: {}
                                        response text: {}", e, &text),
									}
								},
								Err(e) => log::error!("i30: gemini:  Failed to turn response into text: {}", e),
							}
						},
						Err(e) => log::error!("i30: gemini:  Failed to execute Gemini request: {}", e),
					}
				},
				Err(e) => log::error!("i30: gemini:  Couldn't build gemini request: {}", e),
			}
            log::error!("10 sec wait for i30 error. current attempt #: {}", attempts);
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("i30: Failed after 3 attempts");
			}
		}

















        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 10 gemini coinbase: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;


        //---------------------------Coinbase---------------------------------------------//

            let now = Utc::now();
            let time_stamp = now.timestamp().to_string();
            let method = "GET";
            let request_path = "/api/v3/brokerage/best_bid_ask";
            let body = "";
            let message = format!("{}{}{}{}", &time_stamp, 
            &method, &request_path, &body);
            type HmacSha256 = Hmac<Sha256>;
            fn sign(message: &str, coinbase_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                        .expect("HMAC can take key of any size");
            mac.update(message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
            }
            let coinbase_signature = sign(&message, &coinbase_secret);
    

			//03/02/24 - removed:
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price = 0.0;
            // let mut coinbase_buy_price = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
            //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    
    

		//03/02/24 - added:
			let mut attempts = 0;
			let mut coinbase_sell_price_bid: Option<f64> = None;
			//let coinbase_buy_price_ask: Option<f64>;
			let mut value_after: Option<f64> = None;
            //03/13/24 - removed:
			//let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {

						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														//let product_id = pricebook["product_id"].as_str();
														let bids = &pricebook["bids"][0];
														//let asks = &pricebook["asks"][0];
														let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
														//let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_sell_price_bid {
															Some(bid_str) => {
																match bid_str.parse::<f64>() {
																	Ok(bid_str) => {
																		coinbase_sell_price_bid = Some(bid_str);

	
																		// Place your calculations and updates here
																			let gemini_taker_fee = 0.004;
																			let fraction_of_wallet_im_using = 0.10; //aka 10 percent
																			let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																			let fee_for_purchase = total_spent*gemini_taker_fee;
																			let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																			*gemini_wallet -= total_spent;
	
																			let amount_of_sol = 
																			money_going_to_sol_after_fees/gemini_buy_ask
																											.expect(&format!("gemini_buy_ask is somehow Not Some. 
																											even though to get to this point it had to be Some. 
																											gemini_buy_ask: {:?}
																											Honestly restart the program from the last saved state. 
																											The most likely error is a bit got flipped after the loop",
																											&gemini_buy_ask));
	
																			//coinbase calculations for sell

																			let coinbase_taker_fee = 0.008;
																			let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																			let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*coinbase_wallet += money_from_sell_after_fees;
																			value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																			if let Some(mut value_after) = value_after {
                                                                                //03/10/24 - added for unscaling
																				let value_after_unscaled = value_after;
																				let gemini_wallet_unscaled = *gemini_wallet;
																				let coinbase_wallet_unscaled = *coinbase_wallet;

																				*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																				*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																				value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																				
				
																				//value_after = 56
																				//coinbase = 57
																				//bitstamp = 58
																				//kraken = 59
																				//gemini = 60
																				//since this is coinbase and gemini being updated, I will update:
																				//  56, 57, 60
																				//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																				let indices = [56, 57, 60];
																				let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																				//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				neural_network.update_input(&indices, &scaled_values).await;



                                                                                //03/10/24 - added for unscaling:
                                                                                value_after = value_after_unscaled;
                                                                                *gemini_wallet = gemini_wallet_unscaled;
                                                                                *coinbase_wallet = coinbase_wallet_unscaled;

                                                                                //03/13/24 - added:
                                                                                return Ok(value_after);
																			}
																			//03/08/24 - removed:
																			// //value_after = 56
																			// //coinbase = 57
																			// //bitstamp = 58
																			// //kraken = 59
																			// //gemini = 60
																			// //since this is coinbase and gemini being updated, I will update:
																			// //  56, 57, 60
																			// let indices = [56, 57, 60];
																			// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																			// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			// neural_network.update_input(&indices, &scaled_values).await;

                                                                            //03/13/24 - removed:
																			// success = true;
																	},
																	Err(e) => {
																		log::error!("i30: failed to parse JSON to f64. response text: {}
                                                                        erroR: {}", &text, e);
																		if attempts > 3 {
																			panic!("i30: Failed to parse JSON after 3 attempts. Response text: {}", &text);
																		}
                                                                        log::error!("10secwait");
                                                                        let when = tokio::time::Instant::now() +
                                                                            tokio::time::Duration::from_secs(10);
                                                                        tokio::time::sleep_until(when).await;
																		continue ;
																	}
																}
															},
															None => {
																log::error!("i30: Failed to get bid. response text: {} ", &text);
																if attempts > 3 {
																	panic!("i30: Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																}
                                                                log::error!("10secwait");
                                                                let when = tokio::time::Instant::now() +
                                                                    tokio::time::Duration::from_secs(10);
                                                                tokio::time::sleep_until(when).await;
																continue ;
															}
														}
													}
												}
											},
											Err(e) => {
												log::error!("i30: failed to parse JSON. response text: {}
                                                error: {}", &text, e);
												if attempts > 3 {
													panic!("i30: Failed to parse JSON after 3 attempts. Response text: {}", text);
												}
                                                log::error!("10secwait");
                                                let when = tokio::time::Instant::now() +
                                                    tokio::time::Duration::from_secs(10);
                                                tokio::time::sleep_until(when).await;
												continue ; // Continue to the next iteration if parsing fails
											}
										}
									},
									Err(e) => {
										log::error!("i30: failed to get response text. error: {}", e);
										if attempts > 3 {
											panic!("i30: Failed to get response text after 3 attempts");
										}
                                        log::error!("10secwait");
                                        let when = tokio::time::Instant::now() +
                                            tokio::time::Duration::from_secs(10);
                                        tokio::time::sleep_until(when).await;
										continue ; // Continue to the next iteration if getting response text fails
									}
								}
							},
							Err(e) => {
								log::error!("i30: Failed to execute request. error: {}", e);
								if attempts > 3 {
									panic!("i30: Failed to execute request after 3 attempts");
								}
                                log::error!("10secwait");
                                let when = tokio::time::Instant::now() +
                                    tokio::time::Duration::from_secs(10);
                                tokio::time::sleep_until(when).await;
								continue; // Continue to the next iteration if executing request fails
							}
						}
					},
					Err(e) => {
						log::error!("i30: Failed to build request. error: {}", e);
						if attempts > 3 {
							panic!("i30: Failed to build request after 3 attempts");
						}
                        log::error!("10secwait");
                        let when = tokio::time::Instant::now() +
                            tokio::time::Duration::from_secs(10);
                        tokio::time::sleep_until(when).await;
						continue; // Continue to the next iteration if building request fails
					}
				}
                //03/13/24 - removed:
				// if success == true {
				// 	break;
				// }
			}
            //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
			// 	}
			// }















    
    
    
    
    
    
    
    
			//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
    
    
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and gemini being updated, I will update:
            //     //  56, 57, 60
            //     let indices = [56, 57, 60];
            //     let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }
    //cant use 1 through 4 because minimum Kraken buy is 0.2 SOL
    /*
    pub async fn s_i31_sol_1_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.01;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }

    pub async fn s_i32_sol_2_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.02;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }

    pub async fn s_i33_sol_3_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.03;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }

    pub async fn s_i34_sol_4_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            println!("Ask price: {}", kraken_buy_price_ask);
            println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.04;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                let kraken_taker_fee = 0.0026;
                
                let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                *kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
                //println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }
    */
    pub async fn s_i35_sol_5_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

	//03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i35: gemini:  Failed to parse ask as f64.
                                                        response text: {}
                                                        error: {}", &text, e),
													}
												},
												None => log::error!("i35: gemini:  Failed to get ask as string.
                                                response text: {}", &text),
											}
										},
										Err(e) => log::error!("i35: gemini:  Failed to parse JSON.
                                        response text: {}
                                        error: {}", &text, e),
									}
								},
								Err(e) => log::error!("i35: gemini:  Failed to turn response into text. error: {}", e),
							}
						},
						Err(e) => log::error!("i35: gemini:  Failed to execute Gemini request: {}", e),
					}
				},
				Err(e) => log::error!("i35: gemini:  Couldn't build gemini request: {}", e),
			}
		
			attempts += 1;
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}




    //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 5 gemini kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request

	//03/02/24 - removed:	
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("Ask price: {}", kraken_buy_price_ask);
        //     println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();
		
			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																kraken_sell_price_bid = Some(bid);

																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.05; //aka 5 percent
																
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;
																if let Some(gemini_buy_ask) = gemini_buy_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

                                                                                    //03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let gemini_wallet_unscaled = *gemini_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and gemini being updated, I will update:
																					//  56, 59, 60
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 59, 60];
																					let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*gemini_wallet = gemini_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 60
																				// let indices = [56, 59, 60];
																				// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i35: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i35: Gemini buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i35: Failed to parse ask or bid as f64Response text was: {}
                                                            erroR: {}", kraken_response_text, e),
														}
													},
													None => log::error!("i35: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}										
											} 
											else {
												log::error!("i35: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i35: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i35: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i35: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i35: Failed to build kraken request. Error was: {}", e),
			}
		
			// Continue with your logic here...
			// Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            //03/13/24 - removed since no more need for a break statement
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
		
			attempts += 1;
            log::info!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(3 * 60);
            tokio::time::sleep_until(when).await;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}









    //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.05;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is kraken and gemini being updated, I will update:
            //     //  56, 59, 64
            //     let indices = [56, 59, 64];
            //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)
		//03/02/24 - added:
        //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		panic!("Failed to get a valid value after {} attempts. 
			// 		Final values: kraken_sell_price_bid = {:?}
			// 		gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
			// 	}
			// }

    }

    pub async fn s_i36_sol_6_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

	//03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i36: gemini:  Failed to parse ask as f64.
                                                        response text: {}
                                                        error: {}", &text, e),
													}
												},
												None => log::error!("i36: gemini:  Failed to get ask as string.
                                                response text: {}", &text),
											}
										},
										Err(e) => log::error!("i36: gemini:  Failed to parse JSON.
                                        response text: {}
                                        error: {}", &text, e),
									}
								},
								Err(e) => log::error!("i36: gemini:  Failed to turn response into text.error: {}", e),
							}
						},
						Err(e) => log::error!("i36: gemini:  Failed to execute Gemini request. error: {}",e),
					}
				},
				Err(e) => log::error!("i36: gemini:  Couldn't build gemini request. error: {}", e),
			}
		
			attempts += 1;
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}




    //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 6 gemini kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request

	//03/02/24 - removed:	
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("Ask price: {}", kraken_buy_price_ask);
        //     println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();
		
			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																kraken_sell_price_bid = Some(bid);

																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.06; //aka 6 percent
																
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;
																if let Some(gemini_buy_ask) = gemini_buy_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

                                                                                    //03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let gemini_wallet_unscaled = *gemini_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and gemini being updated, I will update:
																					//  56, 59, 60
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 59, 60];
																					let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*gemini_wallet = gemini_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 60
																				// let indices = [56, 59, 60];
																				// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i36: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i36: Gemini buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i36: Failed to parse ask or bid as f64Response text was: {}
                                                            erroR: {}", kraken_response_text, e),
														}
													},
													None => log::error!("i36: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}
											} 
											else {
												log::error!("i36: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i36: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i36: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i36: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i36: Failed to build kraken request. Error was: {}", e),
			}
		
			// Continue with your logic here...
			// Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
		
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
		
			attempts += 1;
            log::info!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(3 * 60);
            tokio::time::sleep_until(when).await;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}









    //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.05;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is kraken and gemini being updated, I will update:
            //     //  56, 59, 64
            //     let indices = [56, 59, 64];
            //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)
		//03/02/24 - added:
        //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
					
			// 		panic!("Failed to get a valid value after {} attempts. 
			// 		Final values: kraken_sell_price_bid = {:?}
			// 		gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
			// 	}
			// }

    }

    pub async fn s_i37_sol_7_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

	//03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i36: gemini:  Failed to parse ask as f64.
                                                        response text: {}
                                                        error: {}", &text, e),
													}
												},
												None => log::error!("i36: gemini:  Failed to get ask as string.
                                                response text: {}", &text),
											}
										},
										Err(e) => log::error!("i36: gemini:  Failed to parse JSON.
                                        response text: {}
                                        error: {}", &text, e),
									}
								},
								Err(e) => log::error!("i36: gemini:  Failed to turn response into text.error: {}", e),
							}
						},
						Err(e) => log::error!("i36: gemini:  Failed to execute Gemini request. error: {}",e),
					}
				},
				Err(e) => log::error!("i36: gemini:  Couldn't build gemini request. error: {}", e),
			}
		
			attempts += 1;
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}




    //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 7 gemini kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request

	//03/02/24 - removed:	
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("Ask price: {}", kraken_buy_price_ask);
        //     println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();
		
			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																kraken_sell_price_bid = Some(bid);

																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.07; //aka 7 percent
																
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;
																if let Some(gemini_buy_ask) = gemini_buy_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

                                                                                    //03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let gemini_wallet_unscaled = *gemini_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and gemini being updated, I will update:
																					//  56, 59, 60
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 59, 60];
																					let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*gemini_wallet = gemini_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 60
																				// let indices = [56, 59, 60];
																				// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i37: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i37: Gemini buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i37: Failed to parse ask or bid as f64Response text was: {}
                                                            erroR: {}", kraken_response_text, e),
														}
													},
													None => log::error!("i37: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}										
											} 
											else {
												log::error!("i37: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i37: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i37: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i37: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i37: Failed to build kraken request. Error was: {}", e),
			}
		
			// Continue with your logic here...
			// Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
		
			attempts += 1;
            log::info!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(3 * 60);
            tokio::time::sleep_until(when).await;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}









    //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.05;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is kraken and gemini being updated, I will update:
            //     //  56, 59, 64
            //     let indices = [56, 59, 64];
            //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)
		//03/02/24 - added:
        //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
					
			// 		panic!("Failed to get a valid value after {} attempts. 
			// 		Final values: kraken_sell_price_bid = {:?}
			// 		gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
			// 	}
			// }

    }
    
	pub async fn s_i38_sol_8_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

	//03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i38: gemini:  Failed to parse ask as f64.
                                                        response text: {}
                                                        error: {}", &text, e),
													}
												},
												None => log::error!("i38: gemini:  Failed to get ask as string.
                                                response text: {}", &text),
											}
										},
										Err(e) => log::error!("i38: gemini:  Failed to parse JSON.
                                        response text: {}
                                        error: {}", &text, e),
									}
								},
								Err(e) => log::error!("i38: gemini:  Failed to turn response into text.error: {}", e),
							}
						},
						Err(e) => log::error!("i38: gemini:  Failed to execute Gemini request. error: {}",e),
					}
				},
				Err(e) => log::error!("i38: gemini:  Couldn't build gemini request. error: {}", e),
			}
		
			attempts += 1;
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}




    //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 8 gemini kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request

	//03/02/24 - removed:	
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("Ask price: {}", kraken_buy_price_ask);
        //     println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();
		
			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																kraken_sell_price_bid = Some(bid);

																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.08; //aka 8 percent
																
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;
																if let Some(gemini_buy_ask) = gemini_buy_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

                                                                                    //03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let gemini_wallet_unscaled = *gemini_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and gemini being updated, I will update:
																					//  56, 59, 60
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 59, 60];
																					let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*gemini_wallet = gemini_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 60
																				// let indices = [56, 59, 60];
																				// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i38: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i38: Gemini buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i38: Failed to parse ask or bid as f64Response text was: {}
                                                            erroR: {}", kraken_response_text, e),
														}
													},
													None => log::error!("i38: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}									
											} 
											else {
												log::error!("i38: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i38: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i38: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i38: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i38: Failed to build kraken request. Error was: {}", e),
			}
		
			// Continue with your logic here...
			// Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
		
			attempts += 1;
            log::info!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(3 * 60);
            tokio::time::sleep_until(when).await;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}









    //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.05;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is kraken and gemini being updated, I will update:
            //     //  56, 59, 64
            //     let indices = [56, 59, 64];
            //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)
		//03/02/24 - added:
        //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
					
			// 		panic!("Failed to get a valid value after {} attempts. 
			// 		Final values: kraken_sell_price_bid = {:?}
			// 		gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
			// 	}
			// }

    }

    pub async fn s_i39_sol_9_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

	//03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i39: gemini:  Failed to parse ask as f64.
                                                        response text: {}
                                                        error: {}", &text, e),
													}
												},
												None => log::error!("i39: gemini:  Failed to get ask as string.
                                                response text: {}", &text),
											}
										},
										Err(e) => log::error!("i39: gemini:  Failed to parse JSON.
                                        response text: {}
                                        error: {}", &text, e),
									}
								},
								Err(e) => log::error!("i39: gemini:  Failed to turn response into text.error: {}", e),
							}
						},
						Err(e) => log::error!("i39: gemini:  Failed to execute Gemini request. error: {}",e),
					}
				},
				Err(e) => log::error!("i39: gemini:  Couldn't build gemini request. error: {}", e),
			}
		
			attempts += 1;
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}




    //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 9 gemini kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request

	//03/02/24 - removed:	
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("Ask price: {}", kraken_buy_price_ask);
        //     println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();
		
			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match  solusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																kraken_sell_price_bid = Some(bid);

																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.09; //aka 9 percent
																
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;
																if let Some(gemini_buy_ask) = gemini_buy_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

                                                                                    //03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let gemini_wallet_unscaled = *gemini_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and gemini being updated, I will update:
																					//  56, 59, 60
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 59, 60];
																					let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*gemini_wallet = gemini_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 60
																				// let indices = [56, 59, 60];
																				// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i39: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i39: Gemini buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i39: Failed to parse ask or bid as f64Response text was: {}
                                                            erroR: {}", kraken_response_text, e),
														}
													},
													None => log::error!("i39: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}									
											} 
											else {
												log::error!("i39: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i39: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i39: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i39: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i39: Failed to build kraken request. Error was: {}", e),
			}
		
			// Continue with your logic here...
			// Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
		
			attempts += 1;
            log::info!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(3 * 60);
            tokio::time::sleep_until(when).await;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}









    //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.05;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is kraken and gemini being updated, I will update:
            //     //  56, 59, 64
            //     let indices = [56, 59, 64];
            //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)
		//03/02/24 - added:
        //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
			// 		panic!("Failed to get a valid value after {} attempts. 
			// 		Final values: kraken_sell_price_bid = {:?}
			// 		gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
			// 	}
			// }

    }

    pub async fn s_i40_sol_10_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        

	//03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(e) => log::error!("i40: gemini:  Failed to parse ask as f64.
                                                        response text: {}
                                                        error: {}", &text, e),
													}
												},
												None => log::error!("i40: gemini:  Failed to get ask as string.
                                                response text: {}", &text),
											}
										},
										Err(e) => log::error!("i40: gemini:  Failed to parse JSON.
                                        response text: {}
                                        error: {}", &text, e),
									}
								},
								Err(e) => log::error!("i40: gemini:  Failed to turn response into text.error: {}", e),
							}
						},
						Err(e) => log::error!("i40: gemini:  Failed to execute Gemini request. error: {}",e),
					}
				},
				Err(e) => log::error!("i40: gemini:  Couldn't build gemini request. error: {}", e),
			}
		
			attempts += 1;
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}




    //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 10 gemini kraken: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;



        //---------------------------Kraken---------------------------------------------//

        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            println!("Nonce:\n{}", nonce_str);
            println!("Encoded payload:\n{}", post_data);
            println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request

	//03/02/24 - removed:	
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("Ask price: {}", kraken_buy_price_ask);
        //     println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }



	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();
		
			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

												match (/*solusd["a"][0].as_str(),*/ solusd["b"][0].as_str()) {
													(/*Some(ask_str),*/ Some(bid_str)) => {
														match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
															(/*Ok(ask),*/ Ok(bid)) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// Continue with your logic here...

																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.10; //aka 10 percent
																
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;
																if let Some(gemini_buy_ask) = gemini_buy_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
																		// Continue with your logic here...
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

                                                                                    //03/09/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let gemini_wallet_unscaled = *gemini_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and gemini being updated, I will update:
																					//  56, 59, 60
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 59, 60];
																					let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;


																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*gemini_wallet = gemini_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 60
																				// let indices = [56, 59, 60];
																				// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i40: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i40: Gemini buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															_ => log::error!("i40: Failed to parse ask or bid as f64"),
														}
													},
													_ => log::error!("i40: Failed to get ask or bid as string"),
												}										
											} 
											else {
												log::error!("i40: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i40: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i40: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i40: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i40: Failed to build kraken request. Error was: {}", e),
			}
		
			// Continue with your logic here...
			// Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
		
			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}









    //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            ////new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations
            //let kraken_taker_fee = 0.0026;
            
            //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //*kraken_wallet += money_from_sell_after_fees;

            //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;

    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.05;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //*coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //*bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is kraken and gemini being updated, I will update:
            //     //  56, 59, 64
            //     let indices = [56, 59, 64];
            //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)
		//03/02/24 - added:
        //03/13/24 - removed:
			// match value_after {
			// 	Some(value) => return Ok(value),
			// 	None => {
					
			// 		panic!("Failed to get a valid value after {} attempts. 
			// 		Final values: kraken_sell_price_bid = {:?}
			// 		gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
			// 	}
			// }

    }
    //gemini has withdraw minimums of 10 dollars: 
    //      https://www.gemini.com/legal/user-agreement#section-fiat-currency-withdrawals
    /*
    pub async fn s_i41_sol_1_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.01;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }

    pub async fn s_i42_sol_2_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str )-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build()
                .expect("couldn't build gemini request");
    
    
        let gemini_response = client.execute(gemini_request).await
                                .expect("Failed to execute Gemini request");
        let gemini_response_text = gemini_response.text().await
                                .expect("Failed to turn response into text");
        let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
                                .expect("Failed to parse JSON");
        let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        //CAN ONLY BUY. NOT SELL
        let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);









        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		.header("X-Auth-Signature", bitstamp_signature)
		.header("X-Auth-Nonce", bitstamp_nonce)
		.header("X-Auth-Timestamp", bitstamp_timestamp)
		.header("X-Auth-Version", "v2")
		//.header("Content-Type", content_type)
		//.body(payload_string)
		.build()
		.expect("\ncould not build bitstamp_request");

	let bitstamp_response = client.execute(bitstamp_request).await
		.expect("Failed to execute Bitstamp request");
	let bitstamp_response_text = bitstamp_response.text().await
		.expect("Failed to turn response into text");
	//probably dont need "bitstamp" once we transfer this to the actual function
    let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
    .expect("Failed to parse JSON");

// Extract the bid and ask values
    let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
    let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
    //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	//println!("Bitstamp:\n{:?}", bitstamp_response_text);





    
    
    
    
    
    
    
    
    
    
    
    
            //gemini calculations for buy 
                //this should equal 0.4%
                let gemini_taker_fee = 0.004;
                let fraction_of_wallet_im_using = 0.02;

                let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                let fee_for_purchase = total_spent*gemini_taker_fee;
                let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                //new state of gemini wallet below
                *gemini_wallet -= total_spent;
                let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            //bitstamp calculations for sell
                let bitstamp_taker_fee = 0.004;
                let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                *bitstamp_wallet += money_from_sell_after_fees;
    

            //coinbase calculations for sell

                //let coinbase_taker_fee = 0.008;
                //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
                //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //coinbase calculations for buy - not needed in this so code commented out
            
                //let coinbase_taker_fee = 0.008;
    
                //let total_spent = 0.10*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //coinbase_wallet -= total_spent;
                //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            //kraken calculations - for sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            //bitstamp calculations - for sell
                //let bitstamp_taker_fee = 0.004;
                //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                //bitstamp_wallet += money_from_sell_after_fees;



            //this will count as value after
                let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
                println!("value after:\n\t{}",value_after);
    
    
                return Ok(value_after)

    }
    */
    //begin removal
    pub async fn s_i43_sol_3_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        //03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i43: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i43: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i43: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i43: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i43: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i43: gemini:  Couldn't build gemini request"),
			}
		
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 3 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

//03/02/24 - removed:	
	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
	// 		.header("X-Auth-Signature", bitstamp_signature)
	// 		.header("X-Auth-Nonce", bitstamp_nonce)
	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
	// 		.header("X-Auth-Version", "v2")
	// 		//.header("Content-Type", content_type)
	// 		//.body(payload_string)
	// 		.build()
	// 		.expect("\ncould not build bitstamp_request");

	// 	let bitstamp_response = client.execute(bitstamp_request).await
	// 		.expect("Failed to execute Bitstamp request");
	// 	let bitstamp_response_text = bitstamp_response.text().await
	// 		.expect("Failed to turn response into text");
	// 	//probably dont need "bitstamp" once we transfer this to the actual function
	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
	//     .expect("Failed to parse JSON");

	// // Extract the bid and ask values
	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
	//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	// 	//println!("Bitstamp:\n{:?}", bitstamp_response_text);

//03/02/24 - added:
	let mut success = false;
	let mut attempts = 0;
	let mut value_after: Option<f64> = None;

	while !success && attempts <=3 {
		attempts += 1;

		match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			.header("X-Auth-Signature", &bitstamp_signature)
			.header("X-Auth-Nonce", &bitstamp_nonce)
			.header("X-Auth-Timestamp", &bitstamp_timestamp)
			.header("X-Auth-Version", "v2")
			.build() {
			Ok(bitstamp_request) => {
				match client.execute(bitstamp_request).await {
					Ok(bitstamp_response) => {
						match bitstamp_response.text().await {
							Ok(bitstamp_response_text) => {
								match serde_json::from_str::<Value>(&bitstamp_response_text) {
									Ok(v) => {
										let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
										let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

										match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
											(Some(bid_str), Some(ask_str)) => {
												match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
													(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

														// Place your calculations and updates here

														//gemini calculations to buy
														let gemini_taker_fee = 0.004;
														let fraction_of_wallet_im_using = 0.03; //aka 3 percent
														let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
														let fee_for_purchase = total_spent*gemini_taker_fee;
														let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
														*gemini_wallet -= total_spent;

														let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask
																						.expect(&format!("gemini_buy_price_ask is somehow Not Some. 
																						even though to get to this point it had to be Some. 
																						gemini_buy_price_ask: {:?}
																						Honestly restart the program from the last saved state. 
																						The most likely error is a bit got flipped after the loop",
																						&gemini_buy_ask));

														//bitstamp calculations for sell

														let bitstamp_taker_fee = 0.004;
														let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
														let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
														let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
														*bitstamp_wallet += money_from_sell_after_fees;
														value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
														if let Some(mut value_after) = value_after {

															//03/09/24 - added for unscaling
															let value_after_unscaled = value_after;
															let gemini_wallet_unscaled = *gemini_wallet;
															let bitstamp_wallet_unscaled = *bitstamp_wallet;

															*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
															*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
															value_after = standardization_functions::normal_value_prior_standardization(&value_after);
															

															//value_after = 56
															//coinbase = 57
															//bitstamp = 58
															//kraken = 59
															//gemini = 60
															//since this is bitstamp and gemini being updated, I will update:
															//  56, 58, 60
															//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
															let indices = [56, 58, 60];
															let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
															//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															neural_network.update_input(&indices, &scaled_values).await;

															//03/10/24 - added for unscaling:
															value_after = value_after_unscaled;
															*gemini_wallet = gemini_wallet_unscaled;
															*bitstamp_wallet = bitstamp_wallet_unscaled;
														}
														//03/08/24 - removed:
														// //value_after = 56
														// //coinbase = 57
														// //bitstamp = 58
														// //kraken = 59
														// //gemini = 60
														// //since this is bitstamp and gemini being updated, I will update:
														// //  56, 58, 60
														// let indices = [56, 58, 60];
														// let new_values = [value_after, Some(*bitstamp_wallet), Some(*gemini_wallet)];
														// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
														// neural_network.update_input(&indices, &scaled_values).await;




														success = true;
													},
													_ => {
														log::error!("i43: Failed to parse bid or ask price as f64");
														if attempts > 3 {
															panic!("i43: Failed to parse bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											_ => {
												log::error!("i43: Failed to get bid or ask price");	
												if attempts > 3 {
													panic!("i43: Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i43: Failed to parse JSON as str");	
										if attempts > 3 {
											panic!("i43: Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i43: Failed to get response text");
								if attempts > 3 {
									panic!("i43: Failed to get response text after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i43: Failed to execute request");	
						if attempts > 3 {
							panic!("i43: Failed to execute request after 3 attempts");
						}
						continue;
					}
				}
			},
			Err(_) => {
				log::error!("i43: Failed to build request");	
				if attempts > 3 {
				
					panic!("i43: Failed to build request after 3 attempts");
				}
				continue;
			}
		}
	}
	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
		}
	}


    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            // //bitstamp calculations for sell
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is bitstamp and gemini being updated, I will update:
            //     //  56, 58, 64
            //     let indices = [56, 58, 64];
            //     let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i44_sol_4_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        //03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i44: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i44: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i44: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i44: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i44: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i44: gemini:  Couldn't build gemini request"),
			}
		
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 4 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

//03/02/24 - removed:	
	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
	// 		.header("X-Auth-Signature", bitstamp_signature)
	// 		.header("X-Auth-Nonce", bitstamp_nonce)
	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
	// 		.header("X-Auth-Version", "v2")
	// 		//.header("Content-Type", content_type)
	// 		//.body(payload_string)
	// 		.build()
	// 		.expect("\ncould not build bitstamp_request");

	// 	let bitstamp_response = client.execute(bitstamp_request).await
	// 		.expect("Failed to execute Bitstamp request");
	// 	let bitstamp_response_text = bitstamp_response.text().await
	// 		.expect("Failed to turn response into text");
	// 	//probably dont need "bitstamp" once we transfer this to the actual function
	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
	//     .expect("Failed to parse JSON");

	// // Extract the bid and ask values
	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
	//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	// 	//println!("Bitstamp:\n{:?}", bitstamp_response_text);

//03/02/24 - added:
	let mut success = false;
	let mut attempts = 0;
	let mut value_after: Option<f64> = None;

	while !success && attempts <=3 {
		attempts += 1;

		match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			.header("X-Auth-Signature", &bitstamp_signature)
			.header("X-Auth-Nonce", &bitstamp_nonce)
			.header("X-Auth-Timestamp", &bitstamp_timestamp)
			.header("X-Auth-Version", "v2")
			.build() {
			Ok(bitstamp_request) => {
				match client.execute(bitstamp_request).await {
					Ok(bitstamp_response) => {
						match bitstamp_response.text().await {
							Ok(bitstamp_response_text) => {
								match serde_json::from_str::<Value>(&bitstamp_response_text) {
									Ok(v) => {
										let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
										let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

										match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
											(Some(bid_str), Some(ask_str)) => {
												match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
													(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

														// Place your calculations and updates here

														//gemini calculations to buy
														let gemini_taker_fee = 0.004;
														let fraction_of_wallet_im_using = 0.04; //aka 4 percent
														let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
														let fee_for_purchase = total_spent*gemini_taker_fee;
														let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
														*gemini_wallet -= total_spent;

														let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask
																						.expect(&format!("gemini_buy_price_ask is somehow Not Some. 
																						even though to get to this point it had to be Some. 
																						gemini_buy_price_ask: {:?}
																						Honestly restart the program from the last saved state. 
																						The most likely error is a bit got flipped after the loop",
																						&gemini_buy_ask));

														//bitstamp calculations for sell

														let bitstamp_taker_fee = 0.004;
														let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
														let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
														let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
														*bitstamp_wallet += money_from_sell_after_fees;
														value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
														if let Some(mut value_after) = value_after {
															*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
															*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
															value_after = standardization_functions::normal_value_prior_standardization(&value_after);
															

															//value_after = 56
															//coinbase = 57
															//bitstamp = 58
															//kraken = 59
															//gemini = 60
															//since this is bitstamp and gemini being updated, I will update:
															//  56, 58, 60
															//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
															let indices = [56, 58, 60];
															let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
															//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															neural_network.update_input(&indices, &scaled_values).await;
														}
														//03/08/24 - removed:
														// //value_after = 56
														// //coinbase = 57
														// //bitstamp = 58
														// //kraken = 59
														// //gemini = 60
														// //since this is bitstamp and gemini being updated, I will update:
														// //  56, 58, 60
														// let indices = [56, 58, 60];
														// let new_values = [value_after, Some(*bitstamp_wallet), Some(*gemini_wallet)];
														// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
														// neural_network.update_input(&indices, &scaled_values).await;




														success = true;
													},
													_ => {
														log::error!("i44: Failed to parse bid or ask price as f64");
														if attempts > 3 {
															panic!("i44: Failed to parse bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											_ => {
												log::error!("i44: Failed to get bid or ask price");	
												if attempts > 3 {
													panic!("i44: Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i44: Failed to parse JSON as str");	
										if attempts > 3 {
											panic!("i44: Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i44: Failed to get response text");
								if attempts > 3 {
									panic!("i44: Failed to get response text after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i44: Failed to execute request");	
						if attempts > 3 {
							panic!("i44: Failed to execute request after 3 attempts");
						}
						continue;
					}
				}
			},
			Err(_) => {
				log::error!("i44: Failed to build request");	
				if attempts > 3 {
				
					panic!("i44: Failed to build request after 3 attempts");
				}
				continue;
			}
		}
	}
	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
		}
	}


    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            // //bitstamp calculations for sell
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is bitstamp and gemini being updated, I will update:
            //     //  56, 58, 64
            //     let indices = [56, 58, 64];
            //     let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i45_sol_5_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        //03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i45: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i45: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i45: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i45: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i45: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i45: gemini:  Couldn't build gemini request"),
			}
		
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 5 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

//03/02/24 - removed:	
	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
	// 		.header("X-Auth-Signature", bitstamp_signature)
	// 		.header("X-Auth-Nonce", bitstamp_nonce)
	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
	// 		.header("X-Auth-Version", "v2")
	// 		//.header("Content-Type", content_type)
	// 		//.body(payload_string)
	// 		.build()
	// 		.expect("\ncould not build bitstamp_request");

	// 	let bitstamp_response = client.execute(bitstamp_request).await
	// 		.expect("Failed to execute Bitstamp request");
	// 	let bitstamp_response_text = bitstamp_response.text().await
	// 		.expect("Failed to turn response into text");
	// 	//probably dont need "bitstamp" once we transfer this to the actual function
	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
	//     .expect("Failed to parse JSON");

	// // Extract the bid and ask values
	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
	//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	// 	//println!("Bitstamp:\n{:?}", bitstamp_response_text);

//03/02/24 - added:
	let mut success = false;
	let mut attempts = 0;
	let mut value_after: Option<f64> = None;

	while !success && attempts <=3 {
		attempts += 1;

		match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			.header("X-Auth-Signature", &bitstamp_signature)
			.header("X-Auth-Nonce", &bitstamp_nonce)
			.header("X-Auth-Timestamp", &bitstamp_timestamp)
			.header("X-Auth-Version", "v2")
			.build() {
			Ok(bitstamp_request) => {
				match client.execute(bitstamp_request).await {
					Ok(bitstamp_response) => {
						match bitstamp_response.text().await {
							Ok(bitstamp_response_text) => {
								match serde_json::from_str::<Value>(&bitstamp_response_text) {
									Ok(v) => {
										let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
										let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

										match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
											(Some(bid_str), Some(ask_str)) => {
												match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
													(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

														// Place your calculations and updates here

														//gemini calculations to buy
														let gemini_taker_fee = 0.004;
														let fraction_of_wallet_im_using = 0.05; //aka 5 percent
														let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
														let fee_for_purchase = total_spent*gemini_taker_fee;
														let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
														*gemini_wallet -= total_spent;

														let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask
																						.expect(&format!("gemini_buy_price_ask is somehow Not Some. 
																						even though to get to this point it had to be Some. 
																						gemini_buy_price_ask: {:?}
																						Honestly restart the program from the last saved state. 
																						The most likely error is a bit got flipped after the loop",
																						&gemini_buy_ask));

														//bitstamp calculations for sell

														let bitstamp_taker_fee = 0.004;
														let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
														let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
														let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
														*bitstamp_wallet += money_from_sell_after_fees;
														value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
														if let Some(mut value_after) = value_after {
															*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
															*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
															value_after = standardization_functions::normal_value_prior_standardization(&value_after);
															

															//value_after = 56
															//coinbase = 57
															//bitstamp = 58
															//kraken = 59
															//gemini = 60
															//since this is bitstamp and gemini being updated, I will update:
															//  56, 58, 60
															//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
															let indices = [56, 58, 60];
															let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
															//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															neural_network.update_input(&indices, &scaled_values).await;
														}
														//03/08/24 - removed:
														// //value_after = 56
														// //coinbase = 57
														// //bitstamp = 58
														// //kraken = 59
														// //gemini = 60
														// //since this is bitstamp and gemini being updated, I will update:
														// //  56, 58, 60
														// let indices = [56, 58, 60];
														// let new_values = [value_after, Some(*bitstamp_wallet), Some(*gemini_wallet)];
														// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
														// neural_network.update_input(&indices, &scaled_values).await;




														success = true;
													},
													_ => {
														log::error!("i45: Failed to parse bid or ask price as f64");
														if attempts > 3 {
															panic!("i45: Failed to parse bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											_ => {
												log::error!("i45: Failed to get bid or ask price");	
												if attempts > 3 {
													panic!("i45: Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i45: Failed to parse JSON as str");	
										if attempts > 3 {
											panic!("i45: Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i45: Failed to get response text");
								if attempts > 3 {
									panic!("i45: Failed to get response text after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i45: Failed to execute request");	
						if attempts > 3 {
							panic!("i45: Failed to execute request after 3 attempts");
						}
						continue;
					}
				}
			},
			Err(_) => {
				log::error!("i45: Failed to build request");	
				if attempts > 3 {
				
					panic!("i45: Failed to build request after 3 attempts");
				}
				continue;
			}
		}
	}
	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
		}
	}


    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            // //bitstamp calculations for sell
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is bitstamp and gemini being updated, I will update:
            //     //  56, 58, 64
            //     let indices = [56, 58, 64];
            //     let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i46_sol_6_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        //03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i46: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i46: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i46: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i46: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i46: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i46: gemini:  Couldn't build gemini request"),
			}
		
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 6 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

//03/02/24 - removed:	
	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
	// 		.header("X-Auth-Signature", bitstamp_signature)
	// 		.header("X-Auth-Nonce", bitstamp_nonce)
	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
	// 		.header("X-Auth-Version", "v2")
	// 		//.header("Content-Type", content_type)
	// 		//.body(payload_string)
	// 		.build()
	// 		.expect("\ncould not build bitstamp_request");

	// 	let bitstamp_response = client.execute(bitstamp_request).await
	// 		.expect("Failed to execute Bitstamp request");
	// 	let bitstamp_response_text = bitstamp_response.text().await
	// 		.expect("Failed to turn response into text");
	// 	//probably dont need "bitstamp" once we transfer this to the actual function
	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
	//     .expect("Failed to parse JSON");

	// // Extract the bid and ask values
	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
	//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	// 	//println!("Bitstamp:\n{:?}", bitstamp_response_text);

//03/02/24 - added:
	let mut success = false;
	let mut attempts = 0;
	let mut value_after: Option<f64> = None;

	while !success && attempts <=3 {
		attempts += 1;

		match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			.header("X-Auth-Signature", &bitstamp_signature)
			.header("X-Auth-Nonce", &bitstamp_nonce)
			.header("X-Auth-Timestamp", &bitstamp_timestamp)
			.header("X-Auth-Version", "v2")
			.build() {
			Ok(bitstamp_request) => {
				match client.execute(bitstamp_request).await {
					Ok(bitstamp_response) => {
						match bitstamp_response.text().await {
							Ok(bitstamp_response_text) => {
								match serde_json::from_str::<Value>(&bitstamp_response_text) {
									Ok(v) => {
										let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
										let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

										match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
											(Some(bid_str), Some(ask_str)) => {
												match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
													(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

														// Place your calculations and updates here

														//gemini calculations to buy
														let gemini_taker_fee = 0.004;
														let fraction_of_wallet_im_using = 0.06; //aka 6 percent
														let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
														let fee_for_purchase = total_spent*gemini_taker_fee;
														let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
														*gemini_wallet -= total_spent;

														let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask
																						.expect(&format!("gemini_buy_price_ask is somehow Not Some. 
																						even though to get to this point it had to be Some. 
																						gemini_buy_price_ask: {:?}
																						Honestly restart the program from the last saved state. 
																						The most likely error is a bit got flipped after the loop",
																						&gemini_buy_ask));

														//bitstamp calculations for sell

														let bitstamp_taker_fee = 0.004;
														let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
														let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
														let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
														*bitstamp_wallet += money_from_sell_after_fees;
														value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
														if let Some(mut value_after) = value_after {
															*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
															*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
															value_after = standardization_functions::normal_value_prior_standardization(&value_after);
															

															//value_after = 56
															//coinbase = 57
															//bitstamp = 58
															//kraken = 59
															//gemini = 60
															//since this is bitstamp and gemini being updated, I will update:
															//  56, 58, 60
															//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
															let indices = [56, 58, 60];
															let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
															//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															neural_network.update_input(&indices, &scaled_values).await;
														}
														//03/08/24 - removed:
														// //value_after = 56
														// //coinbase = 57
														// //bitstamp = 58
														// //kraken = 59
														// //gemini = 60
														// //since this is bitstamp and gemini being updated, I will update:
														// //  56, 58, 60
														// let indices = [56, 58, 60];
														// let new_values = [value_after, Some(*bitstamp_wallet), Some(*gemini_wallet)];
														// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
														// neural_network.update_input(&indices, &scaled_values).await;




														success = true;
													},
													_ => {
														log::error!("i46: Failed to parse bid or ask price as f64");
														if attempts > 3 {
															panic!("i46: Failed to parse bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											_ => {
												log::error!("i46: Failed to get bid or ask price");	
												if attempts > 3 {
													panic!("i46: Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i46: Failed to parse JSON as str");	
										if attempts > 3 {
											panic!("i46: Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i46: Failed to get response text");
								if attempts > 3 {
									panic!("i46: Failed to get response text after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i46: Failed to execute request");	
						if attempts > 3 {
							panic!("i46: Failed to execute request after 3 attempts");
						}
						continue;
					}
				}
			},
			Err(_) => {
				log::error!("i46: Failed to build request");	
				if attempts > 3 {
				
					panic!("i46: Failed to build request after 3 attempts");
				}
				continue;
			}
		}
	}
	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
		}
	}


    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            // //bitstamp calculations for sell
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is bitstamp and gemini being updated, I will update:
            //     //  56, 58, 64
            //     let indices = [56, 58, 64];
            //     let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i47_sol_7_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        //03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i47: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i47: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i47: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i47: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i47: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i47: gemini:  Couldn't build gemini request"),
			}
		
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 7 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

//03/02/24 - removed:	
	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
	// 		.header("X-Auth-Signature", bitstamp_signature)
	// 		.header("X-Auth-Nonce", bitstamp_nonce)
	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
	// 		.header("X-Auth-Version", "v2")
	// 		//.header("Content-Type", content_type)
	// 		//.body(payload_string)
	// 		.build()
	// 		.expect("\ncould not build bitstamp_request");

	// 	let bitstamp_response = client.execute(bitstamp_request).await
	// 		.expect("Failed to execute Bitstamp request");
	// 	let bitstamp_response_text = bitstamp_response.text().await
	// 		.expect("Failed to turn response into text");
	// 	//probably dont need "bitstamp" once we transfer this to the actual function
	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
	//     .expect("Failed to parse JSON");

	// // Extract the bid and ask values
	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
	//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	// 	//println!("Bitstamp:\n{:?}", bitstamp_response_text);

//03/02/24 - added:
	let mut success = false;
	let mut attempts = 0;
	let mut value_after: Option<f64> = None;

	while !success && attempts <= 3 {
		attempts += 1;

		match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			.header("X-Auth-Signature", &bitstamp_signature)
			.header("X-Auth-Nonce", &bitstamp_nonce)
			.header("X-Auth-Timestamp", &bitstamp_timestamp)
			.header("X-Auth-Version", "v2")
			.build() {
			Ok(bitstamp_request) => {
				match client.execute(bitstamp_request).await {
					Ok(bitstamp_response) => {
						match bitstamp_response.text().await {
							Ok(bitstamp_response_text) => {
								match serde_json::from_str::<Value>(&bitstamp_response_text) {
									Ok(v) => {
										let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
										let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

										match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
											(Some(bid_str), Some(ask_str)) => {
												match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
													(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

														// Place your calculations and updates here

														//gemini calculations to buy
														let gemini_taker_fee = 0.004;
														let fraction_of_wallet_im_using = 0.07; //aka 7 percent
														let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
														let fee_for_purchase = total_spent*gemini_taker_fee;
														let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
														*gemini_wallet -= total_spent;

														let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask
																						.expect(&format!("gemini_buy_price_ask is somehow Not Some. 
																						even though to get to this point it had to be Some. 
																						gemini_buy_price_ask: {:?}
																						Honestly restart the program from the last saved state. 
																						The most likely error is a bit got flipped after the loop",
																						&gemini_buy_ask));

														//bitstamp calculations for sell

														let bitstamp_taker_fee = 0.004;
														let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
														let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
														let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
														*bitstamp_wallet += money_from_sell_after_fees;
														value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
														if let Some(mut value_after) = value_after {
															*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
															*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
															value_after = standardization_functions::normal_value_prior_standardization(&value_after);
															

															//value_after = 56
															//coinbase = 57
															//bitstamp = 58
															//kraken = 59
															//gemini = 60
															//since this is bitstamp and gemini being updated, I will update:
															//  56, 58, 60
															//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
															let indices = [56, 58, 60];
															let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
															//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															neural_network.update_input(&indices, &scaled_values).await;
														}
														//03/08/24 - removed:
														// //value_after = 56
														// //coinbase = 57
														// //bitstamp = 58
														// //kraken = 59
														// //gemini = 60
														// //since this is bitstamp and gemini being updated, I will update:
														// //  56, 58, 60
														// let indices = [56, 58, 60];
														// let new_values = [value_after, Some(*bitstamp_wallet), Some(*gemini_wallet)];
														// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
														// neural_network.update_input(&indices, &scaled_values).await;




														success = true;
													},
													_ => {
														log::error!("i47: Failed to parse bid or ask price as f64");
														if attempts > 3 {
															panic!("i47: Failed to parse bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											_ => {
												log::error!("i47: Failed to get bid or ask price");	
												if attempts > 3 {
													panic!("i47: Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i47: Failed to parse JSON as str");	
										if attempts > 3 {
											panic!("i47: Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i47: Failed to get response text");
								if attempts > 3 {
									panic!("i47: Failed to get response text after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i47: Failed to execute request");	
						if attempts > 3 {
							panic!("i47: Failed to execute request after 3 attempts");
						}
						continue;
					}
				}
			},
			Err(_) => {
				log::error!("i47: Failed to build request");	
				if attempts > 3 {
				
					panic!("i47: Failed to build request after 3 attempts");
				}
				continue;
			}
		}
	}
	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
		}
	}


    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            // //bitstamp calculations for sell
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is bitstamp and gemini being updated, I will update:
            //     //  56, 58, 64
            //     let indices = [56, 58, 64];
            //     let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i48_sol_8_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        //03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i48: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i48: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i48: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i48: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i48: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i48: gemini:  Couldn't build gemini request"),
			}
		
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 8 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

//03/02/24 - removed:	
	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
	// 		.header("X-Auth-Signature", bitstamp_signature)
	// 		.header("X-Auth-Nonce", bitstamp_nonce)
	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
	// 		.header("X-Auth-Version", "v2")
	// 		//.header("Content-Type", content_type)
	// 		//.body(payload_string)
	// 		.build()
	// 		.expect("\ncould not build bitstamp_request");

	// 	let bitstamp_response = client.execute(bitstamp_request).await
	// 		.expect("Failed to execute Bitstamp request");
	// 	let bitstamp_response_text = bitstamp_response.text().await
	// 		.expect("Failed to turn response into text");
	// 	//probably dont need "bitstamp" once we transfer this to the actual function
	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
	//     .expect("Failed to parse JSON");

	// // Extract the bid and ask values
	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
	//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	// 	//println!("Bitstamp:\n{:?}", bitstamp_response_text);

//03/02/24 - added:
	let mut success = false;
	let mut attempts = 0;
	let mut value_after: Option<f64> = None;

	while !success && attempts <= 3 {
		attempts += 1;

		match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			.header("X-Auth-Signature", &bitstamp_signature)
			.header("X-Auth-Nonce", &bitstamp_nonce)
			.header("X-Auth-Timestamp", &bitstamp_timestamp)
			.header("X-Auth-Version", "v2")
			.build() {
			Ok(bitstamp_request) => {
				match client.execute(bitstamp_request).await {
					Ok(bitstamp_response) => {
						match bitstamp_response.text().await {
							Ok(bitstamp_response_text) => {
								match serde_json::from_str::<Value>(&bitstamp_response_text) {
									Ok(v) => {
										let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
										let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

										match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
											(Some(bid_str), Some(ask_str)) => {
												match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
													(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

														// Place your calculations and updates here

														//gemini calculations to buy
														let gemini_taker_fee = 0.004;
														let fraction_of_wallet_im_using = 0.08; //aka 8 percent
														let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
														let fee_for_purchase = total_spent*gemini_taker_fee;
														let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
														*gemini_wallet -= total_spent;

														let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask
																						.expect(&format!("gemini_buy_price_ask is somehow Not Some. 
																						even though to get to this point it had to be Some. 
																						gemini_buy_price_ask: {:?}
																						Honestly restart the program from the last saved state. 
																						The most likely error is a bit got flipped after the loop",
																						&gemini_buy_ask));

														//bitstamp calculations for sell

														let bitstamp_taker_fee = 0.004;
														let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
														let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
														let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
														*bitstamp_wallet += money_from_sell_after_fees;
														value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
														if let Some(mut value_after) = value_after {
															*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
															*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
															value_after = standardization_functions::normal_value_prior_standardization(&value_after);
															

															//value_after = 56
															//coinbase = 57
															//bitstamp = 58
															//kraken = 59
															//gemini = 60
															//since this is bitstamp and gemini being updated, I will update:
															//  56, 58, 60
															//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
															let indices = [56, 58, 60];
															let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
															//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															neural_network.update_input(&indices, &scaled_values).await;
														}
														//03/08/24 - removed:
														// //value_after = 56
														// //coinbase = 57
														// //bitstamp = 58
														// //kraken = 59
														// //gemini = 60
														// //since this is bitstamp and gemini being updated, I will update:
														// //  56, 58, 60
														// let indices = [56, 58, 60];
														// let new_values = [value_after, Some(*bitstamp_wallet), Some(*gemini_wallet)];
														// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
														// neural_network.update_input(&indices, &scaled_values).await;




														success = true;
													},
													_ => {
														log::error!("i48: Failed to parse bid or ask price as f64");
														if attempts > 3 {
															panic!("i48: Failed to parse bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											_ => {
												log::error!("i48: Failed to get bid or ask price");	
												if attempts > 3 {
													panic!("i48: Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i48: Failed to parse JSON as str");	
										if attempts > 3 {
											panic!("i48: Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i48: Failed to get response text");
								if attempts > 3 {
									panic!("i48: Failed to get response text after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i48: Failed to execute request");	
						if attempts > 3 {
							panic!("i48: Failed to execute request after 3 attempts");
						}
						continue;
					}
				}
			},
			Err(_) => {
				log::error!("i48: Failed to build request");	
				if attempts > 3 {
				
					panic!("i48: Failed to build request after 3 attempts");
				}
				continue;
			}
		}
	}
	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
		}
	}


    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            // //bitstamp calculations for sell
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is bitstamp and gemini being updated, I will update:
            //     //  56, 58, 64
            //     let indices = [56, 58, 64];
            //     let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i49_sol_9_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        //03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i49: Kraken: Failed to parse ask as f64"),
													}
												},
												None => log::error!("i49: Kraken: Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i49: Kraken: Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i49: Kraken: Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i49: Kraken: Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i49: Kraken: Couldn't build gemini request"),
			}
		
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 9 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

//03/02/24 - removed:	
	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
	// 		.header("X-Auth-Signature", bitstamp_signature)
	// 		.header("X-Auth-Nonce", bitstamp_nonce)
	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
	// 		.header("X-Auth-Version", "v2")
	// 		//.header("Content-Type", content_type)
	// 		//.body(payload_string)
	// 		.build()
	// 		.expect("\ncould not build bitstamp_request");

	// 	let bitstamp_response = client.execute(bitstamp_request).await
	// 		.expect("Failed to execute Bitstamp request");
	// 	let bitstamp_response_text = bitstamp_response.text().await
	// 		.expect("Failed to turn response into text");
	// 	//probably dont need "bitstamp" once we transfer this to the actual function
	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
	//     .expect("Failed to parse JSON");

	// // Extract the bid and ask values
	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
	//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	// 	//println!("Bitstamp:\n{:?}", bitstamp_response_text);

//03/02/24 - added:
	let mut success = false;
	let mut attempts = 0;
	let mut value_after: Option<f64> = None;

	while !success && attempts <= 3 {
		attempts += 1;

		match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			.header("X-Auth-Signature", &bitstamp_signature)
			.header("X-Auth-Nonce", &bitstamp_nonce)
			.header("X-Auth-Timestamp", &bitstamp_timestamp)
			.header("X-Auth-Version", "v2")
			.build() {
			Ok(bitstamp_request) => {
				match client.execute(bitstamp_request).await {
					Ok(bitstamp_response) => {
						match bitstamp_response.text().await {
							Ok(bitstamp_response_text) => {
								match serde_json::from_str::<Value>(&bitstamp_response_text) {
									Ok(v) => {
										let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
										let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

										match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
											(Some(bid_str), Some(ask_str)) => {
												match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
													(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

														// Place your calculations and updates here

														//gemini calculations to buy
														let gemini_taker_fee = 0.004;
														let fraction_of_wallet_im_using = 0.09; //aka 9 percent
														let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
														let fee_for_purchase = total_spent*gemini_taker_fee;
														let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
														*gemini_wallet -= total_spent;

														let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask
																						.expect(&format!("gemini_buy_price_ask is somehow Not Some. 
																						even though to get to this point it had to be Some. 
																						gemini_buy_price_ask: {:?}
																						Honestly restart the program from the last saved state. 
																						The most likely error is a bit got flipped after the loop",
																						&gemini_buy_ask));

														//bitstamp calculations for sell

														let bitstamp_taker_fee = 0.004;
														let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
														let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
														let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
														*bitstamp_wallet += money_from_sell_after_fees;
														value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
														if let Some(mut value_after) = value_after {
															*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
															*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
															value_after = standardization_functions::normal_value_prior_standardization(&value_after);
															

															//value_after = 56
															//coinbase = 57
															//bitstamp = 58
															//kraken = 59
															//gemini = 60
															//since this is bitstamp and gemini being updated, I will update:
															//  56, 58, 60
															//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
															let indices = [56, 58, 60];
															let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
															//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															neural_network.update_input(&indices, &scaled_values).await;
														}
														//03/08/24 - removed:
														// //value_after = 56
														// //coinbase = 57
														// //bitstamp = 58
														// //kraken = 59
														// //gemini = 60
														// //since this is bitstamp and gemini being updated, I will update:
														// //  56, 58, 60
														// let indices = [56, 58, 60];
														// let new_values = [value_after, Some(*bitstamp_wallet), Some(*gemini_wallet)];
														// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
														// neural_network.update_input(&indices, &scaled_values).await;




														success = true;
													},
													_ => {
														log::error!("i49: Failed to parse bid or ask price as f64");
														if attempts > 3 {
															panic!("i49: Failed to parse bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											_ => {
												log::error!("i49: Failed to get bid or ask price");	
												if attempts > 3 {
													panic!("i49: Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i49: Failed to parse JSON as str");	
										if attempts > 3 {
											panic!("i49: Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i49: Failed to get response text");
								if attempts > 3 {
									panic!("i49: Failed to get response text after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i49: Failed to execute request");	
						if attempts > 3 {
							panic!("i49: Failed to execute request after 3 attempts");
						}
						continue;
					}
				}
			},
			Err(_) => {
				log::error!("i49: Failed to build request");	
				if attempts > 3 {
				
					panic!("i49: Failed to build request after 3 attempts");
				}
				continue;
			}
		}
	}
	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
		}
	}


    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            // //bitstamp calculations for sell
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is bitstamp and gemini being updated, I will update:
            //     //  56, 58, 64
            //     let indices = [56, 58, 64];
            //     let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }

    pub async fn s_i50_sol_10_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //------------------------------Gemini-----------------------------------------//
        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/solusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        //03/02/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    

        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // println!("Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);

	//03/02/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i50: Kraken: Failed to parse ask as f64"),
													}
												},
												None => log::error!("i50: Kraken: Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i50: Kraken: Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i50: Kraken: Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i50: Kraken: Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i50: Kraken: Couldn't build gemini request"),
			}
		
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
            println!("sol 10 gemini bitstamp: 3 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(3);
            tokio::time::sleep_until(when).await;




    //------BITSTAMP------//
    type HmacSha256 = Hmac<Sha256>;
    fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";
	//if we needed content_type, it is here
	//let content_type = "application/json";
	//this is the bitstamp message IF we needed content_type
	//let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
	//	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








//--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

//03/02/24 - removed:	
	// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
	// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
	// 		.header("X-Auth-Signature", bitstamp_signature)
	// 		.header("X-Auth-Nonce", bitstamp_nonce)
	// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
	// 		.header("X-Auth-Version", "v2")
	// 		//.header("Content-Type", content_type)
	// 		//.body(payload_string)
	// 		.build()
	// 		.expect("\ncould not build bitstamp_request");

	// 	let bitstamp_response = client.execute(bitstamp_request).await
	// 		.expect("Failed to execute Bitstamp request");
	// 	let bitstamp_response_text = bitstamp_response.text().await
	// 		.expect("Failed to turn response into text");
	// 	//probably dont need "bitstamp" once we transfer this to the actual function
	//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
	//     .expect("Failed to parse JSON");

	// // Extract the bid and ask values
	//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
	//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
	//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
	// 	//println!("Bitstamp:\n{:?}", bitstamp_response_text);

//03/02/24 - added:
	let mut success = false;
	let mut attempts = 0;
	let mut value_after: Option<f64> = None;

	while !success && attempts <= 3 {
		attempts += 1;

		match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			.header("X-Auth-Signature", &bitstamp_signature)
			.header("X-Auth-Nonce", &bitstamp_nonce)
			.header("X-Auth-Timestamp", &bitstamp_timestamp)
			.header("X-Auth-Version", "v2")
			.build() {
			Ok(bitstamp_request) => {
				match client.execute(bitstamp_request).await {
					Ok(bitstamp_response) => {
						match bitstamp_response.text().await {
							Ok(bitstamp_response_text) => {
								match serde_json::from_str::<Value>(&bitstamp_response_text) {
									Ok(v) => {
										let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
										let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

										match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
											(Some(bid_str), Some(ask_str)) => {
												match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
													(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

														// Place your calculations and updates here

														//gemini calculations to buy
														let gemini_taker_fee = 0.004;
														let fraction_of_wallet_im_using = 0.10; //aka 10 percent
														let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
														let fee_for_purchase = total_spent*gemini_taker_fee;
														let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
														*gemini_wallet -= total_spent;

														let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask
																						.expect(&format!("gemini_buy_price_ask is somehow Not Some. 
																						even though to get to this point it had to be Some. 
																						gemini_buy_price_ask: {:?}
																						Honestly restart the program from the last saved state. 
																						The most likely error is a bit got flipped after the loop",
																						&gemini_buy_ask));

														//bitstamp calculations for sell

														let bitstamp_taker_fee = 0.004;
														let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
														let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
														let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
														*bitstamp_wallet += money_from_sell_after_fees;
														value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
														if let Some(mut value_after) = value_after {
															*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
															*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
															value_after = standardization_functions::normal_value_prior_standardization(&value_after);
															

															//value_after = 56
															//coinbase = 57
															//bitstamp = 58
															//kraken = 59
															//gemini = 60
															//since this is bitstamp and gemini being updated, I will update:
															//  56, 58, 60
															//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
															let indices = [56, 58, 60];
															let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
															//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															neural_network.update_input(&indices, &scaled_values).await;
														}
														//03/08/24 - removed:
														// //value_after = 56
														// //coinbase = 57
														// //bitstamp = 58
														// //kraken = 59
														// //gemini = 60
														// //since this is bitstamp and gemini being updated, I will update:
														// //  56, 58, 60
														// let indices = [56, 58, 60];
														// let new_values = [value_after, Some(*bitstamp_wallet), Some(*gemini_wallet)];
														// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
														// neural_network.update_input(&indices, &scaled_values).await;




														success = true;
													},
													_ => {
														log::error!("i50: Failed to parse bid or ask price as f64");
														if attempts > 3 {
															panic!("i50: Failed to parse bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											_ => {
												log::error!("i50: Failed to get bid or ask price");	
												if attempts > 3 {
													panic!("i50: Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i50: Failed to parse JSON as str");	
										if attempts > 3 {
											panic!("i50: Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i50: Failed to get response text");
								if attempts > 3 {
									panic!("i50: Failed to get response text after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i50: Failed to execute request");	
						if attempts > 3 {
							panic!("i50: Failed to execute request after 3 attempts");
						}
						continue;
					}
				}
			},
			Err(_) => {
				log::error!("i50: Failed to build request");	
				if attempts > 3 {
				
					panic!("i50: Failed to build request after 3 attempts");
				}
				continue;
			}
		}
	}
	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
		}
	}


    
    
    
    
    
    
    
    
    
    
    
		//03/02/24 - removed:
            // //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.03;

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
    
    


            // //bitstamp calculations for sell
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;
    

            // //coinbase calculations for sell

            //     //let coinbase_taker_fee = 0.008;
            //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            // //coinbase calculations for buy - not needed in this so code commented out
            
            //     //let coinbase_taker_fee = 0.008;
    
            //     //let total_spent = 0.10*(*coinbase_wallet);
            //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //     ////new state of coinbase wallet below
            //     //coinbase_wallet -= total_spent;
            //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
    
            // //kraken calculations - for sell
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations - for sell
            //     //let bitstamp_taker_fee = 0.004;
            //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     //bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
            //     //println!("value after:\n\t{}",value_after);
    

            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is bitstamp and gemini being updated, I will update:
            //     //  56, 58, 64
            //     let indices = [56, 58, 64];
            //     let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;

    
            //     return Ok(value_after)

    }
    //end removal//
    //cant use 1 through 4 because minimum Kraken buy is 0.2 SOL
    /*
    pub async fn s_i51_sol_1_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.01;  //aka 1 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol = money_going_to_sol_after_fees/kraken_buy_price_ask;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);

            return Ok(value_after)

     }

     pub async fn s_i52_sol_2_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.02;  //aka 2 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol = money_going_to_sol_after_fees/kraken_buy_price_ask;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);

            return Ok(value_after)

     }

     pub async fn s_i53_sol_3_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.03;  //aka 3 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol = money_going_to_sol_after_fees/kraken_buy_price_ask;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);

            return Ok(value_after)

     }

     pub async fn s_i54_sol_4_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build()?;
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};

        let response = client.execute(request).await?;
        //let response = match response {
        //    Ok(resp) => resp,
        //    Err(e) => {
        //        eprintln!("Failed to execute request: \n{}", e);
        //        return Err(e);
        //    }
        //};


        let response_text = response.text().await?;

        //added 12/29/23
        //this is the parsing
        let v: Value = serde_json::from_str(&response_text)?;
        let mut coinbase_sell_price = 0.0;
        let mut coinbase_buy_price = 0.0;

        // Access the pricebooks array
        if let Some(pricebooks) = v["pricebooks"].as_array() {
            // Iterate over each pricebook
            for pricebook in pricebooks {
                // Access the product_id, bids, and asks
                let product_id = pricebook["product_id"].as_str().unwrap_or("");
                let bids = &pricebook["bids"][0];
                let asks = &pricebook["asks"][0];
        
                // Access the price and size of the bids and asks
                coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
                let bid_size = bids["size"].as_str().unwrap_or("size not found");
                coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
                let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
                println!("Product ID: {}", product_id);
                //println!("Best bid: {} (size: {})", bid_price, bid_size);
                //println!("Best ask: {} (size: {})", ask_price, ask_size);
            }
        }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;








        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol = money_going_to_sol_after_fees/kraken_buy_price_ask;

            


        //coinbase calculations for sell

            let coinbase_taker_fee = 0.008;
            let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *coinbase_wallet += money_from_sell_after_fees;




        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
            println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);

            return Ok(value_after)

     }
     */
    pub async fn s_i55_sol_5_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs

		//03/02/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);


		//03/02/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut coinbase_sell_price = 0.0;
        // let mut coinbase_buy_price = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
        //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
        //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
        //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
        //         println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
        //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);

	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


	//03/02/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
				loop {
					attempts += 1;
					let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
		
					match kraken_basic_request {
						Ok(request) => {
							match client.execute(request).await {
								Ok(response) => {
									match response.text().await {
										Ok(kraken_response_text) => {
											match serde_json::from_str::<Value>(&kraken_response_text) {
												Ok(value) => {
													if let Some(solusd) = value["result"]["SOLUSD"].as_object() {
		
														match solusd["a"][0].as_str() {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask) => {
																		kraken_buy_price_ask = Some(ask);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																	},
																	Err(e) => log::error!("i55: Kraken: Failed to parse ask or bid as f64
                                                                    response text: {}
                                                                    error: {}", &kraken_response_text, e),
																}
															},
															None => log::error!("i55: Kraken: Failed to get ask or bid as string
                                                            response text: {}", &kraken_response_text),
														}										
													}
													else {
														log::error!("i55: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
													}
												},
												Err(e) => log::error!("i55: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
											}
										},
										Err(e) => log::error!("i55: Kraken: Failed to read response text. Error was: {}", e),
									}
								},
								Err(e) => log::error!("i55: Kraken: Failed to execute Kraken request. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i55: Kraken: Failed to build kraken request. Error was: {}", e),
					}
					if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
						break; // Exit the loop if everything is successful
					}
                    log::error!("10secwait");
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					attempts += 1;
					if attempts >= 3 {
						panic!("Failed after 3 attempts");
					}
				}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 5 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();

		//03/02/24 - removed:
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);

        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }

        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     //println!("Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }




	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		//let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);

																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.05; //aka 5 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_sol_before_withdraw_fee = 
																			money_going_to_sol_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling after putted scaled values in network
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is kraken and coinbase being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is kraken and coinbase being updated, I will update:
																		// //  56, 57, 59
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;
                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i55: failed to parse JSON to f64. Response text: {}
                                                                    error: {}", text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
                                                                    //03/20/24 - dont see point in having all these continues
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i55: Failed to get bid. Response text: {}", text);
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i55: failed to parse JSON as str. Response text: {}
                                            error: {}", text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											//continue ; 
										}
									}
								},
								Err(e) => {
									log::error!("i55: failed to get response text. error: {}", e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									//continue ; 
								}
							}
						},
						Err(e) => {
							log::error!("i55: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i55: Failed to build request. error: {}", e);
					if attempts > 3 {
						panic!("i55: Failed to build request after 3 attempts");
					}
					//continue; 
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }













		//03/02/24 - removed:
        // //println!("response:\n{:?}", kraken_response_text);
        // //coinbase calculations - to buy
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.01*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     //new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_sol_after_fees;
        //     let amount_of_sol_before_withdraw_fee = 
        //                     money_going_to_sol_after_fees/kraken_buy_price_ask;
        //     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        // //coinbase calculations for sell

        //     let coinbase_taker_fee = 0.008;
        //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *coinbase_wallet += money_from_sell_after_fees;




        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        //     //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is coinbase and kraken being updated, I will update:
        //         //  56, 57, 59
        //         let indices = [56, 57, 59];
        //         let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

            
        //     return Ok(value_after)

     }

	 pub async fn s_i56_sol_6_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs

		//03/02/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);


		//03/02/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut coinbase_sell_price = 0.0;
        // let mut coinbase_buy_price = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
        //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
        //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
        //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
        //         println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
        //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);

	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


	//03/02/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
				loop {
					attempts += 1;
					let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
		
					match kraken_basic_request {
						Ok(request) => {
							match client.execute(request).await {
								Ok(response) => {
									match response.text().await {
										Ok(kraken_response_text) => {
											match serde_json::from_str::<Value>(&kraken_response_text) {
												Ok(value) => {
													if let Some(solusd) = value["result"]["SOLUSD"].as_object() {
		
														match solusd["a"][0].as_str() {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask) => {
																		kraken_buy_price_ask = Some(ask);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																	},
																	Err(e) => log::error!("i56: Kraken: Failed to parse ask or bid as f64
                                                                    response text: {}
                                                                    error: {}", &kraken_response_text, e),
																}
															},
															None => log::error!("i56: Kraken: Failed to get ask or bid as string
                                                            response text: {}", &kraken_response_text),
														}									
													}
													else {
														log::error!("i56: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
													}
												},
												Err(e) => log::error!("i56: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
											}
										},
										Err(e) => log::error!("i56: Kraken: Failed to read response text. Error was: {}", e),
									}
								},
								Err(e) => log::error!("i56: Kraken: Failed to execute Kraken request. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i56: Kraken: Failed to build kraken request. Error was: {}", e),
					}
					if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
						break; // Exit the loop if everything is successful
					}
                    log::error!("10secwait");
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					attempts += 1;
					if attempts >= 3 {
						panic!("Failed after 3 attempts");
					}
				}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 6 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();

		//03/02/24 - removed:
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);

        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }

        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     //println!("Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }




	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);

																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.06; //aka 6 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_sol_before_withdraw_fee = 
																			money_going_to_sol_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling after putted scaled values in network
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is kraken and coinbase being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is kraken and coinbase being updated, I will update:
																		// //  56, 57, 59
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;
                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i56: failed to parse JSON to f64. Response text: {}
                                                                    error: {}", text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
                                                                    //03/20/24 - dont see point in having all these continues
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i56: Failed to get bid. Response text: {}", text);
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i56: failed to parse JSON as str. Response text: {}
                                            error: {}", text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											//continue ; 
										}
									}
								},
								Err(e) => {
									log::error!("i56: failed to get response text. error: {}", e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									//continue ; 
								}
							}
						},
						Err(e) => {
							log::error!("i56: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i56: Failed to build request. error: {}", e);
					if attempts > 3 {
						panic!("i55: Failed to build request after 3 attempts");
					}
					//continue; 
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }













		//03/02/24 - removed:
        // //println!("response:\n{:?}", kraken_response_text);
        // //coinbase calculations - to buy
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.01*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     //new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_sol_after_fees;
        //     let amount_of_sol_before_withdraw_fee = 
        //                     money_going_to_sol_after_fees/kraken_buy_price_ask;
        //     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        // //coinbase calculations for sell

        //     let coinbase_taker_fee = 0.008;
        //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *coinbase_wallet += money_from_sell_after_fees;




        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        //     //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is coinbase and kraken being updated, I will update:
        //         //  56, 57, 59
        //         let indices = [56, 57, 59];
        //         let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

            
        //     return Ok(value_after)

     }

	 pub async fn s_i57_sol_7_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs

		//03/02/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);


		//03/02/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut coinbase_sell_price = 0.0;
        // let mut coinbase_buy_price = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
        //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
        //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
        //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
        //         println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
        //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);

	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


	//03/02/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
				loop {
					attempts += 1;
					let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
		
					match kraken_basic_request {
						Ok(request) => {
							match client.execute(request).await {
								Ok(response) => {
									match response.text().await {
										Ok(kraken_response_text) => {
											match serde_json::from_str::<Value>(&kraken_response_text) {
												Ok(value) => {
													if let Some(solusd) = value["result"]["SOLUSD"].as_object() {
		
														match solusd["a"][0].as_str() {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask) => {
																		kraken_buy_price_ask = Some(ask);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																	},
																	Err(e) => log::error!("i57: Kraken: Failed to parse ask or bid as f64
                                                                    response text: {}
                                                                    error: {}", &kraken_response_text, e),
																}
															},
															None => log::error!("i57: Kraken: Failed to get ask or bid as string
                                                            response text: {}", &kraken_response_text),
														}									
													}
													else {
														log::error!("i57: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
													}
												},
												Err(e) => log::error!("i57: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
											}
										},
										Err(e) => log::error!("i57: Kraken: Failed to read response text. Error was: {}", e),
									}
								},
								Err(e) => log::error!("i57: Kraken: Failed to execute Kraken request. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i57: Kraken: Failed to build kraken request. Error was: {}", e),
					}
					if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
						break; // Exit the loop if everything is successful
					}
                    log::error!("10secwait");
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					attempts += 1;
					if attempts >= 3 {
						panic!("Failed after 3 attempts");
					}
				}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 7 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();

		//03/02/24 - removed:
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);

        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }

        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     //println!("Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }




	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);

																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.07; //aka 7 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_sol_before_withdraw_fee = 
																			money_going_to_sol_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling after putted scaled values in network
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is kraken and coinbase being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is kraken and coinbase being updated, I will update:
																		// //  56, 57, 59
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;
                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i57: failed to parse JSON to f64. Response text: {}
                                                                    error: {}", text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
                                                                    //03/20/24 - dont see point in having all these continues
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i57: Failed to get bid. Response text: {}", text);
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i57: failed to parse JSON as str. Response text: {}
                                            error: {}", text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											//continue ; 
										}
									}
								},
								Err(e) => {
									log::error!("i57: failed to get response text. error: {}", e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									//continue ; 
								}
							}
						},
						Err(e) => {
							log::error!("i57: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i57: Failed to build request. error: {}", e);
					if attempts > 3 {
						panic!("i55: Failed to build request after 3 attempts");
					}
					//continue; 
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }













		//03/02/24 - removed:
        // //println!("response:\n{:?}", kraken_response_text);
        // //coinbase calculations - to buy
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.01*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     //new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_sol_after_fees;
        //     let amount_of_sol_before_withdraw_fee = 
        //                     money_going_to_sol_after_fees/kraken_buy_price_ask;
        //     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        // //coinbase calculations for sell

        //     let coinbase_taker_fee = 0.008;
        //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *coinbase_wallet += money_from_sell_after_fees;




        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        //     //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is coinbase and kraken being updated, I will update:
        //         //  56, 57, 59
        //         let indices = [56, 57, 59];
        //         let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

            
        //     return Ok(value_after)

     }

	 pub async fn s_i58_sol_8_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs

		//03/02/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);


		//03/02/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut coinbase_sell_price = 0.0;
        // let mut coinbase_buy_price = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
        //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
        //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
        //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
        //         println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
        //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);

	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


	//03/02/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
				loop {
					attempts += 1;
					let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
		
					match kraken_basic_request {
						Ok(request) => {
							match client.execute(request).await {
								Ok(response) => {
									match response.text().await {
										Ok(kraken_response_text) => {
											match serde_json::from_str::<Value>(&kraken_response_text) {
												Ok(value) => {
													if let Some(solusd) = value["result"]["SOLUSD"].as_object() {
		
														match solusd["a"][0].as_str() {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask) => {
																		kraken_buy_price_ask = Some(ask);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																	},
																	Err(e) => log::error!("i58: Kraken: Failed to parse ask or bid as f64
                                                                    response text: {}
                                                                    error: {}", &kraken_response_text, e),
																}
															},
															None => log::error!("i58: Kraken: Failed to get ask or bid as string
                                                            response text: {}", &kraken_response_text),
														}									
													}
													else {
														log::error!("i58: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
													}
												},
												Err(e) => log::error!("i58: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
											}
										},
										Err(e) => log::error!("i58: Kraken: Failed to read response text. Error was: {}", e),
									}
								},
								Err(e) => log::error!("i58: Kraken: Failed to execute Kraken request. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i58: Kraken: Failed to build kraken request. Error was: {}", e),
					}
					if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
						break; // Exit the loop if everything is successful
					}
                    log::error!("10secwait");
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					attempts += 1;
					if attempts >= 3 {
						panic!("Failed after 3 attempts");
					}
				}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 8 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();

		//03/02/24 - removed:
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);

        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }

        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     //println!("Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }




	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);

																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.08; //aka 8 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_sol_before_withdraw_fee = 
																			money_going_to_sol_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling after putted scaled values in network
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is kraken and coinbase being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is kraken and coinbase being updated, I will update:
																		// //  56, 57, 59
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;
                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i58: failed to parse JSON to f64. Response text: {}
                                                                    error: {}", text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
                                                                    //03/20/24 - dont see point in having all these continues
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i58: Failed to get bid. Response text: {}", text);
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i58: failed to parse JSON as str. Response text: {}
                                            error: {}", text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											//continue ; 
										}
									}
								},
								Err(e) => {
									log::error!("i58: failed to get response text. error: {}", e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									//continue ; 
								}
							}
						},
						Err(e) => {
							log::error!("i58: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i58: Failed to build request. error: {}", e);
					if attempts > 3 {
						panic!("i58: Failed to build request after 3 attempts");
					}
					//continue; 
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }













		//03/02/24 - removed:
        // //println!("response:\n{:?}", kraken_response_text);
        // //coinbase calculations - to buy
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.01*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     //new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_sol_after_fees;
        //     let amount_of_sol_before_withdraw_fee = 
        //                     money_going_to_sol_after_fees/kraken_buy_price_ask;
        //     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        // //coinbase calculations for sell

        //     let coinbase_taker_fee = 0.008;
        //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *coinbase_wallet += money_from_sell_after_fees;




        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        //     //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is coinbase and kraken being updated, I will update:
        //         //  56, 57, 59
        //         let indices = [56, 57, 59];
        //         let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

            
        //     return Ok(value_after)

     }

	 pub async fn s_i59_sol_9_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs

		//03/02/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);


		//03/02/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut coinbase_sell_price = 0.0;
        // let mut coinbase_buy_price = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
        //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
        //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
        //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
        //         println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
        //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);

	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


	//03/02/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
				loop {
					attempts += 1;
					let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
		
					match kraken_basic_request {
						Ok(request) => {
							match client.execute(request).await {
								Ok(response) => {
									match response.text().await {
										Ok(kraken_response_text) => {
											match serde_json::from_str::<Value>(&kraken_response_text) {
												Ok(value) => {
													if let Some(solusd) = value["result"]["SOLUSD"].as_object() {
		
														match solusd["a"][0].as_str() {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask) => {
																		kraken_buy_price_ask = Some(ask);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																	},
																	Err(e) => log::error!("i59: Kraken: Failed to parse ask or bid as f64
                                                                    response text: {}
                                                                    error: {}", &kraken_response_text, e),
																}
															},
															None => log::error!("i59: Kraken: Failed to get ask or bid as string
                                                            response text: {}", &kraken_response_text),
														}									
													}
													else {
														log::error!("i59: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
													}
												},
												Err(e) => log::error!("i59: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
											}
										},
										Err(e) => log::error!("i59: Kraken: Failed to read response text. Error was: {}", e),
									}
								},
								Err(e) => log::error!("i59: Kraken: Failed to execute Kraken request. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i59: Kraken: Failed to build kraken request. Error was: {}", e),
					}
					if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
						break; // Exit the loop if everything is successful
					}
                    log::error!("10secwait");
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					attempts += 1;
					if attempts >= 3 {
						panic!("Failed after 3 attempts");
					}
				}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 9 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();

		//03/02/24 - removed:
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);

        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }

        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     //println!("Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }




	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);

																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.09; //aka 9 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_sol_before_withdraw_fee = 
																			money_going_to_sol_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling after putted scaled values in network
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is kraken and coinbase being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is kraken and coinbase being updated, I will update:
																		// //  56, 57, 59
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;
                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i59: failed to parse JSON to f64. Response text: {}
                                                                    error: {}", text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
                                                                    //03/20/24 - dont see point in having all these continues
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i59: Failed to get bid. Response text: {}", text);
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i59: failed to parse JSON as str. Response text: {}
                                            error: {}", text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											//continue ; 
										}
									}
								},
								Err(e) => {
									log::error!("i59: failed to get response text. error: {}", e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									//continue ; 
								}
							}
						},
						Err(e) => {
							log::error!("i59: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i59: Failed to build request. error: {}", e);
					if attempts > 3 {
						panic!("i59: Failed to build request after 3 attempts");
					}
					//continue; 
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }













		//03/02/24 - removed:
        // //println!("response:\n{:?}", kraken_response_text);
        // //coinbase calculations - to buy
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.01*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     //new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_sol_after_fees;
        //     let amount_of_sol_before_withdraw_fee = 
        //                     money_going_to_sol_after_fees/kraken_buy_price_ask;
        //     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        // //coinbase calculations for sell

        //     let coinbase_taker_fee = 0.008;
        //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *coinbase_wallet += money_from_sell_after_fees;




        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        //     //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is coinbase and kraken being updated, I will update:
        //         //  56, 57, 59
        //         let indices = [56, 57, 59];
        //         let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

            
        //     return Ok(value_after)

     }

	pub async fn s_i60_sol_10_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs

		//03/02/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);


		//03/02/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut coinbase_sell_price = 0.0;
        // let mut coinbase_buy_price = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().unwrap_or("");
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
        //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
        //         coinbase_buy_price = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
        //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
        
        //         println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", bid_price, bid_size);
        //         //println!("Best ask: {} (size: {})", ask_price, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);

	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


	//03/02/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
				loop {
					attempts += 1;
					let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
		
					match kraken_basic_request {
						Ok(request) => {
							match client.execute(request).await {
								Ok(response) => {
									match response.text().await {
										Ok(kraken_response_text) => {
											match serde_json::from_str::<Value>(&kraken_response_text) {
												Ok(value) => {
													if let Some(solusd) = value["result"]["SOLUSD"].as_object() {
		
														match solusd["a"][0].as_str() {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask) => {
																		kraken_buy_price_ask = Some(ask);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																	},
																	Err(e) => log::error!("i60: Kraken: Failed to parse ask or bid as f64
                                                                    response text: {}
                                                                    error: {}", &kraken_response_text, e),
																}
															},
															None => log::error!("i60: Kraken: Failed to get ask or bid as string
                                                            response text: {}", &kraken_response_text),
														}									
													}
													else {
														log::error!("i60: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
													}
												},
												Err(e) => log::error!("i60: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
											}
										},
										Err(e) => log::error!("i60: Kraken: Failed to read response text. Error was: {}", e),
									}
								},
								Err(e) => log::error!("i60: Kraken: Failed to execute Kraken request. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i60: Kraken: Failed to build kraken request. Error was: {}", e),
					}
					if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
						break; // Exit the loop if everything is successful
					}
                    log::error!("10secwait");
                    let when = tokio::time::Instant::now() +
                        tokio::time::Duration::from_secs(10);
                    tokio::time::sleep_until(when).await;
					attempts += 1;
					if attempts >= 3 {
						panic!("Failed after 3 attempts");
					}
				}









        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("sol 10 kraken coinbase: 3 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(3);
                tokio::time::sleep_until(when).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();

		//03/02/24 - removed:
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);

        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }

        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     //println!("Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }




	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=SOL-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);

																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.10; //aka 10 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_sol_before_withdraw_fee = 
																			money_going_to_sol_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling after putted scaled values in network
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is kraken and coinbase being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is kraken and coinbase being updated, I will update:
																		// //  56, 57, 59
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;
                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i60: failed to parse JSON to f64. Response text: {}
                                                                    error: {}", text, e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
                                                                    //03/20/24 - dont see point in having all these continues
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i60: Failed to get bid. Response text: {}", text);
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i60: failed to parse JSON as str. Response text: {}
                                            error: {}", text, e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											//continue ; 
										}
									}
								},
								Err(e) => {
									log::error!("i60: failed to get response text. error: {}", e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									//continue ; 
								}
							}
						},
						Err(e) => {
							log::error!("i60: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i60: Failed to build request. error: {}", e);
					if attempts > 3 {
						panic!("i60: Failed to build request after 3 attempts");
					}
					//continue; 
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }













		//03/02/24 - removed:
        // //println!("response:\n{:?}", kraken_response_text);
        // //coinbase calculations - to buy
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.01*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     //new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_sol_after_fees;
        //     let amount_of_sol_before_withdraw_fee = 
        //                     money_going_to_sol_after_fees/kraken_buy_price_ask;
        //     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        // //coinbase calculations for sell

        //     let coinbase_taker_fee = 0.008;
        //     let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *coinbase_wallet += money_from_sell_after_fees;




        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        //     //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is coinbase and kraken being updated, I will update:
        //         //  56, 57, 59
        //         let indices = [56, 57, 59];
        //         let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

            
        //     return Ok(value_after)

     }
     //cant use 1 through 4 because minimum Kraken buy is 0.2 SOL
     /*
     pub async fn s_i57_sol_1_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();














        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.01;  //aka 1 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);

            return Ok(value_after)

    }

    pub async fn s_i58_sol_2_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.02;  //aka 2 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);

            return Ok(value_after)

    }

    pub async fn s_i59_sol_3_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.03;  //aka 3 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);

            return Ok(value_after)

    }

    pub async fn s_i64_sol_4_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str )-> Result<f64, Box<dyn Error>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


        let now = Utc::now();
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        
    
        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
    
    
    
    
    
    
    
    //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
    
    
    
        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
    
        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
    
        let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
            .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            .header("X-Auth-Signature", bitstamp_signature)
            .header("X-Auth-Nonce", bitstamp_nonce)
            .header("X-Auth-Timestamp", bitstamp_timestamp)
            .header("X-Auth-Version", "v2")
            //.header("Content-Type", content_type)
            //.body(payload_string)
            .build()
            .expect("\ncould not build bitstamp_request");
    
        let bitstamp_response = client.execute(bitstamp_request).await
            .expect("Failed to execute Bitstamp request");
        let bitstamp_response_text = bitstamp_response.text().await
            .expect("Failed to turn response into text");
        //probably dont need "bitstamp" once we transfer this to the actual function
        let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        .expect("Failed to parse JSON");
    
    // Extract the bid and ask values
        let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();












        //serves as transaction time
        delay_for(Duration::from_secs(3)).await;







        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        //		let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=SOLUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);


        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }


        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
                .header("API-Key", kraken_api_key)
                .header("API-Sign", &kraken_signature)
                .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                .body(format!("nonce={}", nonce))
                .build()
                .expect("Failed to build kraken request");


        let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");

        let v: Value = serde_json::from_str(&kraken_response_text)?;
        let mut kraken_buy_price_ask = 0.0;
        let mut kraken_sell_price_bid = 0.0;
        if let Some(solusd) = v["result"]["SOLUSD"].as_object() {
            // Access the ask and bid prices
            kraken_buy_price_ask = solusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            kraken_sell_price_bid = solusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
            //println!("Ask price: {}", kraken_buy_price_ask);
            //println!("Bid price: {}", kraken_sell_price_bid );
        }
        else {
            println!("didnt parse kraken correctly.");
        }

        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        //kraken calculations - buy
            let kraken_taker_fee = 0.0026;
            let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
            let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
            let fee_for_purchase = total_spent*kraken_taker_fee;
            let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            *kraken_wallet -= money_going_to_sol_after_fees;
            let amount_of_sol_before_withdraw_fee = 
                            money_going_to_sol_after_fees/kraken_buy_price_ask;
            let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

            


        //coinbase calculations for sell

            //let coinbase_taker_fee = 0.008;
            //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
            //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //coinbase_wallet += money_from_sell_after_fees;

        //bitstamp calculations for sell
            let bitstamp_taker_fee = 0.004;
            let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            *bitstamp_wallet += money_from_sell_after_fees;


        //this will count as value after
            let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
            println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);

            return Ok(value_after)

    }
    */
    //begin removal
	//DO NOT USE SOL BITSTAMP
    pub async fn s_i65_sol_5_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


		//03/02/24 - removed:
			//     let now = Utc::now();
			//     type HmacSha256 = Hmac<Sha256>;
			//     fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
			//         let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			//             .expect("HMAC can take key of any size");
			//         mac.update(bitstamp_message.as_bytes());
			//         let result = mac.finalize();
			//         let code_bytes = result.into_bytes();
			//         hex::encode(code_bytes)
			//     }
				
			
			//     let content_type = "application/x-www-form-urlencoded";
			//     let payload_string = "offset=1";
			//     //if we needed content_type, it is here
			//     //let content_type = "application/json";
			//     //this is the bitstamp message IF we needed content_type
			//     //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
			//     //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			
			
			
			
			
			
			
			// //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
			
			
			
			//     let the_uuid = Uuid::new_v4();
			//     let bitstamp_nonce = the_uuid.to_string();
			//     let bitstamp_timestamp = now.timestamp_millis().to_string();
			//     //let content_type = "application/x-www-form-urlencoded";
			//     let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			//             bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			//     let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
			
			//     let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			//         .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			//         .header("X-Auth-Signature", bitstamp_signature)
			//         .header("X-Auth-Nonce", bitstamp_nonce)
			//         .header("X-Auth-Timestamp", bitstamp_timestamp)
			//         .header("X-Auth-Version", "v2")
			//         //.header("Content-Type", content_type)
			//         //.body(payload_string)
			//         .build()
			//         .expect("\ncould not build bitstamp_request");
			
			//     let bitstamp_response = client.execute(bitstamp_request).await
			//         .expect("Failed to execute Bitstamp request");
			//     let bitstamp_response_text = bitstamp_response.text().await
			//         .expect("Failed to turn response into text");
			//     //probably dont need "bitstamp" once we transfer this to the actual function
			//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
			//     .expect("Failed to parse JSON");
			
			// // Extract the bid and ask values
			//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
			//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
			//03/02/24 - removed:
                // println!("sol 5 kraken bitstamp: 3 sec delay");
                // let when = tokio::time::Instant::now() + Duration::from_secs(3);
                // tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        //returns current time. MAY NEED TO USE LOCAL TIME
		
		//03/02/24 - removed:
        // let now = Utc::now();
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);


        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }


        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request


	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
		let data = vec![
			("nonce", &nonce),
			// Add more parameters as needed
		];
		//let post_data: String = form_urlencoded::Serializer::new(String::new())
		//    .extend_pairs(data)
		//    .finish();

		let url_path = "/0/public/Ticker?pair=SOLUSD";
		//let message = format!("{}{}{}", url_path, nonce, post_data);


		fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
		-> String {
			// Create the post data
			let post_data: String = form_urlencoded::Serializer::new(String::new())
				.extend_pairs(data)
				.finish();
			//FOR DEBUGGING
			//println!("Private key:\n{}", secret);
			//println!("Nonce:\n{}", nonce_str);
			//println!("Encoded payload:\n{}", post_data);
			//println!("URI Path:\n{}", url_path);

			// Create the encoded string (nonce + post data) and hash it
			let encoded = format!("{}{}", nonce_str, post_data);
			let mut hasher = sha2::Sha256::new();
			hasher.update(encoded);
			let encoded_hash = hasher.finalize();

			// Create the message (url_path + encoded_hash as bytes)
			let mut message = url_path.as_bytes().to_vec();
			message.extend_from_slice(&encoded_hash);

			// Create a HMAC-SHA512 object with the base64-decoded secret
			let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
			let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
				.expect("HMAC can take key of any size");

			// Compute the HMAC of the message
			mac.update(&message);
			let result = mac.finalize();

			// Return the base64-encoded HMAC
			let signature = base64::encode(result.into_bytes());
			//println!("Kraken signature:\n{}", signature);

			signature
		}


		let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


		//03/02/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

													match (solusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);
																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i65: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i65: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i65: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i65: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i65: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i65: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i65: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			println!("sol 5 kraken bitstamp: 3 sec delay");
			let when = tokio::time::Instant::now() + Duration::from_secs(3);
			tokio::time::sleep_until(when).await;















		//03/02/24 - added:
			type HmacSha256 = Hmac<Sha256>;
			fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
				let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
					.expect("HMAC can take key of any size");
				mac.update(bitstamp_message.as_bytes());
				let result = mac.finalize();
				let code_bytes = result.into_bytes();
				hex::encode(code_bytes)
			}
			
		
			let content_type = "application/x-www-form-urlencoded";
			let payload_string = "offset=1";		
			let the_uuid = Uuid::new_v4();
			let bitstamp_nonce = the_uuid.to_string();
			let bitstamp_timestamp = now.timestamp_millis().to_string();
			//let content_type = "application/x-www-form-urlencoded";
			let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
					bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
		
			let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
				

				let mut success = false;
				let mut attempts = 0;
				let mut value_after: Option<f64> = None;
		
				while !success && attempts <=3 {
					attempts += 1;
		
					match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
						.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
						.header("X-Auth-Signature", &bitstamp_signature)
						.header("X-Auth-Nonce", &bitstamp_nonce)
						.header("X-Auth-Timestamp", &bitstamp_timestamp)
						.header("X-Auth-Version", "v2")
						.build() {
						Ok(bitstamp_request) => {
							match client.execute(bitstamp_request).await {
								Ok(bitstamp_response) => {
									match bitstamp_response.text().await {
										Ok(bitstamp_response_text) => {
											match serde_json::from_str::<Value>(&bitstamp_response_text) {
												Ok(v) => {
													let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
													let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
		
													match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
														(Some(bid_str), Some(ask_str)) => {
															match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
																(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																	
																	// Place your calculations and updates here
																	let kraken_taker_fee = 0.0026;
																	let fraction_of_wallet_im_using = 0.05; //aka 5 percent
																	let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																	let fee_for_purchase = total_spent*kraken_taker_fee;
																	let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																	//03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;

																	let amount_of_sol_before_withdraw_fee = 
																		money_going_to_sol_after_fees/kraken_buy_price_ask
																									.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																									even though to get to this point it had to be Some. 
																									kraken_buy_price_ask: {:?}
																									Honestly restart the program from the last saved state. 
																									The most likely error is a bit got flipped after the loop",
																									&kraken_buy_price_ask));

																	let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;
																	
																	//bitstamp calculations for sell
																	
																	let bitstamp_taker_fee = 0.004;
																	let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
																	let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
																	let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																	*bitstamp_wallet += money_from_sell_after_fees;
																	value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																	if let Some(mut value_after) = value_after {
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is bitstamp and kraken being updated, I will update:
																		//  56, 58, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 58, 59];
																		let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;
																	}
																	//03/08/24 - removed:			
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is bitstamp and kraken being updated, I will update:
																	// //  56, 58, 59
																	// let indices = [56, 58, 59];
																	// let new_values = [value_after, Some(*bitstamp_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;
																	
																	success = true;
																},
																_ => {
																	log::error!("i65: Failed to f64 parse bid or ask price");
																	if attempts > 3 {
																		panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																	}
																	continue;
																}
															}
														},
														_ => {
															log::error!("i65: Failed to originally parse bid or ask price");
															if attempts > 3 {
																panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
															}
															continue;
														}
													}
												},
												Err(_) => {
													log::error!("i65: Failed to parse JSON");
													if attempts > 3 {
														panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
													}
													continue;
												}
											}
										},
										Err(_) => {
											log::error!("i65: failed to get response text");
											if attempts > 3 {
												panic!("Failed to get response text after 3 attempts");
											}
											continue;
										}
									}
								},
								Err(_) => {
									log::error!("i65: Failed to execute request");
									if attempts > 3 {
										panic!("Failed to execute request after 3 attempts");
									}
									continue;
								}
							}
						},
						Err(_) => {
							log::error!("i65: Failed to build request");
							if attempts > 3 {
								panic!("Failed to build request after 3 attempts");
							}
							continue;
						}
					}
				}
		
				match value_after {
					Some(value) => return Ok(value),
					None => {
						//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
						panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
					}
				}











        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

		//03/02/24 - removed:
			// //kraken calculations - buy
			//     let kraken_taker_fee = 0.0026;
			//     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
			//     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
			//     let fee_for_purchase = total_spent*kraken_taker_fee;
			//     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
			//     *kraken_wallet -= money_going_to_sol_after_fees;
			//     let amount_of_sol_before_withdraw_fee = 
			//                     money_going_to_sol_after_fees/kraken_buy_price_ask;
			//     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

				


			// //coinbase calculations for sell

			//     //let coinbase_taker_fee = 0.008;
			//     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
			//     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
			//     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     //*coinbase_wallet += money_from_sell_after_fees;

			// //bitstamp calculations for sell
			//     let bitstamp_taker_fee = 0.004;
			//     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     *bitstamp_wallet += money_from_sell_after_fees;


			// //this will count as value after
			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
			//     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



			//         //value_after = 56
			//         //coinbase = 57
			//         //bitstamp = 58
			//         //kraken = 59
			//         //gemini = 60
			//         //since this is bitstamp and kraken being updated, I will update:
			//         //  56, 58, 59
			//         let indices = [56, 58, 59];
			//         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;


			//     return Ok(value_after)

    }

    pub async fn s_i66_sol_6_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


		//03/02/24 - removed:
			//     let now = Utc::now();
			//     type HmacSha256 = Hmac<Sha256>;
			//     fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
			//         let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			//             .expect("HMAC can take key of any size");
			//         mac.update(bitstamp_message.as_bytes());
			//         let result = mac.finalize();
			//         let code_bytes = result.into_bytes();
			//         hex::encode(code_bytes)
			//     }
				
			
			//     let content_type = "application/x-www-form-urlencoded";
			//     let payload_string = "offset=1";
			//     //if we needed content_type, it is here
			//     //let content_type = "application/json";
			//     //this is the bitstamp message IF we needed content_type
			//     //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
			//     //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			
			
			
			
			
			
			
			// //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
			
			
			
			//     let the_uuid = Uuid::new_v4();
			//     let bitstamp_nonce = the_uuid.to_string();
			//     let bitstamp_timestamp = now.timestamp_millis().to_string();
			//     //let content_type = "application/x-www-form-urlencoded";
			//     let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			//             bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			//     let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
			
			//     let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			//         .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			//         .header("X-Auth-Signature", bitstamp_signature)
			//         .header("X-Auth-Nonce", bitstamp_nonce)
			//         .header("X-Auth-Timestamp", bitstamp_timestamp)
			//         .header("X-Auth-Version", "v2")
			//         //.header("Content-Type", content_type)
			//         //.body(payload_string)
			//         .build()
			//         .expect("\ncould not build bitstamp_request");
			
			//     let bitstamp_response = client.execute(bitstamp_request).await
			//         .expect("Failed to execute Bitstamp request");
			//     let bitstamp_response_text = bitstamp_response.text().await
			//         .expect("Failed to turn response into text");
			//     //probably dont need "bitstamp" once we transfer this to the actual function
			//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
			//     .expect("Failed to parse JSON");
			
			// // Extract the bid and ask values
			//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
			//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
			//03/02/24 - removed:
                // println!("sol 5 kraken bitstamp: 3 sec delay");
                // let when = tokio::time::Instant::now() + Duration::from_secs(3);
                // tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        //returns current time. MAY NEED TO USE LOCAL TIME
		
		//03/02/24 - removed:
        // let now = Utc::now();
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);


        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }


        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request


	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
		let data = vec![
			("nonce", &nonce),
			// Add more parameters as needed
		];
		//let post_data: String = form_urlencoded::Serializer::new(String::new())
		//    .extend_pairs(data)
		//    .finish();

		let url_path = "/0/public/Ticker?pair=SOLUSD";
		//let message = format!("{}{}{}", url_path, nonce, post_data);


		fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
		-> String {
			// Create the post data
			let post_data: String = form_urlencoded::Serializer::new(String::new())
				.extend_pairs(data)
				.finish();
			//FOR DEBUGGING
			//println!("Private key:\n{}", secret);
			//println!("Nonce:\n{}", nonce_str);
			//println!("Encoded payload:\n{}", post_data);
			//println!("URI Path:\n{}", url_path);

			// Create the encoded string (nonce + post data) and hash it
			let encoded = format!("{}{}", nonce_str, post_data);
			let mut hasher = sha2::Sha256::new();
			hasher.update(encoded);
			let encoded_hash = hasher.finalize();

			// Create the message (url_path + encoded_hash as bytes)
			let mut message = url_path.as_bytes().to_vec();
			message.extend_from_slice(&encoded_hash);

			// Create a HMAC-SHA512 object with the base64-decoded secret
			let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
			let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
				.expect("HMAC can take key of any size");

			// Compute the HMAC of the message
			mac.update(&message);
			let result = mac.finalize();

			// Return the base64-encoded HMAC
			let signature = base64::encode(result.into_bytes());
			//println!("Kraken signature:\n{}", signature);

			signature
		}


		let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


		//03/02/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

													match (solusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);
																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i66: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i66: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i66: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i66: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i66: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i66: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i66: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			println!("sol 6 kraken bitstamp: 3 sec delay");
			let when = tokio::time::Instant::now() + Duration::from_secs(3);
			tokio::time::sleep_until(when).await;















		//03/02/24 - added:
			type HmacSha256 = Hmac<Sha256>;
			fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
				let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
					.expect("HMAC can take key of any size");
				mac.update(bitstamp_message.as_bytes());
				let result = mac.finalize();
				let code_bytes = result.into_bytes();
				hex::encode(code_bytes)
			}
			
		
			let content_type = "application/x-www-form-urlencoded";
			let payload_string = "offset=1";		
			let the_uuid = Uuid::new_v4();
			let bitstamp_nonce = the_uuid.to_string();
			let bitstamp_timestamp = now.timestamp_millis().to_string();
			//let content_type = "application/x-www-form-urlencoded";
			let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
					bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
		
			let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
				

				let mut success = false;
				let mut attempts = 0;
				let mut value_after: Option<f64> = None;
		
				while !success && attempts <=3 {
					attempts += 1;
		
					match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
						.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
						.header("X-Auth-Signature", &bitstamp_signature)
						.header("X-Auth-Nonce", &bitstamp_nonce)
						.header("X-Auth-Timestamp", &bitstamp_timestamp)
						.header("X-Auth-Version", "v2")
						.build() {
						Ok(bitstamp_request) => {
							match client.execute(bitstamp_request).await {
								Ok(bitstamp_response) => {
									match bitstamp_response.text().await {
										Ok(bitstamp_response_text) => {
											match serde_json::from_str::<Value>(&bitstamp_response_text) {
												Ok(v) => {
													let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
													let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
		
													match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
														(Some(bid_str), Some(ask_str)) => {
															match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
																(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																	
																	// Place your calculations and updates here
																	let kraken_taker_fee = 0.0026;
																	let fraction_of_wallet_im_using = 0.06; //aka 6 percent
																	let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																	let fee_for_purchase = total_spent*kraken_taker_fee;
																	let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																	//03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;

																	let amount_of_sol_before_withdraw_fee = 
																		money_going_to_sol_after_fees/kraken_buy_price_ask
																									.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																									even though to get to this point it had to be Some. 
																									kraken_buy_price_ask: {:?}
																									Honestly restart the program from the last saved state. 
																									The most likely error is a bit got flipped after the loop",
																									&kraken_buy_price_ask));

																	let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;
																	
																	//bitstamp calculations for sell
																	
																	let bitstamp_taker_fee = 0.004;
																	let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
																	let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
																	let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																	*bitstamp_wallet += money_from_sell_after_fees;
																	value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																	if let Some(mut value_after) = value_after {
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is bitstamp and kraken being updated, I will update:
																		//  56, 58, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 58, 59];
																		let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;
																	}
																	//03/08/24 - removed:			
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is bitstamp and kraken being updated, I will update:
																	// //  56, 58, 59
																	// let indices = [56, 58, 59];
																	// let new_values = [value_after, Some(*bitstamp_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;
																	
																	success = true;
																},
																_ => {
																	log::error!("i66: Failed to f64 parse bid or ask price");
																	if attempts > 3 {
																		panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																	}
																	continue;
																}
															}
														},
														_ => {
															log::error!("i66: Failed to originally parse bid or ask price");
															if attempts > 3 {
																panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
															}
															continue;
														}
													}
												},
												Err(_) => {
													log::error!("i66: Failed to parse JSON");
													if attempts > 3 {
														panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
													}
													continue;
												}
											}
										},
										Err(_) => {
											log::error!("i66: failed to get response text");
											if attempts > 3 {
												panic!("Failed to get response text after 3 attempts");
											}
											continue;
										}
									}
								},
								Err(_) => {
									log::error!("i66: Failed to execute request");
									if attempts > 3 {
										panic!("Failed to execute request after 3 attempts");
									}
									continue;
								}
							}
						},
						Err(_) => {
							log::error!("i66: Failed to build request");
							if attempts > 3 {
								panic!("Failed to build request after 3 attempts");
							}
							continue;
						}
					}
				}
		
				match value_after {
					Some(value) => return Ok(value),
					None => {
						//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
						panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
					}
				}











        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

		//03/02/24 - removed:
			// //kraken calculations - buy
			//     let kraken_taker_fee = 0.0026;
			//     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
			//     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
			//     let fee_for_purchase = total_spent*kraken_taker_fee;
			//     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
			//     *kraken_wallet -= money_going_to_sol_after_fees;
			//     let amount_of_sol_before_withdraw_fee = 
			//                     money_going_to_sol_after_fees/kraken_buy_price_ask;
			//     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

				


			// //coinbase calculations for sell

			//     //let coinbase_taker_fee = 0.008;
			//     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
			//     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
			//     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     //*coinbase_wallet += money_from_sell_after_fees;

			// //bitstamp calculations for sell
			//     let bitstamp_taker_fee = 0.004;
			//     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     *bitstamp_wallet += money_from_sell_after_fees;


			// //this will count as value after
			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
			//     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



			//         //value_after = 56
			//         //coinbase = 57
			//         //bitstamp = 58
			//         //kraken = 59
			//         //gemini = 60
			//         //since this is bitstamp and kraken being updated, I will update:
			//         //  56, 58, 59
			//         let indices = [56, 58, 59];
			//         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;


			//     return Ok(value_after)

    }

    pub async fn s_i67_sol_7_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


		//03/02/24 - removed:
			//     let now = Utc::now();
			//     type HmacSha256 = Hmac<Sha256>;
			//     fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
			//         let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			//             .expect("HMAC can take key of any size");
			//         mac.update(bitstamp_message.as_bytes());
			//         let result = mac.finalize();
			//         let code_bytes = result.into_bytes();
			//         hex::encode(code_bytes)
			//     }
				
			
			//     let content_type = "application/x-www-form-urlencoded";
			//     let payload_string = "offset=1";
			//     //if we needed content_type, it is here
			//     //let content_type = "application/json";
			//     //this is the bitstamp message IF we needed content_type
			//     //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
			//     //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			
			
			
			
			
			
			
			// //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
			
			
			
			//     let the_uuid = Uuid::new_v4();
			//     let bitstamp_nonce = the_uuid.to_string();
			//     let bitstamp_timestamp = now.timestamp_millis().to_string();
			//     //let content_type = "application/x-www-form-urlencoded";
			//     let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			//             bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			//     let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
			
			//     let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			//         .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			//         .header("X-Auth-Signature", bitstamp_signature)
			//         .header("X-Auth-Nonce", bitstamp_nonce)
			//         .header("X-Auth-Timestamp", bitstamp_timestamp)
			//         .header("X-Auth-Version", "v2")
			//         //.header("Content-Type", content_type)
			//         //.body(payload_string)
			//         .build()
			//         .expect("\ncould not build bitstamp_request");
			
			//     let bitstamp_response = client.execute(bitstamp_request).await
			//         .expect("Failed to execute Bitstamp request");
			//     let bitstamp_response_text = bitstamp_response.text().await
			//         .expect("Failed to turn response into text");
			//     //probably dont need "bitstamp" once we transfer this to the actual function
			//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
			//     .expect("Failed to parse JSON");
			
			// // Extract the bid and ask values
			//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
			//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
			//03/02/24 - removed:
                // println!("sol 5 kraken bitstamp: 3 sec delay");
                // let when = tokio::time::Instant::now() + Duration::from_secs(3);
                // tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        //returns current time. MAY NEED TO USE LOCAL TIME
		
		//03/02/24 - removed:
        // let now = Utc::now();
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);


        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }


        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request


	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
		let data = vec![
			("nonce", &nonce),
			// Add more parameters as needed
		];
		//let post_data: String = form_urlencoded::Serializer::new(String::new())
		//    .extend_pairs(data)
		//    .finish();

		let url_path = "/0/public/Ticker?pair=SOLUSD";
		//let message = format!("{}{}{}", url_path, nonce, post_data);


		fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
		-> String {
			// Create the post data
			let post_data: String = form_urlencoded::Serializer::new(String::new())
				.extend_pairs(data)
				.finish();
			//FOR DEBUGGING
			//println!("Private key:\n{}", secret);
			//println!("Nonce:\n{}", nonce_str);
			//println!("Encoded payload:\n{}", post_data);
			//println!("URI Path:\n{}", url_path);

			// Create the encoded string (nonce + post data) and hash it
			let encoded = format!("{}{}", nonce_str, post_data);
			let mut hasher = sha2::Sha256::new();
			hasher.update(encoded);
			let encoded_hash = hasher.finalize();

			// Create the message (url_path + encoded_hash as bytes)
			let mut message = url_path.as_bytes().to_vec();
			message.extend_from_slice(&encoded_hash);

			// Create a HMAC-SHA512 object with the base64-decoded secret
			let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
			let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
				.expect("HMAC can take key of any size");

			// Compute the HMAC of the message
			mac.update(&message);
			let result = mac.finalize();

			// Return the base64-encoded HMAC
			let signature = base64::encode(result.into_bytes());
			//println!("Kraken signature:\n{}", signature);

			signature
		}


		let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


		//03/02/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

													match (solusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i67: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i67: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i67: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i67: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i67: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i67: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i67: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			println!("sol 7 kraken bitstamp: 3 sec delay");
			let when = tokio::time::Instant::now() + Duration::from_secs(3);
			tokio::time::sleep_until(when).await;















		//03/02/24 - added:
			type HmacSha256 = Hmac<Sha256>;
			fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
				let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
					.expect("HMAC can take key of any size");
				mac.update(bitstamp_message.as_bytes());
				let result = mac.finalize();
				let code_bytes = result.into_bytes();
				hex::encode(code_bytes)
			}
			
		
			let content_type = "application/x-www-form-urlencoded";
			let payload_string = "offset=1";		
			let the_uuid = Uuid::new_v4();
			let bitstamp_nonce = the_uuid.to_string();
			let bitstamp_timestamp = now.timestamp_millis().to_string();
			//let content_type = "application/x-www-form-urlencoded";
			let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
					bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
		
			let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
				

				let mut success = false;
				let mut attempts = 0;
				let mut value_after: Option<f64> = None;
		
				while !success && attempts <=3 {
					attempts += 1;
		
					match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
						.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
						.header("X-Auth-Signature", &bitstamp_signature)
						.header("X-Auth-Nonce", &bitstamp_nonce)
						.header("X-Auth-Timestamp", &bitstamp_timestamp)
						.header("X-Auth-Version", "v2")
						.build() {
						Ok(bitstamp_request) => {
							match client.execute(bitstamp_request).await {
								Ok(bitstamp_response) => {
									match bitstamp_response.text().await {
										Ok(bitstamp_response_text) => {
											match serde_json::from_str::<Value>(&bitstamp_response_text) {
												Ok(v) => {
													let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
													let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
		
													match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
														(Some(bid_str), Some(ask_str)) => {
															match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
																(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																	
																	// Place your calculations and updates here
																	let kraken_taker_fee = 0.0026;
																	let fraction_of_wallet_im_using = 0.07; //aka 7 percent
																	let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																	let fee_for_purchase = total_spent*kraken_taker_fee;
																	let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																	//03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;

																	let amount_of_sol_before_withdraw_fee = 
																		money_going_to_sol_after_fees/kraken_buy_price_ask
																									.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																									even though to get to this point it had to be Some. 
																									kraken_buy_price_ask: {:?}
																									Honestly restart the program from the last saved state. 
																									The most likely error is a bit got flipped after the loop",
																									&kraken_buy_price_ask));

																	let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;
																	
																	//bitstamp calculations for sell
																	
																	let bitstamp_taker_fee = 0.004;
																	let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
																	let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
																	let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																	*bitstamp_wallet += money_from_sell_after_fees;
																	value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																	if let Some(mut value_after) = value_after {
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is bitstamp and kraken being updated, I will update:
																		//  56, 58, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 58, 59];
																		let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;
																	}
																	//03/08/24 - removed:			
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is bitstamp and kraken being updated, I will update:
																	// //  56, 58, 59
																	// let indices = [56, 58, 59];
																	// let new_values = [value_after, Some(*bitstamp_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;
																	
																	success = true;
																},
																_ => {
																	log::error!("i67: Failed to f64 parse bid or ask price");
																	if attempts > 3 {
																		panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																	}
																	continue;
																}
															}
														},
														_ => {
															log::error!("i67: Failed to originally parse bid or ask price");
															if attempts > 3 {
																panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
															}
															continue;
														}
													}
												},
												Err(_) => {
													log::error!("i67: Failed to parse JSON");
													if attempts > 3 {
														panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
													}
													continue;
												}
											}
										},
										Err(_) => {
											log::error!("i67: failed to get response text");
											if attempts > 3 {
												panic!("Failed to get response text after 3 attempts");
											}
											continue;
										}
									}
								},
								Err(_) => {
									log::error!("i67: Failed to execute request");
									if attempts > 3 {
										panic!("Failed to execute request after 3 attempts");
									}
									continue;
								}
							}
						},
						Err(_) => {
							log::error!("i67: Failed to build request");
							if attempts > 3 {
								panic!("Failed to build request after 3 attempts");
							}
							continue;
						}
					}
				}
		
				match value_after {
					Some(value) => return Ok(value),
					None => {
						//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
						panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
					}
				}











        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

		//03/02/24 - removed:
			// //kraken calculations - buy
			//     let kraken_taker_fee = 0.0026;
			//     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
			//     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
			//     let fee_for_purchase = total_spent*kraken_taker_fee;
			//     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
			//     *kraken_wallet -= money_going_to_sol_after_fees;
			//     let amount_of_sol_before_withdraw_fee = 
			//                     money_going_to_sol_after_fees/kraken_buy_price_ask;
			//     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

				


			// //coinbase calculations for sell

			//     //let coinbase_taker_fee = 0.008;
			//     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
			//     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
			//     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     //*coinbase_wallet += money_from_sell_after_fees;

			// //bitstamp calculations for sell
			//     let bitstamp_taker_fee = 0.004;
			//     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     *bitstamp_wallet += money_from_sell_after_fees;


			// //this will count as value after
			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
			//     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



			//         //value_after = 56
			//         //coinbase = 57
			//         //bitstamp = 58
			//         //kraken = 59
			//         //gemini = 60
			//         //since this is bitstamp and kraken being updated, I will update:
			//         //  56, 58, 59
			//         let indices = [56, 58, 59];
			//         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;


			//     return Ok(value_after)

    }

    pub async fn s_i68_sol_8_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


		//03/02/24 - removed:
			//     let now = Utc::now();
			//     type HmacSha256 = Hmac<Sha256>;
			//     fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
			//         let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			//             .expect("HMAC can take key of any size");
			//         mac.update(bitstamp_message.as_bytes());
			//         let result = mac.finalize();
			//         let code_bytes = result.into_bytes();
			//         hex::encode(code_bytes)
			//     }
				
			
			//     let content_type = "application/x-www-form-urlencoded";
			//     let payload_string = "offset=1";
			//     //if we needed content_type, it is here
			//     //let content_type = "application/json";
			//     //this is the bitstamp message IF we needed content_type
			//     //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
			//     //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			
			
			
			
			
			
			
			// //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
			
			
			
			//     let the_uuid = Uuid::new_v4();
			//     let bitstamp_nonce = the_uuid.to_string();
			//     let bitstamp_timestamp = now.timestamp_millis().to_string();
			//     //let content_type = "application/x-www-form-urlencoded";
			//     let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			//             bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			//     let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
			
			//     let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			//         .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			//         .header("X-Auth-Signature", bitstamp_signature)
			//         .header("X-Auth-Nonce", bitstamp_nonce)
			//         .header("X-Auth-Timestamp", bitstamp_timestamp)
			//         .header("X-Auth-Version", "v2")
			//         //.header("Content-Type", content_type)
			//         //.body(payload_string)
			//         .build()
			//         .expect("\ncould not build bitstamp_request");
			
			//     let bitstamp_response = client.execute(bitstamp_request).await
			//         .expect("Failed to execute Bitstamp request");
			//     let bitstamp_response_text = bitstamp_response.text().await
			//         .expect("Failed to turn response into text");
			//     //probably dont need "bitstamp" once we transfer this to the actual function
			//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
			//     .expect("Failed to parse JSON");
			
			// // Extract the bid and ask values
			//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
			//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
			//03/02/24 - removed:
                // println!("sol 5 kraken bitstamp: 3 sec delay");
                // let when = tokio::time::Instant::now() + Duration::from_secs(3);
                // tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        //returns current time. MAY NEED TO USE LOCAL TIME
		
		//03/02/24 - removed:
        // let now = Utc::now();
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);


        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }


        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request


	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
		let data = vec![
			("nonce", &nonce),
			// Add more parameters as needed
		];
		//let post_data: String = form_urlencoded::Serializer::new(String::new())
		//    .extend_pairs(data)
		//    .finish();

		let url_path = "/0/public/Ticker?pair=SOLUSD";
		//let message = format!("{}{}{}", url_path, nonce, post_data);


		fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
		-> String {
			// Create the post data
			let post_data: String = form_urlencoded::Serializer::new(String::new())
				.extend_pairs(data)
				.finish();
			//FOR DEBUGGING
			//println!("Private key:\n{}", secret);
			//println!("Nonce:\n{}", nonce_str);
			//println!("Encoded payload:\n{}", post_data);
			//println!("URI Path:\n{}", url_path);

			// Create the encoded string (nonce + post data) and hash it
			let encoded = format!("{}{}", nonce_str, post_data);
			let mut hasher = sha2::Sha256::new();
			hasher.update(encoded);
			let encoded_hash = hasher.finalize();

			// Create the message (url_path + encoded_hash as bytes)
			let mut message = url_path.as_bytes().to_vec();
			message.extend_from_slice(&encoded_hash);

			// Create a HMAC-SHA512 object with the base64-decoded secret
			let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
			let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
				.expect("HMAC can take key of any size");

			// Compute the HMAC of the message
			mac.update(&message);
			let result = mac.finalize();

			// Return the base64-encoded HMAC
			let signature = base64::encode(result.into_bytes());
			//println!("Kraken signature:\n{}", signature);

			signature
		}


		let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


		//03/02/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

													match (solusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i68: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i68: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i68: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i68: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i68: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i68: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i68: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			println!("sol 8 kraken bitstamp: 3 sec delay");
			let when = tokio::time::Instant::now() + Duration::from_secs(3);
			tokio::time::sleep_until(when).await;















		//03/02/24 - added:
			type HmacSha256 = Hmac<Sha256>;
			fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
				let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
					.expect("HMAC can take key of any size");
				mac.update(bitstamp_message.as_bytes());
				let result = mac.finalize();
				let code_bytes = result.into_bytes();
				hex::encode(code_bytes)
			}
			
		
			let content_type = "application/x-www-form-urlencoded";
			let payload_string = "offset=1";		
			let the_uuid = Uuid::new_v4();
			let bitstamp_nonce = the_uuid.to_string();
			let bitstamp_timestamp = now.timestamp_millis().to_string();
			//let content_type = "application/x-www-form-urlencoded";
			let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
					bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
		
			let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
				

				let mut success = false;
				let mut attempts = 0;
				let mut value_after: Option<f64> = None;
		
				while !success && attempts <=3 {
					attempts += 1;
		
					match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
						.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
						.header("X-Auth-Signature", &bitstamp_signature)
						.header("X-Auth-Nonce", &bitstamp_nonce)
						.header("X-Auth-Timestamp", &bitstamp_timestamp)
						.header("X-Auth-Version", "v2")
						.build() {
						Ok(bitstamp_request) => {
							match client.execute(bitstamp_request).await {
								Ok(bitstamp_response) => {
									match bitstamp_response.text().await {
										Ok(bitstamp_response_text) => {
											match serde_json::from_str::<Value>(&bitstamp_response_text) {
												Ok(v) => {
													let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
													let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
		
													match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
														(Some(bid_str), Some(ask_str)) => {
															match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
																(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																	
																	// Place your calculations and updates here
																	let kraken_taker_fee = 0.0026;
																	let fraction_of_wallet_im_using = 0.08; //aka 8 percent
																	let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																	let fee_for_purchase = total_spent*kraken_taker_fee;
																	let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																	//03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;

																	let amount_of_sol_before_withdraw_fee = 
																		money_going_to_sol_after_fees/kraken_buy_price_ask
																									.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																									even though to get to this point it had to be Some. 
																									kraken_buy_price_ask: {:?}
																									Honestly restart the program from the last saved state. 
																									The most likely error is a bit got flipped after the loop",
																									&kraken_buy_price_ask));

																	let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;
																	
																	//bitstamp calculations for sell
																	
																	let bitstamp_taker_fee = 0.004;
																	let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
																	let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
																	let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																	*bitstamp_wallet += money_from_sell_after_fees;
																	value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																	if let Some(mut value_after) = value_after {
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is bitstamp and kraken being updated, I will update:
																		//  56, 58, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 58, 59];
																		let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;
																	}
																	//03/08/24 - removed:			
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is bitstamp and kraken being updated, I will update:
																	// //  56, 58, 59
																	// let indices = [56, 58, 59];
																	// let new_values = [value_after, Some(*bitstamp_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;
																	
																	success = true;
																},
																_ => {
																	log::error!("i68: Failed to f64 parse bid or ask price");
																	if attempts > 3 {
																		panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																	}
																	continue;
																}
															}
														},
														_ => {
															log::error!("i68: Failed to originally parse bid or ask price");
															if attempts > 3 {
																panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
															}
															continue;
														}
													}
												},
												Err(_) => {
													log::error!("i68: Failed to parse JSON");
													if attempts > 3 {
														panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
													}
													continue;
												}
											}
										},
										Err(_) => {
											log::error!("i68: failed to get response text");
											if attempts > 3 {
												panic!("Failed to get response text after 3 attempts");
											}
											continue;
										}
									}
								},
								Err(_) => {
									log::error!("i68: Failed to execute request");
									if attempts > 3 {
										panic!("Failed to execute request after 3 attempts");
									}
									continue;
								}
							}
						},
						Err(_) => {
							log::error!("i68: Failed to build request");
							if attempts > 3 {
								panic!("Failed to build request after 3 attempts");
							}
							continue;
						}
					}
				}
		
				match value_after {
					Some(value) => return Ok(value),
					None => {
						//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
						panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
					}
				}











        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

		//03/02/24 - removed:
			// //kraken calculations - buy
			//     let kraken_taker_fee = 0.0026;
			//     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
			//     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
			//     let fee_for_purchase = total_spent*kraken_taker_fee;
			//     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
			//     *kraken_wallet -= money_going_to_sol_after_fees;
			//     let amount_of_sol_before_withdraw_fee = 
			//                     money_going_to_sol_after_fees/kraken_buy_price_ask;
			//     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

				


			// //coinbase calculations for sell

			//     //let coinbase_taker_fee = 0.008;
			//     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
			//     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
			//     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     //*coinbase_wallet += money_from_sell_after_fees;

			// //bitstamp calculations for sell
			//     let bitstamp_taker_fee = 0.004;
			//     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     *bitstamp_wallet += money_from_sell_after_fees;


			// //this will count as value after
			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
			//     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



			//         //value_after = 56
			//         //coinbase = 57
			//         //bitstamp = 58
			//         //kraken = 59
			//         //gemini = 60
			//         //since this is bitstamp and kraken being updated, I will update:
			//         //  56, 58, 59
			//         let indices = [56, 58, 59];
			//         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;


			//     return Ok(value_after)

    }

    pub async fn s_i69_sol_9_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


		//03/02/24 - removed:
			//     let now = Utc::now();
			//     type HmacSha256 = Hmac<Sha256>;
			//     fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
			//         let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			//             .expect("HMAC can take key of any size");
			//         mac.update(bitstamp_message.as_bytes());
			//         let result = mac.finalize();
			//         let code_bytes = result.into_bytes();
			//         hex::encode(code_bytes)
			//     }
				
			
			//     let content_type = "application/x-www-form-urlencoded";
			//     let payload_string = "offset=1";
			//     //if we needed content_type, it is here
			//     //let content_type = "application/json";
			//     //this is the bitstamp message IF we needed content_type
			//     //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
			//     //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			
			
			
			
			
			
			
			// //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
			
			
			
			//     let the_uuid = Uuid::new_v4();
			//     let bitstamp_nonce = the_uuid.to_string();
			//     let bitstamp_timestamp = now.timestamp_millis().to_string();
			//     //let content_type = "application/x-www-form-urlencoded";
			//     let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			//             bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			//     let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
			
			//     let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			//         .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			//         .header("X-Auth-Signature", bitstamp_signature)
			//         .header("X-Auth-Nonce", bitstamp_nonce)
			//         .header("X-Auth-Timestamp", bitstamp_timestamp)
			//         .header("X-Auth-Version", "v2")
			//         //.header("Content-Type", content_type)
			//         //.body(payload_string)
			//         .build()
			//         .expect("\ncould not build bitstamp_request");
			
			//     let bitstamp_response = client.execute(bitstamp_request).await
			//         .expect("Failed to execute Bitstamp request");
			//     let bitstamp_response_text = bitstamp_response.text().await
			//         .expect("Failed to turn response into text");
			//     //probably dont need "bitstamp" once we transfer this to the actual function
			//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
			//     .expect("Failed to parse JSON");
			
			// // Extract the bid and ask values
			//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
			//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
			//03/02/24 - removed:
                // println!("sol 5 kraken bitstamp: 3 sec delay");
                // let when = tokio::time::Instant::now() + Duration::from_secs(3);
                // tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        //returns current time. MAY NEED TO USE LOCAL TIME
		
		//03/02/24 - removed:
        // let now = Utc::now();
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);


        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }


        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request


	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
		let data = vec![
			("nonce", &nonce),
			// Add more parameters as needed
		];
		//let post_data: String = form_urlencoded::Serializer::new(String::new())
		//    .extend_pairs(data)
		//    .finish();

		let url_path = "/0/public/Ticker?pair=SOLUSD";
		//let message = format!("{}{}{}", url_path, nonce, post_data);


		fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
		-> String {
			// Create the post data
			let post_data: String = form_urlencoded::Serializer::new(String::new())
				.extend_pairs(data)
				.finish();
			//FOR DEBUGGING
			//println!("Private key:\n{}", secret);
			//println!("Nonce:\n{}", nonce_str);
			//println!("Encoded payload:\n{}", post_data);
			//println!("URI Path:\n{}", url_path);

			// Create the encoded string (nonce + post data) and hash it
			let encoded = format!("{}{}", nonce_str, post_data);
			let mut hasher = sha2::Sha256::new();
			hasher.update(encoded);
			let encoded_hash = hasher.finalize();

			// Create the message (url_path + encoded_hash as bytes)
			let mut message = url_path.as_bytes().to_vec();
			message.extend_from_slice(&encoded_hash);

			// Create a HMAC-SHA512 object with the base64-decoded secret
			let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
			let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
				.expect("HMAC can take key of any size");

			// Compute the HMAC of the message
			mac.update(&message);
			let result = mac.finalize();

			// Return the base64-encoded HMAC
			let signature = base64::encode(result.into_bytes());
			//println!("Kraken signature:\n{}", signature);

			signature
		}


		let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


		//03/02/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

													match (solusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i69: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i69: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i69: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i69: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i69: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i69: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i69: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			println!("sol 9 kraken bitstamp: 3 sec delay");
			let when = tokio::time::Instant::now() + Duration::from_secs(3);
			tokio::time::sleep_until(when).await;















		//03/02/24 - added:
			type HmacSha256 = Hmac<Sha256>;
			fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
				let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
					.expect("HMAC can take key of any size");
				mac.update(bitstamp_message.as_bytes());
				let result = mac.finalize();
				let code_bytes = result.into_bytes();
				hex::encode(code_bytes)
			}
			
		
			let content_type = "application/x-www-form-urlencoded";
			let payload_string = "offset=1";		
			let the_uuid = Uuid::new_v4();
			let bitstamp_nonce = the_uuid.to_string();
			let bitstamp_timestamp = now.timestamp_millis().to_string();
			//let content_type = "application/x-www-form-urlencoded";
			let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
					bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
		
			let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
				

				let mut success = false;
				let mut attempts = 0;
				let mut value_after: Option<f64> = None;
		
				while !success && attempts <=3 {
					attempts += 1;
		
					match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
						.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
						.header("X-Auth-Signature", &bitstamp_signature)
						.header("X-Auth-Nonce", &bitstamp_nonce)
						.header("X-Auth-Timestamp", &bitstamp_timestamp)
						.header("X-Auth-Version", "v2")
						.build() {
						Ok(bitstamp_request) => {
							match client.execute(bitstamp_request).await {
								Ok(bitstamp_response) => {
									match bitstamp_response.text().await {
										Ok(bitstamp_response_text) => {
											match serde_json::from_str::<Value>(&bitstamp_response_text) {
												Ok(v) => {
													let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
													let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
		
													match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
														(Some(bid_str), Some(ask_str)) => {
															match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
																(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																	
																	// Place your calculations and updates here
																	let kraken_taker_fee = 0.0026;
																	let fraction_of_wallet_im_using = 0.09; //aka 9 percent
																	let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																	let fee_for_purchase = total_spent*kraken_taker_fee;
																	let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																	//03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;

																	let amount_of_sol_before_withdraw_fee = 
																		money_going_to_sol_after_fees/kraken_buy_price_ask
																									.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																									even though to get to this point it had to be Some. 
																									kraken_buy_price_ask: {:?}
																									Honestly restart the program from the last saved state. 
																									The most likely error is a bit got flipped after the loop",
																									&kraken_buy_price_ask));

																	let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;
																	
																	//bitstamp calculations for sell
																	
																	let bitstamp_taker_fee = 0.004;
																	let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
																	let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
																	let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																	*bitstamp_wallet += money_from_sell_after_fees;
																	value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																	if let Some(mut value_after) = value_after {
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is bitstamp and kraken being updated, I will update:
																		//  56, 58, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 58, 59];
																		let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;
																	}
																	//03/08/24 - removed:			
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is bitstamp and kraken being updated, I will update:
																	// //  56, 58, 59
																	// let indices = [56, 58, 59];
																	// let new_values = [value_after, Some(*bitstamp_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;
																	
																	success = true;
																},
																_ => {
																	log::error!("i69: Failed to f64 parse bid or ask price");
																	if attempts > 3 {
																		panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																	}
																	continue;
																}
															}
														},
														_ => {
															log::error!("i69: Failed to originally parse bid or ask price");
															if attempts > 3 {
																panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
															}
															continue;
														}
													}
												},
												Err(_) => {
													log::error!("i69: Failed to parse JSON");
													if attempts > 3 {
														panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
													}
													continue;
												}
											}
										},
										Err(_) => {
											log::error!("i69: failed to get response text");
											if attempts > 3 {
												panic!("Failed to get response text after 3 attempts");
											}
											continue;
										}
									}
								},
								Err(_) => {
									log::error!("i69: Failed to execute request");
									if attempts > 3 {
										panic!("Failed to execute request after 3 attempts");
									}
									continue;
								}
							}
						},
						Err(_) => {
							log::error!("i69: Failed to build request");
							if attempts > 3 {
								panic!("Failed to build request after 3 attempts");
							}
							continue;
						}
					}
				}
		
				match value_after {
					Some(value) => return Ok(value),
					None => {
						//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
						panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
					}
				}











        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

		//03/02/24 - removed:
			// //kraken calculations - buy
			//     let kraken_taker_fee = 0.0026;
			//     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
			//     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
			//     let fee_for_purchase = total_spent*kraken_taker_fee;
			//     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
			//     *kraken_wallet -= money_going_to_sol_after_fees;
			//     let amount_of_sol_before_withdraw_fee = 
			//                     money_going_to_sol_after_fees/kraken_buy_price_ask;
			//     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

				


			// //coinbase calculations for sell

			//     //let coinbase_taker_fee = 0.008;
			//     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
			//     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
			//     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     //*coinbase_wallet += money_from_sell_after_fees;

			// //bitstamp calculations for sell
			//     let bitstamp_taker_fee = 0.004;
			//     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     *bitstamp_wallet += money_from_sell_after_fees;


			// //this will count as value after
			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
			//     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



			//         //value_after = 56
			//         //coinbase = 57
			//         //bitstamp = 58
			//         //kraken = 59
			//         //gemini = 60
			//         //since this is bitstamp and kraken being updated, I will update:
			//         //  56, 58, 59
			//         let indices = [56, 58, 59];
			//         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;


			//     return Ok(value_after)

    }

    pub async fn s_i70_sol_10_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
        //      then do .01 * coinbase_wallet - trading_fee = how much sol in usd Im sending. 
        //      then do coinbase_wallet = coinbase_wallet - (.01 * coinbase_wallet + trading_fee)
        //      then do price_of_sol / how much I'm buying   or oposite  to get how much sol im sending
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then figure out price at kraken
        //      then sell it there with the trading fee.
        //      then do a 2.7 sec wait. 2.5 sec for sol transaction speed. 0.2 sec for assumed time to gather data
        //      then set kraken_wallet = new value of wallet.
        //      then add values of both wallets to bitstamp_wallet and gemini_wallet
        //      then compare to value_prior
        //      tehn do reward function?
        //I'll have the keys in main so it doesn't have to load everything everytime, it can just store it in RAM
        //------all stuff below this is to actually complete the request to get how much money it costs


		//03/02/24 - removed:
			//     let now = Utc::now();
			//     type HmacSha256 = Hmac<Sha256>;
			//     fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
			//         let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			//             .expect("HMAC can take key of any size");
			//         mac.update(bitstamp_message.as_bytes());
			//         let result = mac.finalize();
			//         let code_bytes = result.into_bytes();
			//         hex::encode(code_bytes)
			//     }
				
			
			//     let content_type = "application/x-www-form-urlencoded";
			//     let payload_string = "offset=1";
			//     //if we needed content_type, it is here
			//     //let content_type = "application/json";
			//     //this is the bitstamp message IF we needed content_type
			//     //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
			//     //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			
			
			
			
			
			
			
			// //--------------------FOR ACTUAL REQUEST MESSAGE------------------------------------------//
			
			
			
			//     let the_uuid = Uuid::new_v4();
			//     let bitstamp_nonce = the_uuid.to_string();
			//     let bitstamp_timestamp = now.timestamp_millis().to_string();
			//     //let content_type = "application/x-www-form-urlencoded";
			//     let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
			//             bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
			
			//     let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
			
			//     let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
			//         .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
			//         .header("X-Auth-Signature", bitstamp_signature)
			//         .header("X-Auth-Nonce", bitstamp_nonce)
			//         .header("X-Auth-Timestamp", bitstamp_timestamp)
			//         .header("X-Auth-Version", "v2")
			//         //.header("Content-Type", content_type)
			//         //.body(payload_string)
			//         .build()
			//         .expect("\ncould not build bitstamp_request");
			
			//     let bitstamp_response = client.execute(bitstamp_request).await
			//         .expect("Failed to execute Bitstamp request");
			//     let bitstamp_response_text = bitstamp_response.text().await
			//         .expect("Failed to turn response into text");
			//     //probably dont need "bitstamp" once we transfer this to the actual function
			//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
			//     .expect("Failed to parse JSON");
			
			// // Extract the bid and ask values
			//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
			//     let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();













        //serves as transaction time
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
			//03/02/24 - removed:
                // println!("sol 5 kraken bitstamp: 3 sec delay");
                // let when = tokio::time::Instant::now() + Duration::from_secs(3);
                // tokio::time::sleep_until(when).await;






        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        //returns current time. MAY NEED TO USE LOCAL TIME
		
		//03/02/24 - removed:
        // let now = Utc::now();
        // let nonce = now.timestamp_millis().to_string();
        // let data = vec![
        //     ("nonce", &nonce),
        //     // Add more parameters as needed
        // ];
        // //let post_data: String = form_urlencoded::Serializer::new(String::new())
        // //    .extend_pairs(data)
        // //    .finish();
        
        // let url_path = "/0/public/Ticker?pair=SOLUSD";
        // //let message = format!("{}{}{}", url_path, nonce, post_data);


        // fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        // -> String {
        //     // Create the post data
        //     let post_data: String = form_urlencoded::Serializer::new(String::new())
        //         .extend_pairs(data)
        //         .finish();
        //     //FOR DEBUGGING
        //     //println!("Private key:\n{}", secret);
        //     //println!("Nonce:\n{}", nonce_str);
        //     //println!("Encoded payload:\n{}", post_data);
        //     //println!("URI Path:\n{}", url_path);
        
        //     // Create the encoded string (nonce + post data) and hash it
        //     let encoded = format!("{}{}", nonce_str, post_data);
        //     let mut hasher = sha2::Sha256::new();
        //     hasher.update(encoded);
        //     let encoded_hash = hasher.finalize();
        
        //     // Create the message (url_path + encoded_hash as bytes)
        //     let mut message = url_path.as_bytes().to_vec();
        //     message.extend_from_slice(&encoded_hash);
        
        //     // Create a HMAC-SHA512 object with the base64-decoded secret
        //     let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        //     let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
        //         .expect("HMAC can take key of any size");
        
        //     // Compute the HMAC of the message
        //     mac.update(&message);
        //     let result = mac.finalize();
        
        //     // Return the base64-encoded HMAC
        //     let signature = base64::encode(result.into_bytes());
        //     //println!("Kraken signature:\n{}", signature);
        
        //     signature
        // }


        // let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request


	//03/02/24 - added:
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
		let data = vec![
			("nonce", &nonce),
			// Add more parameters as needed
		];
		//let post_data: String = form_urlencoded::Serializer::new(String::new())
		//    .extend_pairs(data)
		//    .finish();

		let url_path = "/0/public/Ticker?pair=SOLUSD";
		//let message = format!("{}{}{}", url_path, nonce, post_data);


		fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
		-> String {
			// Create the post data
			let post_data: String = form_urlencoded::Serializer::new(String::new())
				.extend_pairs(data)
				.finish();
			//FOR DEBUGGING
			//println!("Private key:\n{}", secret);
			//println!("Nonce:\n{}", nonce_str);
			//println!("Encoded payload:\n{}", post_data);
			//println!("URI Path:\n{}", url_path);

			// Create the encoded string (nonce + post data) and hash it
			let encoded = format!("{}{}", nonce_str, post_data);
			let mut hasher = sha2::Sha256::new();
			hasher.update(encoded);
			let encoded_hash = hasher.finalize();

			// Create the message (url_path + encoded_hash as bytes)
			let mut message = url_path.as_bytes().to_vec();
			message.extend_from_slice(&encoded_hash);

			// Create a HMAC-SHA512 object with the base64-decoded secret
			let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
			let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
				.expect("HMAC can take key of any size");

			// Compute the HMAC of the message
			mac.update(&message);
			let result = mac.finalize();

			// Return the base64-encoded HMAC
			let signature = base64::encode(result.into_bytes());
			//println!("Kraken signature:\n{}", signature);

			signature
		}


		let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);


		//03/02/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=SOLUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(solusd) = value["result"]["SOLUSD"].as_object() {

													match (solusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i70: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i70: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i70: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i70:Kraken:  Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i70: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i70: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i70: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			println!("sol 10 kraken bitstamp: 3 sec delay");
			let when = tokio::time::Instant::now() + Duration::from_secs(3);
			tokio::time::sleep_until(when).await;















		//03/02/24 - added:
			type HmacSha256 = Hmac<Sha256>;
			fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
				let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
					.expect("HMAC can take key of any size");
				mac.update(bitstamp_message.as_bytes());
				let result = mac.finalize();
				let code_bytes = result.into_bytes();
				hex::encode(code_bytes)
			}
			
		
			let content_type = "application/x-www-form-urlencoded";
			let payload_string = "offset=1";		
			let the_uuid = Uuid::new_v4();
			let bitstamp_nonce = the_uuid.to_string();
			let bitstamp_timestamp = now.timestamp_millis().to_string();
			//let content_type = "application/x-www-form-urlencoded";
			let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/sol-usd/{}{}{}{}v2{}", 
					bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);
		
			let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);
				

				let mut success = false;
				let mut attempts = 0;
				let mut value_after: Option<f64> = None;
		
				while !success && attempts <=3 {
					attempts += 1;
		
					match client.get("https://www.bitstamp.net/api/v2/ticker/solusd/")
						.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
						.header("X-Auth-Signature", &bitstamp_signature)
						.header("X-Auth-Nonce", &bitstamp_nonce)
						.header("X-Auth-Timestamp", &bitstamp_timestamp)
						.header("X-Auth-Version", "v2")
						.build() {
						Ok(bitstamp_request) => {
							match client.execute(bitstamp_request).await {
								Ok(bitstamp_response) => {
									match bitstamp_response.text().await {
										Ok(bitstamp_response_text) => {
											match serde_json::from_str::<Value>(&bitstamp_response_text) {
												Ok(v) => {
													let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
													let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();
		
													match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
														(Some(bid_str), Some(ask_str)) => {
															match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
																(Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																	
																	// Place your calculations and updates here
																	let kraken_taker_fee = 0.0026;
																	let fraction_of_wallet_im_using = 0.10; //aka 10 percent
																	let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																	let fee_for_purchase = total_spent*kraken_taker_fee;
																	let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																	//03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;

																	let amount_of_sol_before_withdraw_fee = 
																		money_going_to_sol_after_fees/kraken_buy_price_ask
																									.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																									even though to get to this point it had to be Some. 
																									kraken_buy_price_ask: {:?}
																									Honestly restart the program from the last saved state. 
																									The most likely error is a bit got flipped after the loop",
																									&kraken_buy_price_ask));

																	let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;
																	
																	//bitstamp calculations for sell
																	
																	let bitstamp_taker_fee = 0.004;
																	let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
																	let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
																	let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																	*bitstamp_wallet += money_from_sell_after_fees;
																	value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																	if let Some(mut value_after) = value_after {
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is bitstamp and kraken being updated, I will update:
																		//  56, 58, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 58, 59];
																		let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;
																	}
																	//03/08/24 - removed:			
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is bitstamp and kraken being updated, I will update:
																	// //  56, 58, 59
																	// let indices = [56, 58, 59];
																	// let new_values = [value_after, Some(*bitstamp_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;
																	
																	success = true;
																},
																_ => {
																	log::error!("i70: Failed to f64 parse bid or ask price");
																	if attempts > 3 {
																		panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																	}
																	continue;
																}
															}
														},
														_ => {
															log::error!("i70: Failed to originally parse bid or ask price");
															if attempts > 3 {
																panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
															}
															continue;
														}
													}
												},
												Err(_) => {
													log::error!("i70: Failed to parse JSON");
													if attempts > 3 {
														panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
													}
													continue;
												}
											}
										},
										Err(_) => {
											log::error!("i70: failed to get response text");
											if attempts > 3 {
												panic!("Failed to get response text after 3 attempts");
											}
											continue;
										}
									}
								},
								Err(_) => {
									log::error!("i70: Failed to execute request");
									if attempts > 3 {
										panic!("Failed to execute request after 3 attempts");
									}
									continue;
								}
							}
						},
						Err(_) => {
							log::error!("i70: Failed to build request");
							if attempts > 3 {
								panic!("Failed to build request after 3 attempts");
							}
							continue;
						}
					}
				}
		
				match value_after {
					Some(value) => return Ok(value),
					None => {
						//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
						panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
					}
				}











        //println!("response:\n{:?}", kraken_response_text);
        //coinbase calculations - to buy
            //let coinbase_taker_fee = 0.008;

            //let total_spent = 0.01*(*coinbase_wallet);
            //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //new state of coinbase wallet below
            //*coinbase_wallet -= total_spent;
            //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

		//03/02/24 - removed:
			// //kraken calculations - buy
			//     let kraken_taker_fee = 0.0026;
			//     let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
			//     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
			//     let fee_for_purchase = total_spent*kraken_taker_fee;
			//     let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
			//     *kraken_wallet -= money_going_to_sol_after_fees;
			//     let amount_of_sol_before_withdraw_fee = 
			//                     money_going_to_sol_after_fees/kraken_buy_price_ask;
			//     let amount_of_sol = amount_of_sol_before_withdraw_fee - 0.01;

				


			// //coinbase calculations for sell

			//     //let coinbase_taker_fee = 0.008;
			//     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
			//     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
			//     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     //*coinbase_wallet += money_from_sell_after_fees;

			// //bitstamp calculations for sell
			//     let bitstamp_taker_fee = 0.004;
			//     let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     *bitstamp_wallet += money_from_sell_after_fees;


			// //this will count as value after
			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
			//     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



			//         //value_after = 56
			//         //coinbase = 57
			//         //bitstamp = 58
			//         //kraken = 59
			//         //gemini = 60
			//         //since this is bitstamp and kraken being updated, I will update:
			//         //  56, 58, 59
			//         let indices = [56, 58, 59];
			//         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;


			//     return Ok(value_after)

    }
    //DO NOT USE SOL BITSTAMP.
	//end removal//
    pub async fn s_i75_xlm_5_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {



			//03/02/24 - REMOVED:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    



		//03/03/24 - added:
			let now = Utc::now();
			let time_stamp = now.timestamp().to_string();
			let method = "GET";
			let request_path = "/api/v3/brokerage/best_bid_ask";
			let body = "";
			let message = format!("{}{}{}{}", &time_stamp, 
			&method, &request_path, &body);
			type HmacSha256 = Hmac<Sha256>;
			fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
			}
			let coinbase_signature = sign(&message, &coinbase_secret);

			
			let mut coinbase_buy_price_ask: Option<f64> = None;
			let mut attempts = 0;
			let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {
						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														let asks = &pricebook["asks"][0];
														let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_buy_price_ask {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask_str) => {

																		coinbase_buy_price_ask = Some(ask_str);
		
																			success = true;
                                                                    },
                                                                    Err(e) => {
                                                                        log::error!("i75:  coinbase:  Failed to f64 parse JSON.
                                                                        response text: {}
                                                                        error: {}", &text, &e);
                                                                        if attempts > 3 {
                                                                            panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                            error: {}", text, &e);
                                                                        }
                                                                        //03/20/24 - dont see point of all these continues
                                                                        //continue ;
                                                                    }
                                                                }
                                                            },
                                                            None => {
                                                                log::error!("i75: coinbase:   Failed to get ask price
                                                                response text: {}", &text);
                                                                if attempts > 3 {
                                                                    panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                                }
                                                                //continue ;
                                                            }
                                                        }
                                                    }
                                                //03/02/24 - added else condition
                                                } else {
                                                    log::error!("i75:  coinbase:  Failed to get pricebooks as array.
                                                    response text: {}", &text);
                                                    if attempts > 3 {
                                                        panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                    }
                                                    //continue;
                                                }
                                            },
                                            Err(e) => {
                                                log::error!("i75:  coinbase:  Failed to parse outer JSON as str.
                                                response text: {}
                                                error: {}", &text, &e);
                                                if attempts > 3 {
                                                    panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                    response text: {}", text, &e);
                                                }
                                                //continue ; 
                                            }
                                        }
                                    },
                                    Err(e) => {
                                        log::error!("i75:  coinbase:  Failed to get response text.
                                        error: {}", &e);
                                        if attempts > 3 {
                                            panic!("Failed to get response text after 3 attempts
                                            error: {}", &e);
                                        }
                                        //continue ; 
                                    }
                                }
                            },
                            Err(e) => {
                                log::error!("i75:  coinbase:  Failed to execute request
                                error: {}", &e);
                                if attempts > 3 {
                                    panic!("Failed to execute request after 3 attempts
                                    error: {}", &e);
                                }
                                //continue; 
                            }
                        }
                    },
                    Err(e) => {
                        log::error!("i75:  coinbase:  Failed to build request
                        error: {}", &e);
                        if attempts > 3 {
                            panic!("Failed to build request after 3 attempts
                            error: {}", &e);
                        }
                        //continue; 
                    }
                }
                //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
                if success == true {
                    break;
                }
                log::error!("10secwait");
                let when = tokio::time::Instant::now() +
                    tokio::time::Duration::from_secs(10);
                tokio::time::sleep_until(when).await;
            }








    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 5 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
			//03/02/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     //println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    












	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.05; //aka 5 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
																		// Continue with your logic here...
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

																					//03/10/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and kraken being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;

																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 64
																				// let indices = [56, 57, 59];
																				// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i75: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i75: Coinbase buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i75: Failed to parse ask or bid as f64. error: {}", e),
														}
													},
													None => log::error!("i75: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}										
											} 
											else {
												log::error!("i75: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i75: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i75: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i75: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i75: Failed to build kraken request. Error was: {}", e),
			}
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("i75: Failed after 3 attempts");
			}
		}

        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }













			//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            // //this will count as value after
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
    
            //     return Ok(value_after)

    }

	pub async fn s_i76_xlm_6_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {



			//03/02/24 - REMOVED:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    



		//03/03/24 - added:
			let now = Utc::now();
			let time_stamp = now.timestamp().to_string();
			let method = "GET";
			let request_path = "/api/v3/brokerage/best_bid_ask";
			let body = "";
			let message = format!("{}{}{}{}", &time_stamp, 
			&method, &request_path, &body);
			type HmacSha256 = Hmac<Sha256>;
			fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
			}
			let coinbase_signature = sign(&message, &coinbase_secret);

			
			let mut coinbase_buy_price_ask: Option<f64> = None;
			let mut attempts = 0;
			let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {
						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														let asks = &pricebook["asks"][0];
														let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_buy_price_ask {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask_str) => {

																		coinbase_buy_price_ask = Some(ask_str);
		
																			success = true;
                                                                    },
                                                                    Err(e) => {
                                                                        log::error!("i76:  coinbase:  Failed to f64 parse JSON.
                                                                        response text: {}
                                                                        error: {}", &text, &e);
                                                                        if attempts > 3 {
                                                                            panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                            error: {}", text, &e);
                                                                        }
                                                                        //03/20/24 - dont see point of all these continues
                                                                        //continue ;
                                                                    }
                                                                }
                                                            },
                                                            None => {
                                                                log::error!("i76: coinbase:   Failed to get ask price
                                                                response text: {}", &text);
                                                                if attempts > 3 {
                                                                    panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                                }
                                                                //continue ;
                                                            }
                                                        }
                                                    }
                                                //03/02/24 - added else condition
                                                } else {
                                                    log::error!("i76:  coinbase:  Failed to get pricebooks as array.
                                                    response text: {}", &text);
                                                    if attempts > 3 {
                                                        panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                    }
                                                    //continue;
                                                }
                                            },
                                            Err(e) => {
                                                log::error!("i76:  coinbase:  Failed to parse outer JSON as str.
                                                response text: {}
                                                error: {}", &text, &e);
                                                if attempts > 3 {
                                                    panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                    response text: {}", text, &e);
                                                }
                                                //continue ; 
                                            }
                                        }
                                    },
                                    Err(e) => {
                                        log::error!("i76:  coinbase:  Failed to get response text.
                                        error: {}", &e);
                                        if attempts > 3 {
                                            panic!("Failed to get response text after 3 attempts
                                            error: {}", &e);
                                        }
                                        //continue ; 
                                    }
                                }
                            },
                            Err(e) => {
                                log::error!("i76:  coinbase:  Failed to execute request
                                error: {}", &e);
                                if attempts > 3 {
                                    panic!("Failed to execute request after 3 attempts
                                    error: {}", &e);
                                }
                                //continue; 
                            }
                        }
                    },
                    Err(e) => {
                        log::error!("i76:  coinbase:  Failed to build request
                        error: {}", &e);
                        if attempts > 3 {
                            panic!("Failed to build request after 3 attempts
                            error: {}", &e);
                        }
                        //continue; 
                    }
                }
                //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
                if success == true {
                    break;
                }
                log::error!("10secwait");
                let when = tokio::time::Instant::now() +
                    tokio::time::Duration::from_secs(10);
                tokio::time::sleep_until(when).await;
            }








    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 6 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
			//03/02/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     //println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    












	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.06; //aka 6 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
																		// Continue with your logic here...
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

																					//03/10/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and kraken being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;

																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 64
																				// let indices = [56, 57, 59];
																				// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i76: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i76: Coinbase buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i76: Failed to parse ask or bid as f64. error: {}", e),
														}
													},
													None => log::error!("i76: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}										
											} 
											else {
												log::error!("i76: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i76: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i76: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i76: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i76: Failed to build kraken request. Error was: {}", e),
			}
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("i76: Failed after 3 attempts");
			}
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }













			//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            // //this will count as value after
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
    
            //     return Ok(value_after)

    }
    
	pub async fn s_i77_xlm_7_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {



			//03/02/24 - REMOVED:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    



		//03/03/24 - added:
			let now = Utc::now();
			let time_stamp = now.timestamp().to_string();
			let method = "GET";
			let request_path = "/api/v3/brokerage/best_bid_ask";
			let body = "";
			let message = format!("{}{}{}{}", &time_stamp, 
			&method, &request_path, &body);
			type HmacSha256 = Hmac<Sha256>;
			fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
			}
			let coinbase_signature = sign(&message, &coinbase_secret);

			
			let mut coinbase_buy_price_ask: Option<f64> = None;
			let mut attempts = 0;
			let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {
						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														let asks = &pricebook["asks"][0];
														let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_buy_price_ask {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask_str) => {

																		coinbase_buy_price_ask = Some(ask_str);
		
																			success = true;
                                                                    },
                                                                    Err(e) => {
                                                                        log::error!("i77:  coinbase:  Failed to f64 parse JSON.
                                                                        response text: {}
                                                                        error: {}", &text, &e);
                                                                        if attempts > 3 {
                                                                            panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                            error: {}", text, &e);
                                                                        }
                                                                        //03/20/24 - dont see point of all these continues
                                                                        //continue ;
                                                                    }
                                                                }
                                                            },
                                                            None => {
                                                                log::error!("i77: coinbase:   Failed to get ask price
                                                                response text: {}", &text);
                                                                if attempts > 3 {
                                                                    panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                                }
                                                                //continue ;
                                                            }
                                                        }
                                                    }
                                                //03/02/24 - added else condition
                                                } else {
                                                    log::error!("i77:  coinbase:  Failed to get pricebooks as array.
                                                    response text: {}", &text);
                                                    if attempts > 3 {
                                                        panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                    }
                                                    //continue;
                                                }
                                            },
                                            Err(e) => {
                                                log::error!("i77:  coinbase:  Failed to parse outer JSON as str.
                                                response text: {}
                                                error: {}", &text, &e);
                                                if attempts > 3 {
                                                    panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                    response text: {}", text, &e);
                                                }
                                                //continue ; 
                                            }
                                        }
                                    },
                                    Err(e) => {
                                        log::error!("i77:  coinbase:  Failed to get response text.
                                        error: {}", &e);
                                        if attempts > 3 {
                                            panic!("Failed to get response text after 3 attempts
                                            error: {}", &e);
                                        }
                                        //continue ; 
                                    }
                                }
                            },
                            Err(e) => {
                                log::error!("i77:  coinbase:  Failed to execute request
                                error: {}", &e);
                                if attempts > 3 {
                                    panic!("Failed to execute request after 3 attempts
                                    error: {}", &e);
                                }
                                //continue; 
                            }
                        }
                    },
                    Err(e) => {
                        log::error!("i77:  coinbase:  Failed to build request
                        error: {}", &e);
                        if attempts > 3 {
                            panic!("Failed to build request after 3 attempts
                            error: {}", &e);
                        }
                        //continue; 
                    }
                }
                //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
                if success == true {
                    break;
                }
                log::error!("10secwait");
                let when = tokio::time::Instant::now() +
                    tokio::time::Duration::from_secs(10);
                tokio::time::sleep_until(when).await;
            }








    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 7 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
			//03/02/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     //println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    












	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.07; //aka 7 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
																		// Continue with your logic here...
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

																					//03/10/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and kraken being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;

																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 64
																				// let indices = [56, 57, 59];
																				// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i77: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i77: Coinbase buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i77: Failed to parse ask or bid as f64. error: {}", e),
														}
													},
													None => log::error!("i77: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}										
											} 
											else {
												log::error!("i77: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i77: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i77: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i77: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i77: Failed to build kraken request. Error was: {}", e),
			}
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("i77: Failed after 3 attempts");
			}
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }













			//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            // //this will count as value after
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
    
            //     return Ok(value_after)

    }

	pub async fn s_i78_xlm_8_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {



			//03/02/24 - REMOVED:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    



		//03/03/24 - added:
			let now = Utc::now();
			let time_stamp = now.timestamp().to_string();
			let method = "GET";
			let request_path = "/api/v3/brokerage/best_bid_ask";
			let body = "";
			let message = format!("{}{}{}{}", &time_stamp, 
			&method, &request_path, &body);
			type HmacSha256 = Hmac<Sha256>;
			fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
			}
			let coinbase_signature = sign(&message, &coinbase_secret);

			
			let mut coinbase_buy_price_ask: Option<f64> = None;
			let mut attempts = 0;
			let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {
						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														let asks = &pricebook["asks"][0];
														let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_buy_price_ask {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask_str) => {

																		coinbase_buy_price_ask = Some(ask_str);
		
																			success = true;
                                                                    },
                                                                    Err(e) => {
                                                                        log::error!("i78:  coinbase:  Failed to f64 parse JSON.
                                                                        response text: {}
                                                                        error: {}", &text, &e);
                                                                        if attempts > 3 {
                                                                            panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                            error: {}", text, &e);
                                                                        }
                                                                        //03/20/24 - dont see point of all these continues
                                                                        //continue ;
                                                                    }
                                                                }
                                                            },
                                                            None => {
                                                                log::error!("i78: coinbase:   Failed to get ask price
                                                                response text: {}", &text);
                                                                if attempts > 3 {
                                                                    panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                                }
                                                                //continue ;
                                                            }
                                                        }
                                                    }
                                                //03/02/24 - added else condition
                                                } else {
                                                    log::error!("i78:  coinbase:  Failed to get pricebooks as array.
                                                    response text: {}", &text);
                                                    if attempts > 3 {
                                                        panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                    }
                                                    //continue;
                                                }
                                            },
                                            Err(e) => {
                                                log::error!("i78:  coinbase:  Failed to parse outer JSON as str.
                                                response text: {}
                                                error: {}", &text, &e);
                                                if attempts > 3 {
                                                    panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                    response text: {}", text, &e);
                                                }
                                                //continue ; 
                                            }
                                        }
                                    },
                                    Err(e) => {
                                        log::error!("i78:  coinbase:  Failed to get response text.
                                        error: {}", &e);
                                        if attempts > 3 {
                                            panic!("Failed to get response text after 3 attempts
                                            error: {}", &e);
                                        }
                                        //continue ; 
                                    }
                                }
                            },
                            Err(e) => {
                                log::error!("i78:  coinbase:  Failed to execute request
                                error: {}", &e);
                                if attempts > 3 {
                                    panic!("Failed to execute request after 3 attempts
                                    error: {}", &e);
                                }
                                //continue; 
                            }
                        }
                    },
                    Err(e) => {
                        log::error!("i78:  coinbase:  Failed to build request
                        error: {}", &e);
                        if attempts > 3 {
                            panic!("Failed to build request after 3 attempts
                            error: {}", &e);
                        }
                        //continue; 
                    }
                }
                //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
                if success == true {
                    break;
                }
                log::error!("10secwait");
                let when = tokio::time::Instant::now() +
                    tokio::time::Duration::from_secs(10);
                tokio::time::sleep_until(when).await;
            }








    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 8 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
			//03/02/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     //println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    












	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.08; //aka 8 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
																		// Continue with your logic here...
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

																					//03/10/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and kraken being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;

																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 64
																				// let indices = [56, 57, 59];
																				// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i78: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i78: Coinbase buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i78: Failed to parse ask or bid as f64. error: {}", e),
														}
													},
													None => log::error!("i78: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}										
											} 
											else {
												log::error!("i78: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i78: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i78: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i78: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i78: Failed to build kraken request. Error was: {}", e),
			}
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("i78: Failed after 3 attempts");
			}
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }













			//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            // //this will count as value after
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
    
            //     return Ok(value_after)

    }

	pub async fn s_i79_xlm_9_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {



			//03/02/24 - REMOVED:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    



		//03/03/24 - added:
			let now = Utc::now();
			let time_stamp = now.timestamp().to_string();
			let method = "GET";
			let request_path = "/api/v3/brokerage/best_bid_ask";
			let body = "";
			let message = format!("{}{}{}{}", &time_stamp, 
			&method, &request_path, &body);
			type HmacSha256 = Hmac<Sha256>;
			fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
			}
			let coinbase_signature = sign(&message, &coinbase_secret);

			
			let mut coinbase_buy_price_ask: Option<f64> = None;
			let mut attempts = 0;
			let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {
						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														let asks = &pricebook["asks"][0];
														let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_buy_price_ask {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask_str) => {

																		coinbase_buy_price_ask = Some(ask_str);
		
																			success = true;
                                                                    },
                                                                    Err(e) => {
                                                                        log::error!("i79:  coinbase:  Failed to f64 parse JSON.
                                                                        response text: {}
                                                                        error: {}", &text, &e);
                                                                        if attempts > 3 {
                                                                            panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                            error: {}", text, &e);
                                                                        }
                                                                        //03/20/24 - dont see point of all these continues
                                                                        //continue ;
                                                                    }
                                                                }
                                                            },
                                                            None => {
                                                                log::error!("i79: coinbase:   Failed to get ask price
                                                                response text: {}", &text);
                                                                if attempts > 3 {
                                                                    panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                                }
                                                                //continue ;
                                                            }
                                                        }
                                                    }
                                                //03/02/24 - added else condition
                                                } else {
                                                    log::error!("i79:  coinbase:  Failed to get pricebooks as array.
                                                    response text: {}", &text);
                                                    if attempts > 3 {
                                                        panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                    }
                                                    //continue;
                                                }
                                            },
                                            Err(e) => {
                                                log::error!("i79:  coinbase:  Failed to parse outer JSON as str.
                                                response text: {}
                                                error: {}", &text, &e);
                                                if attempts > 3 {
                                                    panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                    response text: {}", text, &e);
                                                }
                                                //continue ; 
                                            }
                                        }
                                    },
                                    Err(e) => {
                                        log::error!("i79:  coinbase:  Failed to get response text.
                                        error: {}", &e);
                                        if attempts > 3 {
                                            panic!("Failed to get response text after 3 attempts
                                            error: {}", &e);
                                        }
                                        //continue ; 
                                    }
                                }
                            },
                            Err(e) => {
                                log::error!("i79:  coinbase:  Failed to execute request
                                error: {}", &e);
                                if attempts > 3 {
                                    panic!("Failed to execute request after 3 attempts
                                    error: {}", &e);
                                }
                                //continue; 
                            }
                        }
                    },
                    Err(e) => {
                        log::error!("i79:  coinbase:  Failed to build request
                        error: {}", &e);
                        if attempts > 3 {
                            panic!("Failed to build request after 3 attempts
                            error: {}", &e);
                        }
                        //continue; 
                    }
                }
                //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
                if success == true {
                    break;
                }
                log::error!("10secwait");
                let when = tokio::time::Instant::now() +
                    tokio::time::Duration::from_secs(10);
                tokio::time::sleep_until(when).await;
            }








    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 9 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
			//03/02/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     //println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    












	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.09; //aka 9 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
																		// Continue with your logic here...
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

																					//03/10/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and kraken being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;

																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 64
																				// let indices = [56, 57, 59];
																				// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i79: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i79 Coinbase buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i79: Failed to parse ask or bid as f64. error: {}", e),
														}
													},
													None => log::error!("i79: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}										
											} 
											else {
												log::error!("i79: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i79: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i79: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i79: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i79: Failed to build kraken request. Error was: {}", e),
			}
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("i79: Failed after 3 attempts");
			}
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }













			//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            // //this will count as value after
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
    
            //     return Ok(value_after)

    }

	pub async fn s_i80_xlm_10_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {



			//03/02/24 - REMOVED:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
    
    
    



		//03/03/24 - added:
			let now = Utc::now();
			let time_stamp = now.timestamp().to_string();
			let method = "GET";
			let request_path = "/api/v3/brokerage/best_bid_ask";
			let body = "";
			let message = format!("{}{}{}{}", &time_stamp, 
			&method, &request_path, &body);
			type HmacSha256 = Hmac<Sha256>;
			fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
			}
			let coinbase_signature = sign(&message, &coinbase_secret);

			
			let mut coinbase_buy_price_ask: Option<f64> = None;
			let mut attempts = 0;
			let mut success = false;
			loop {
				attempts +=1;
				let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
				.header("CB-ACCESS-KEY", coinbase_api_key)
				.header("CB-ACCESS-SIGN", &coinbase_signature)
				.header("CB-ACCESS-TIMESTAMP", &time_stamp)
				.build();

				match request {
					Ok(req) => {
						let response = client.execute(req).await;
						match response {
							Ok(resp) => {
								let response_text = resp.text().await;
								match response_text {
									Ok(text) => {
										match serde_json::from_str::<Value>(&text) {
											Ok(v) => {
												if let Some(pricebooks) = v["pricebooks"].as_array() {
													for pricebook in pricebooks {
														let asks = &pricebook["asks"][0];
														let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
			
														match before_parse_coinbase_buy_price_ask {
															Some(ask_str) => {
																match ask_str.parse::<f64>() {
																	Ok(ask_str) => {

																		coinbase_buy_price_ask = Some(ask_str);
		
																			success = true;
                                                                    },
                                                                    Err(e) => {
                                                                        log::error!("i80:  coinbase:  Failed to f64 parse JSON.
                                                                        response text: {}
                                                                        error: {}", &text, &e);
                                                                        if attempts > 3 {
                                                                            panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                            error: {}", text, &e);
                                                                        }
                                                                        //03/20/24 - dont see point of all these continues
                                                                        //continue ;
                                                                    }
                                                                }
                                                            },
                                                            None => {
                                                                log::error!("i80: coinbase:   Failed to get ask price
                                                                response text: {}", &text);
                                                                if attempts > 3 {
                                                                    panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                                }
                                                                //continue ;
                                                            }
                                                        }
                                                    }
                                                //03/02/24 - added else condition
                                                } else {
                                                    log::error!("i80:  coinbase:  Failed to get pricebooks as array.
                                                    response text: {}", &text);
                                                    if attempts > 3 {
                                                        panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                    }
                                                    //continue;
                                                }
                                            },
                                            Err(e) => {
                                                log::error!("i80:  coinbase:  Failed to parse outer JSON as str.
                                                response text: {}
                                                error: {}", &text, &e);
                                                if attempts > 3 {
                                                    panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                    response text: {}", text, &e);
                                                }
                                                //continue ; 
                                            }
                                        }
                                    },
                                    Err(e) => {
                                        log::error!("i80:  coinbase:  Failed to get response text.
                                        error: {}", &e);
                                        if attempts > 3 {
                                            panic!("Failed to get response text after 3 attempts
                                            error: {}", &e);
                                        }
                                        //continue ; 
                                    }
                                }
                            },
                            Err(e) => {
                                log::error!("i80:  coinbase:  Failed to execute request
                                error: {}", &e);
                                if attempts > 3 {
                                    panic!("Failed to execute request after 3 attempts
                                    error: {}", &e);
                                }
                                //continue; 
                            }
                        }
                    },
                    Err(e) => {
                        log::error!("i80:  coinbase:  Failed to build request
                        error: {}", &e);
                        if attempts > 3 {
                            panic!("Failed to build request after 3 attempts
                            error: {}", &e);
                        }
                        //continue; 
                    }
                }
                //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
                if success == true {
                    break;
                }
                log::error!("10secwait");
                let when = tokio::time::Instant::now() +
                    tokio::time::Duration::from_secs(10);
                tokio::time::sleep_until(when).await;
            }








    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 10 coinbase kraken: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;
            
    
    
    
    
    
    
    
    
    
    
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            //		let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
			//03/02/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     //kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     //println!("Ask price: {}", kraken_buy_price_ask);
            //     println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    












	//03/02/24 - added:
		let mut kraken_sell_price_bid: Option<f64> = None;
		let mut value_after: Option<f64> = None;
		let mut attempts = 0;
		loop {
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["b"][0].as_str() {
													Some(bid_str) => {
														match bid_str.parse::<f64>() {
															Ok(bid) => {
																//kraken_buy_price_ask = Some(ask);
																kraken_sell_price_bid = Some(bid);
																// // Continue with your logic here...

																//coinbase calculations
																let coinbase_taker_fee = 0.008;
																let fraction_of_wallet_im_using = 0.10; //aka 10 percent
																let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																let fee_for_purchase = total_spent*coinbase_taker_fee;
																let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																//new state of coinbase wallet below
																*coinbase_wallet -= total_spent;
																
																if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																	if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																		
																		let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
																		// Continue with your logic here...
																		//kraken calculations - for sell
																			let kraken_taker_fee = 0.0026;
																			
																			let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
																			let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																			let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																			*kraken_wallet += money_from_sell_after_fees;
																		
																		
																		
																		//this will count as value after
																				value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																				if let Some(mut value_after) = value_after {

																					//03/10/24 - added for unscaling
																					let value_after_unscaled = value_after;
																					let coinbase_wallet_unscaled = *coinbase_wallet;
																					let kraken_wallet_unscaled = *kraken_wallet;

																					*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																					*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																					value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																					
																					//value_after = 56
																					//coinbase = 57
																					//bitstamp = 58
																					//kraken = 59
																					//gemini = 60
																					//since this is coinbase and kraken being updated, I will update:
																					//  56, 57, 59
																					//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																					let indices = [56, 57, 59];
																					let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																					//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					neural_network.update_input(&indices, &scaled_values).await;

																					//03/09/24 - added for unscaling:
																					value_after = value_after_unscaled;
																					*coinbase_wallet = coinbase_wallet_unscaled;
																					*kraken_wallet = kraken_wallet_unscaled;

                                                                                    //03/13/24 - added:
                                                                                    return Ok(value_after);
																				}
																				//03/08/24 - removed:
																				// //value_after = 56
																				// //coinbase = 57
																				// //bitstamp = 58
																				// //kraken = 59
																				// //gemini = 60
																				// //since this is kraken and gemini being updated, I will update:
																				// //  56, 59, 64
																				// let indices = [56, 57, 59];
																				// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																				// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																				// neural_network.update_input(&indices, &scaled_values).await;
																	}
																	else {
																		log::error!("i80: Kraken sell price is None. Response text was: {}", kraken_response_text);
																	}
																} 
																else {
																	log::error!("i80: Coinbase buy ask is None. Response text was: {}", kraken_response_text);
																}
																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															Err(e) => log::error!("i80: Failed to parse ask or bid as f64. error: {}", e),
														}
													},
													None => log::error!("i80: Failed to get ask or bid as stringResponse text was: {}", kraken_response_text),
												}										
											} 
											else {
												log::error!("i80: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i80: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i80: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i80: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i80: Failed to build kraken request. Error was: {}", e),
			}
            //03/13/24 - removed:
			// if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
			// 	break; // Exit the loop if everything is successful
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
			attempts += 1;
			if attempts >= 3 {
				panic!("i80: Failed after 3 attempts");
			}
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
		// 	}
		// }













			//03/02/24 - removed:
            // //println!("response:\n{:?}", kraken_response_text);
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     let kraken_taker_fee = 0.0026;
                
            //     let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *kraken_wallet += money_from_sell_after_fees;
    
            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    
    
            // //this will count as value after
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
    
            //     return Ok(value_after)

    }

    pub async fn s_i83_xlm_3_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
			//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    








	//03/03/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);

		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match ask_str.parse::<f64>() {
                                                                Ok(ask_str) => {

                                                                    coinbase_buy_price_ask = Some(ask_str);
    
                                                                        success = true;
                                                                },
                                                                Err(e) => {
                                                                    log::error!("i83:  coinbase:  Failed to f64 parse JSON.
                                                                    response text: {}
                                                                    error: {}", &text, &e);
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                        error: {}", text, &e);
                                                                    }
                                                                    //03/20/24 - dont see point of all these continues
                                                                    //continue ;
                                                                }
                                                            }
                                                        },
                                                        None => {
                                                            log::error!("i83: coinbase:   Failed to get ask price
                                                            response text: {}", &text);
                                                            if attempts > 3 {
                                                                panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                            }
                                                            //continue ;
                                                        }
                                                    }
                                                }
                                            //03/02/24 - added else condition
                                            } else {
                                                log::error!("i83:  coinbase:  Failed to get pricebooks as array.
                                                response text: {}", &text);
                                                if attempts > 3 {
                                                    panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                }
                                                //continue;
                                            }
                                        },
                                        Err(e) => {
                                            log::error!("i83:  coinbase:  Failed to parse outer JSON as str.
                                            response text: {}
                                            error: {}", &text, &e);
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                response text: {}", text, &e);
                                            }
                                            //continue ; 
                                        }
                                    }
                                },
                                Err(e) => {
                                    log::error!("i83:  coinbase:  Failed to get response text.
                                    error: {}", &e);
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts
                                        error: {}", &e);
                                    }
                                    //continue ; 
                                }
                            }
                        },
                        Err(e) => {
                            log::error!("i83:  coinbase:  Failed to execute request
                            error: {}", &e);
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts
                                error: {}", &e);
                            }
                            //continue; 
                        }
                    }
                },
                Err(e) => {
                    log::error!("i83:  coinbase:  Failed to build request
                    error: {}", &e);
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts
                        error: {}", &e);
                    }
                    //continue; 
                }
            }
            //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
            if success == true {
                break;
            }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
        }









    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 3 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	//03/03/24 - removed:
		// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		// 		.header("X-Auth-Signature", bitstamp_signature)
		// 		.header("X-Auth-Nonce", bitstamp_nonce)
		// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
		// 		.header("X-Auth-Version", "v2")
		// 		//.header("Content-Type", content_type)
		// 		//.body(payload_string)
		// 		.build()
		// 		.expect("\ncould not build bitstamp_request");

		// 	let bitstamp_response = client.execute(bitstamp_request).await
		// 		.expect("Failed to execute Bitstamp request");
		// 	let bitstamp_response_text = bitstamp_response.text().await
		// 		.expect("Failed to turn response into text");
		// 	//probably dont need "bitstamp" once we transfer this to the actual function
		//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
		//     .expect("Failed to parse JSON");

		// // Extract the bid and ask values
		//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
		//     //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
		//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
		// 	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    









	//03/02/24 - added:
		let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while !success && attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//coinbase calculations to buy
															let coinbase_taker_fee = 0.008;
															let fraction_of_wallet_im_using = 0.03; //aka 3 percent
															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
															let fee_for_purchase = total_spent*coinbase_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*coinbase_wallet -= total_spent;

															let amount_of_xlm = 
															money_going_to_xlm_after_fees/coinbase_buy_price_ask
																							.expect(&format!("i83: coinbase_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							coinbase_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&coinbase_buy_price_ask));

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let coinbase_wallet_unscaled = *coinbase_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is coinbase and bitstamp being updated, I will update:
																//  56, 57, 58
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 57, 58];
																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/09/24 - added for unscaling:
																value_after = value_after_unscaled;
																*coinbase_wallet = coinbase_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i83: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i83: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after 3 attempts. response text: {}", &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i83: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. response text: {}
                                                error: {} ", &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i83: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts. error: {}", &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i83: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attemptserror: {}", &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i83: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after 3 attemptserror: {}", &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

        //03/13/24 - removed:
		match value_after {
			Some(value) => return Ok(value),
			None => {
				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
			}
		}
















			//03/02/24 - removed:
            // //coinbase calculations
            // let coinbase_taker_fee = 0.008;
            // let fraction_of_wallet_used = 0.03;
            // let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            // let fee_for_purchase = total_spent*coinbase_taker_fee;
            // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            // //new state of coinbase wallet below
            // *coinbase_wallet -= total_spent;
            // let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 58
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            //     return Ok(value_after)

    }

    pub async fn s_i84_xlm_4_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
			//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    








	//03/03/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);

		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match ask_str.parse::<f64>() {
                                                                Ok(ask_str) => {

                                                                    coinbase_buy_price_ask = Some(ask_str);
    
                                                                        success = true;
                                                                },
                                                                Err(e) => {
                                                                    log::error!("i84:  coinbase:  Failed to f64 parse JSON.
                                                                    response text: {}
                                                                    error: {}", &text, &e);
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                        error: {}", text, &e);
                                                                    }
                                                                    //03/20/24 - dont see point of all these continues
                                                                    //continue ;
                                                                }
                                                            }
                                                        },
                                                        None => {
                                                            log::error!("i84: coinbase:   Failed to get ask price
                                                            response text: {}", &text);
                                                            if attempts > 3 {
                                                                panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                            }
                                                            //continue ;
                                                        }
                                                    }
                                                }
                                            //03/02/24 - added else condition
                                            } else {
                                                log::error!("i84:  coinbase:  Failed to get pricebooks as array.
                                                response text: {}", &text);
                                                if attempts > 3 {
                                                    panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                }
                                                //continue;
                                            }
                                        },
                                        Err(e) => {
                                            log::error!("i84:  coinbase:  Failed to parse outer JSON as str.
                                            response text: {}
                                            error: {}", &text, &e);
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                response text: {}", text, &e);
                                            }
                                            //continue ; 
                                        }
                                    }
                                },
                                Err(e) => {
                                    log::error!("i84:  coinbase:  Failed to get response text.
                                    error: {}", &e);
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts
                                        error: {}", &e);
                                    }
                                    //continue ; 
                                }
                            }
                        },
                        Err(e) => {
                            log::error!("i84:  coinbase:  Failed to execute request
                            error: {}", &e);
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts
                                error: {}", &e);
                            }
                            //continue; 
                        }
                    }
                },
                Err(e) => {
                    log::error!("i84:  coinbase:  Failed to build request
                    error: {}", &e);
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts
                        error: {}", &e);
                    }
                    //continue; 
                }
            }
            //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
            if success == true {
                break;
            }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
        }









    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 4 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	//03/03/24 - removed:
		// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		// 		.header("X-Auth-Signature", bitstamp_signature)
		// 		.header("X-Auth-Nonce", bitstamp_nonce)
		// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
		// 		.header("X-Auth-Version", "v2")
		// 		//.header("Content-Type", content_type)
		// 		//.body(payload_string)
		// 		.build()
		// 		.expect("\ncould not build bitstamp_request");

		// 	let bitstamp_response = client.execute(bitstamp_request).await
		// 		.expect("Failed to execute Bitstamp request");
		// 	let bitstamp_response_text = bitstamp_response.text().await
		// 		.expect("Failed to turn response into text");
		// 	//probably dont need "bitstamp" once we transfer this to the actual function
		//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
		//     .expect("Failed to parse JSON");

		// // Extract the bid and ask values
		//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
		//     //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
		//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
		// 	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    









	//03/02/24 - added:
		let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while !success && attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//coinbase calculations to buy
															let coinbase_taker_fee = 0.008;
															let fraction_of_wallet_im_using = 0.04; //aka 4 percent
															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
															let fee_for_purchase = total_spent*coinbase_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*coinbase_wallet -= total_spent;

															let amount_of_xlm = 
															money_going_to_xlm_after_fees/coinbase_buy_price_ask
																							.expect(&format!("i84: coinbase_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							coinbase_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&coinbase_buy_price_ask));

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let coinbase_wallet_unscaled = *coinbase_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is coinbase and bitstamp being updated, I will update:
																//  56, 57, 58
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 57, 58];
																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/09/24 - added for unscaling:
																value_after = value_after_unscaled;
																*coinbase_wallet = coinbase_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i84: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i84: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after 3 attempts. response text: {}", &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i84: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. response text: {}
                                                error: {} ", &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i84: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts. error: {}", &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i84: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attemptserror: {}", &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i84: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after 3 attemptserror: {}", &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

		match value_after {
			Some(value) => return Ok(value),
			None => {
				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
			}
		}
















			//03/02/24 - removed:
            // //coinbase calculations
            // let coinbase_taker_fee = 0.008;
            // let fraction_of_wallet_used = 0.03;
            // let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            // let fee_for_purchase = total_spent*coinbase_taker_fee;
            // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            // //new state of coinbase wallet below
            // *coinbase_wallet -= total_spent;
            // let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 58
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            //     return Ok(value_after)

    }

    pub async fn s_i85_xlm_5_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
			//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    








	//03/03/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);

		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match ask_str.parse::<f64>() {
                                                                Ok(ask_str) => {

                                                                    coinbase_buy_price_ask = Some(ask_str);
    
                                                                        success = true;
                                                                },
                                                                Err(e) => {
                                                                    log::error!("i85:  coinbase:  Failed to f64 parse JSON.
                                                                    response text: {}
                                                                    error: {}", &text, &e);
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                        error: {}", text, &e);
                                                                    }
                                                                    //03/20/24 - dont see point of all these continues
                                                                    //continue ;
                                                                }
                                                            }
                                                        },
                                                        None => {
                                                            log::error!("i85: coinbase:   Failed to get ask price
                                                            response text: {}", &text);
                                                            if attempts > 3 {
                                                                panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                            }
                                                            //continue ;
                                                        }
                                                    }
                                                }
                                            //03/02/24 - added else condition
                                            } else {
                                                log::error!("i85:  coinbase:  Failed to get pricebooks as array.
                                                response text: {}", &text);
                                                if attempts > 3 {
                                                    panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                }
                                                //continue;
                                            }
                                        },
                                        Err(e) => {
                                            log::error!("i85:  coinbase:  Failed to parse outer JSON as str.
                                            response text: {}
                                            error: {}", &text, &e);
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                response text: {}", text, &e);
                                            }
                                            //continue ; 
                                        }
                                    }
                                },
                                Err(e) => {
                                    log::error!("i85:  coinbase:  Failed to get response text.
                                    error: {}", &e);
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts
                                        error: {}", &e);
                                    }
                                    //continue ; 
                                }
                            }
                        },
                        Err(e) => {
                            log::error!("i85:  coinbase:  Failed to execute request
                            error: {}", &e);
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts
                                error: {}", &e);
                            }
                            //continue; 
                        }
                    }
                },
                Err(e) => {
                    log::error!("i85:  coinbase:  Failed to build request
                    error: {}", &e);
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts
                        error: {}", &e);
                    }
                    //continue; 
                }
            }
            //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
            if success == true {
                break;
            }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
        }









    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 5 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	//03/03/24 - removed:
		// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		// 		.header("X-Auth-Signature", bitstamp_signature)
		// 		.header("X-Auth-Nonce", bitstamp_nonce)
		// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
		// 		.header("X-Auth-Version", "v2")
		// 		//.header("Content-Type", content_type)
		// 		//.body(payload_string)
		// 		.build()
		// 		.expect("\ncould not build bitstamp_request");

		// 	let bitstamp_response = client.execute(bitstamp_request).await
		// 		.expect("Failed to execute Bitstamp request");
		// 	let bitstamp_response_text = bitstamp_response.text().await
		// 		.expect("Failed to turn response into text");
		// 	//probably dont need "bitstamp" once we transfer this to the actual function
		//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
		//     .expect("Failed to parse JSON");

		// // Extract the bid and ask values
		//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
		//     //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
		//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
		// 	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    









	//03/02/24 - added:
		let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while !success && attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//coinbase calculations to buy
															let coinbase_taker_fee = 0.008;
															let fraction_of_wallet_im_using = 0.05; //aka 5 percent
															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
															let fee_for_purchase = total_spent*coinbase_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*coinbase_wallet -= total_spent;

															let amount_of_xlm = 
															money_going_to_xlm_after_fees/coinbase_buy_price_ask
																							.expect(&format!("i85: coinbase_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							coinbase_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&coinbase_buy_price_ask));

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let coinbase_wallet_unscaled = *coinbase_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is coinbase and bitstamp being updated, I will update:
																//  56, 57, 58
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 57, 58];
																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/09/24 - added for unscaling:
																value_after = value_after_unscaled;
																*coinbase_wallet = coinbase_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i85: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i85: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after 3 attempts. response text: {}", &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i85: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. response text: {}
                                                error: {} ", &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i85: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts. error: {}", &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i85: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attemptserror: {}", &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i85: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after 3 attemptserror: {}", &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

		match value_after {
			Some(value) => return Ok(value),
			None => {
				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
			}
		}
















			//03/02/24 - removed:
            // //coinbase calculations
            // let coinbase_taker_fee = 0.008;
            // let fraction_of_wallet_used = 0.03;
            // let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            // let fee_for_purchase = total_spent*coinbase_taker_fee;
            // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            // //new state of coinbase wallet below
            // *coinbase_wallet -= total_spent;
            // let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 58
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            //     return Ok(value_after)

    }

    pub async fn s_i86_xlm_6_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
			//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    








	//03/03/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);

		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match ask_str.parse::<f64>() {
                                                                Ok(ask_str) => {

                                                                    coinbase_buy_price_ask = Some(ask_str);
    
                                                                        success = true;
                                                                },
                                                                Err(e) => {
                                                                    log::error!("i86:  coinbase:  Failed to f64 parse JSON.
                                                                    response text: {}
                                                                    error: {}", &text, &e);
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                        error: {}", text, &e);
                                                                    }
                                                                    //03/20/24 - dont see point of all these continues
                                                                    //continue ;
                                                                }
                                                            }
                                                        },
                                                        None => {
                                                            log::error!("i86: coinbase:   Failed to get ask price
                                                            response text: {}", &text);
                                                            if attempts > 3 {
                                                                panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                            }
                                                            //continue ;
                                                        }
                                                    }
                                                }
                                            //03/02/24 - added else condition
                                            } else {
                                                log::error!("i86:  coinbase:  Failed to get pricebooks as array.
                                                response text: {}", &text);
                                                if attempts > 3 {
                                                    panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                }
                                                //continue;
                                            }
                                        },
                                        Err(e) => {
                                            log::error!("i86:  coinbase:  Failed to parse outer JSON as str.
                                            response text: {}
                                            error: {}", &text, &e);
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                response text: {}", text, &e);
                                            }
                                            //continue ; 
                                        }
                                    }
                                },
                                Err(e) => {
                                    log::error!("i86:  coinbase:  Failed to get response text.
                                    error: {}", &e);
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts
                                        error: {}", &e);
                                    }
                                    //continue ; 
                                }
                            }
                        },
                        Err(e) => {
                            log::error!("i86:  coinbase:  Failed to execute request
                            error: {}", &e);
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts
                                error: {}", &e);
                            }
                            //continue; 
                        }
                    }
                },
                Err(e) => {
                    log::error!("i86:  coinbase:  Failed to build request
                    error: {}", &e);
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts
                        error: {}", &e);
                    }
                    //continue; 
                }
            }
            //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
            if success == true {
                break;
            }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
        }









    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 6 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	//03/03/24 - removed:
		// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		// 		.header("X-Auth-Signature", bitstamp_signature)
		// 		.header("X-Auth-Nonce", bitstamp_nonce)
		// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
		// 		.header("X-Auth-Version", "v2")
		// 		//.header("Content-Type", content_type)
		// 		//.body(payload_string)
		// 		.build()
		// 		.expect("\ncould not build bitstamp_request");

		// 	let bitstamp_response = client.execute(bitstamp_request).await
		// 		.expect("Failed to execute Bitstamp request");
		// 	let bitstamp_response_text = bitstamp_response.text().await
		// 		.expect("Failed to turn response into text");
		// 	//probably dont need "bitstamp" once we transfer this to the actual function
		//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
		//     .expect("Failed to parse JSON");

		// // Extract the bid and ask values
		//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
		//     //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
		//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
		// 	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    









	//03/02/24 - added:
		let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while !success && attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//coinbase calculations to buy
															let coinbase_taker_fee = 0.008;
															let fraction_of_wallet_im_using = 0.06; //aka 6 percent
															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
															let fee_for_purchase = total_spent*coinbase_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*coinbase_wallet -= total_spent;

															let amount_of_xlm = 
															money_going_to_xlm_after_fees/coinbase_buy_price_ask
																							.expect(&format!("i86: coinbase_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							coinbase_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&coinbase_buy_price_ask));

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let coinbase_wallet_unscaled = *coinbase_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is coinbase and bitstamp being updated, I will update:
																//  56, 57, 58
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 57, 58];
																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/09/24 - added for unscaling:
																value_after = value_after_unscaled;
																*coinbase_wallet = coinbase_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i86: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i86: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after 3 attempts. response text: {}", &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i86: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. response text: {}
                                                error: {} ", &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i86: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts. error: {}", &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i86: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attemptserror: {}", &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i86: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after 3 attemptserror: {}", &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

		match value_after {
			Some(value) => return Ok(value),
			None => {
				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
			}
		}
















			//03/02/24 - removed:
            // //coinbase calculations
            // let coinbase_taker_fee = 0.008;
            // let fraction_of_wallet_used = 0.03;
            // let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            // let fee_for_purchase = total_spent*coinbase_taker_fee;
            // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            // //new state of coinbase wallet below
            // *coinbase_wallet -= total_spent;
            // let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 58
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            //     return Ok(value_after)

    }

    pub async fn s_i87_xlm_7_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
			//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    








	//03/03/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);

		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match ask_str.parse::<f64>() {
                                                                Ok(ask_str) => {

                                                                    coinbase_buy_price_ask = Some(ask_str);
    
                                                                        success = true;
                                                                },
                                                                Err(e) => {
                                                                    log::error!("i87:  coinbase:  Failed to f64 parse JSON.
                                                                    response text: {}
                                                                    error: {}", &text, &e);
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                        error: {}", text, &e);
                                                                    }
                                                                    //03/20/24 - dont see point of all these continues
                                                                    //continue ;
                                                                }
                                                            }
                                                        },
                                                        None => {
                                                            log::error!("i87: coinbase:   Failed to get ask price
                                                            response text: {}", &text);
                                                            if attempts > 3 {
                                                                panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                            }
                                                            //continue ;
                                                        }
                                                    }
                                                }
                                            //03/02/24 - added else condition
                                            } else {
                                                log::error!("i87:  coinbase:  Failed to get pricebooks as array.
                                                response text: {}", &text);
                                                if attempts > 3 {
                                                    panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                }
                                                //continue;
                                            }
                                        },
                                        Err(e) => {
                                            log::error!("i87:  coinbase:  Failed to parse outer JSON as str.
                                            response text: {}
                                            error: {}", &text, &e);
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                response text: {}", text, &e);
                                            }
                                            //continue ; 
                                        }
                                    }
                                },
                                Err(e) => {
                                    log::error!("i87:  coinbase:  Failed to get response text.
                                    error: {}", &e);
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts
                                        error: {}", &e);
                                    }
                                    //continue ; 
                                }
                            }
                        },
                        Err(e) => {
                            log::error!("i87:  coinbase:  Failed to execute request
                            error: {}", &e);
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts
                                error: {}", &e);
                            }
                            //continue; 
                        }
                    }
                },
                Err(e) => {
                    log::error!("i87:  coinbase:  Failed to build request
                    error: {}", &e);
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts
                        error: {}", &e);
                    }
                    //continue; 
                }
            }
            //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
            if success == true {
                break;
            }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
        }









    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 7 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	//03/03/24 - removed:
		// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		// 		.header("X-Auth-Signature", bitstamp_signature)
		// 		.header("X-Auth-Nonce", bitstamp_nonce)
		// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
		// 		.header("X-Auth-Version", "v2")
		// 		//.header("Content-Type", content_type)
		// 		//.body(payload_string)
		// 		.build()
		// 		.expect("\ncould not build bitstamp_request");

		// 	let bitstamp_response = client.execute(bitstamp_request).await
		// 		.expect("Failed to execute Bitstamp request");
		// 	let bitstamp_response_text = bitstamp_response.text().await
		// 		.expect("Failed to turn response into text");
		// 	//probably dont need "bitstamp" once we transfer this to the actual function
		//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
		//     .expect("Failed to parse JSON");

		// // Extract the bid and ask values
		//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
		//     //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
		//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
		// 	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    









	//03/02/24 - added:
		let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while !success && attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//coinbase calculations to buy
															let coinbase_taker_fee = 0.008;
															let fraction_of_wallet_im_using = 0.07; //aka 7 percent
															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
															let fee_for_purchase = total_spent*coinbase_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*coinbase_wallet -= total_spent;

															let amount_of_xlm = 
															money_going_to_xlm_after_fees/coinbase_buy_price_ask
																							.expect(&format!("i87: coinbase_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							coinbase_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&coinbase_buy_price_ask));

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let coinbase_wallet_unscaled = *coinbase_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is coinbase and bitstamp being updated, I will update:
																//  56, 57, 58
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 57, 58];
																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/09/24 - added for unscaling:
																value_after = value_after_unscaled;
																*coinbase_wallet = coinbase_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i87: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i87: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after 3 attempts. response text: {}", &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i87: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. response text: {}
                                                error: {} ", &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i87: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts. error: {}", &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i87: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attemptserror: {}", &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i87: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after 3 attemptserror: {}", &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

		match value_after {
			Some(value) => return Ok(value),
			None => {
				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
			}
		}
















			//03/02/24 - removed:
            // //coinbase calculations
            // let coinbase_taker_fee = 0.008;
            // let fraction_of_wallet_used = 0.03;
            // let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            // let fee_for_purchase = total_spent*coinbase_taker_fee;
            // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            // //new state of coinbase wallet below
            // *coinbase_wallet -= total_spent;
            // let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 58
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            //     return Ok(value_after)

    }

    pub async fn s_i88_xlm_8_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
			//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    








	//03/03/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);

		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match ask_str.parse::<f64>() {
                                                                Ok(ask_str) => {

                                                                    coinbase_buy_price_ask = Some(ask_str);
    
                                                                        success = true;
                                                                },
                                                                Err(e) => {
                                                                    log::error!("i88:  coinbase:  Failed to f64 parse JSON.
                                                                    response text: {}
                                                                    error: {}", &text, &e);
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                        error: {}", text, &e);
                                                                    }
                                                                    //03/20/24 - dont see point of all these continues
                                                                    //continue ;
                                                                }
                                                            }
                                                        },
                                                        None => {
                                                            log::error!("i88: coinbase:   Failed to get ask price
                                                            response text: {}", &text);
                                                            if attempts > 3 {
                                                                panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                            }
                                                            //continue ;
                                                        }
                                                    }
                                                }
                                            //03/02/24 - added else condition
                                            } else {
                                                log::error!("i88:  coinbase:  Failed to get pricebooks as array.
                                                response text: {}", &text);
                                                if attempts > 3 {
                                                    panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                }
                                                //continue;
                                            }
                                        },
                                        Err(e) => {
                                            log::error!("i88:  coinbase:  Failed to parse outer JSON as str.
                                            response text: {}
                                            error: {}", &text, &e);
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                response text: {}", text, &e);
                                            }
                                            //continue ; 
                                        }
                                    }
                                },
                                Err(e) => {
                                    log::error!("i88:  coinbase:  Failed to get response text.
                                    error: {}", &e);
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts
                                        error: {}", &e);
                                    }
                                    //continue ; 
                                }
                            }
                        },
                        Err(e) => {
                            log::error!("i88:  coinbase:  Failed to execute request
                            error: {}", &e);
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts
                                error: {}", &e);
                            }
                            //continue; 
                        }
                    }
                },
                Err(e) => {
                    log::error!("i88:  coinbase:  Failed to build request
                    error: {}", &e);
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts
                        error: {}", &e);
                    }
                    //continue; 
                }
            }
            //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
            if success == true {
                break;
            }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
        }









    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 8 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	//03/03/24 - removed:
		// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		// 		.header("X-Auth-Signature", bitstamp_signature)
		// 		.header("X-Auth-Nonce", bitstamp_nonce)
		// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
		// 		.header("X-Auth-Version", "v2")
		// 		//.header("Content-Type", content_type)
		// 		//.body(payload_string)
		// 		.build()
		// 		.expect("\ncould not build bitstamp_request");

		// 	let bitstamp_response = client.execute(bitstamp_request).await
		// 		.expect("Failed to execute Bitstamp request");
		// 	let bitstamp_response_text = bitstamp_response.text().await
		// 		.expect("Failed to turn response into text");
		// 	//probably dont need "bitstamp" once we transfer this to the actual function
		//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
		//     .expect("Failed to parse JSON");

		// // Extract the bid and ask values
		//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
		//     //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
		//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
		// 	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    









	//03/02/24 - added:
		let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while !success && attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//coinbase calculations to buy
															let coinbase_taker_fee = 0.008;
															let fraction_of_wallet_im_using = 0.08; //aka 8 percent
															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
															let fee_for_purchase = total_spent*coinbase_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*coinbase_wallet -= total_spent;

															let amount_of_xlm = 
															money_going_to_xlm_after_fees/coinbase_buy_price_ask
																							.expect(&format!("i88: coinbase_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							coinbase_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&coinbase_buy_price_ask));

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let coinbase_wallet_unscaled = *coinbase_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is coinbase and bitstamp being updated, I will update:
																//  56, 57, 58
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 57, 58];
																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/09/24 - added for unscaling:
																value_after = value_after_unscaled;
																*coinbase_wallet = coinbase_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i88: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i88: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after {} attempts. response text: {}", &attempts, &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i88: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. response text: {}
                                                error: {} ", &attempts, &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i88: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i88: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attemptserror: {}", &attempts, &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i88: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after {} attemptserror: {}", &attempts, &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

		match value_after {
			Some(value) => return Ok(value),
			None => {
				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
			}
		}
















			//03/02/24 - removed:
            // //coinbase calculations
            // let coinbase_taker_fee = 0.008;
            // let fraction_of_wallet_used = 0.03;
            // let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            // let fee_for_purchase = total_spent*coinbase_taker_fee;
            // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            // //new state of coinbase wallet below
            // *coinbase_wallet -= total_spent;
            // let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 58
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            //     return Ok(value_after)

    }

    pub async fn s_i89_xlm_9_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
			//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    








	//03/03/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);

		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match ask_str.parse::<f64>() {
                                                                Ok(ask_str) => {

                                                                    coinbase_buy_price_ask = Some(ask_str);
    
                                                                        success = true;
                                                                },
                                                                Err(e) => {
                                                                    log::error!("i89:  coinbase:  Failed to f64 parse JSON.
                                                                    response text: {}
                                                                    error: {}", &text, &e);
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                        error: {}", text, &e);
                                                                    }
                                                                    //03/20/24 - dont see point of all these continues
                                                                    //continue ;
                                                                }
                                                            }
                                                        },
                                                        None => {
                                                            log::error!("i89: coinbase:   Failed to get ask price
                                                            response text: {}", &text);
                                                            if attempts > 3 {
                                                                panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                            }
                                                            //continue ;
                                                        }
                                                    }
                                                }
                                            //03/02/24 - added else condition
                                            } else {
                                                log::error!("i89:  coinbase:  Failed to get pricebooks as array.
                                                response text: {}", &text);
                                                if attempts > 3 {
                                                    panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                }
                                                //continue;
                                            }
                                        },
                                        Err(e) => {
                                            log::error!("i89:  coinbase:  Failed to parse outer JSON as str.
                                            response text: {}
                                            error: {}", &text, &e);
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                response text: {}", text, &e);
                                            }
                                            //continue ; 
                                        }
                                    }
                                },
                                Err(e) => {
                                    log::error!("i89:  coinbase:  Failed to get response text.
                                    error: {}", &e);
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts
                                        error: {}", &e);
                                    }
                                    //continue ; 
                                }
                            }
                        },
                        Err(e) => {
                            log::error!("i89:  coinbase:  Failed to execute request
                            error: {}", &e);
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts
                                error: {}", &e);
                            }
                            //continue; 
                        }
                    }
                },
                Err(e) => {
                    log::error!("i89:  coinbase:  Failed to build request
                    error: {}", &e);
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts
                        error: {}", &e);
                    }
                    //continue; 
                }
            }
            //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
            if success == true {
                break;
            }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
        }









    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 9 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	//03/03/24 - removed:
		// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		// 		.header("X-Auth-Signature", bitstamp_signature)
		// 		.header("X-Auth-Nonce", bitstamp_nonce)
		// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
		// 		.header("X-Auth-Version", "v2")
		// 		//.header("Content-Type", content_type)
		// 		//.body(payload_string)
		// 		.build()
		// 		.expect("\ncould not build bitstamp_request");

		// 	let bitstamp_response = client.execute(bitstamp_request).await
		// 		.expect("Failed to execute Bitstamp request");
		// 	let bitstamp_response_text = bitstamp_response.text().await
		// 		.expect("Failed to turn response into text");
		// 	//probably dont need "bitstamp" once we transfer this to the actual function
		//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
		//     .expect("Failed to parse JSON");

		// // Extract the bid and ask values
		//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
		//     //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
		//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
		// 	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    









	//03/02/24 - added:
		let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while !success && attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//coinbase calculations to buy
															let coinbase_taker_fee = 0.008;
															let fraction_of_wallet_im_using = 0.09; //aka 9 percent
															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
															let fee_for_purchase = total_spent*coinbase_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*coinbase_wallet -= total_spent;

															let amount_of_xlm = 
															money_going_to_xlm_after_fees/coinbase_buy_price_ask
																							.expect(&format!("i89: coinbase_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							coinbase_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&coinbase_buy_price_ask));

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let coinbase_wallet_unscaled = *coinbase_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is coinbase and bitstamp being updated, I will update:
																//  56, 57, 58
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 57, 58];
																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/09/24 - added for unscaling:
																value_after = value_after_unscaled;
																*coinbase_wallet = coinbase_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i89: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i89: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after 3 attempts. response text: {}", &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i89: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. response text: {}
                                                error: {} ", &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i89: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts. error: {}", &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i89: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attemptserror: {}", &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i89: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after 3 attemptserror: {}", &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

		match value_after {
			Some(value) => return Ok(value),
			None => {
				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
			}
		}
















			//03/02/24 - removed:
            // //coinbase calculations
            // let coinbase_taker_fee = 0.008;
            // let fraction_of_wallet_used = 0.03;
            // let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            // let fee_for_purchase = total_spent*coinbase_taker_fee;
            // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            // //new state of coinbase wallet below
            // *coinbase_wallet -= total_spent;
            // let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 58
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            //     return Ok(value_after)

    }

    pub async fn s_i90_xlm_10_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
			//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         //let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         //coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }
    
            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    








	//03/03/24 - added:
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
			let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
						.expect("HMAC can take key of any size");
			mac.update(message.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);

		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													let asks = &pricebook["asks"][0];
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match before_parse_coinbase_buy_price_ask {
														Some(ask_str) => {
															match ask_str.parse::<f64>() {
                                                                Ok(ask_str) => {

                                                                    coinbase_buy_price_ask = Some(ask_str);
    
                                                                        success = true;
                                                                },
                                                                Err(e) => {
                                                                    log::error!("i90:  coinbase:  Failed to f64 parse JSON.
                                                                    response text: {}
                                                                    error: {}", &text, &e);
                                                                    if attempts > 3 {
                                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                                        error: {}", text, &e);
                                                                    }
                                                                    //03/20/24 - dont see point of all these continues
                                                                    //continue ;
                                                                }
                                                            }
                                                        },
                                                        None => {
                                                            log::error!("i90: coinbase:   Failed to get ask price
                                                            response text: {}", &text);
                                                            if attempts > 3 {
                                                                panic!("Failed to get ask price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                            }
                                                            //continue ;
                                                        }
                                                    }
                                                }
                                            //03/02/24 - added else condition
                                            } else {
                                                log::error!("i90:  coinbase:  Failed to get pricebooks as array.
                                                response text: {}", &text);
                                                if attempts > 3 {
                                                    panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
                                                }
                                                //continue;
                                            }
                                        },
                                        Err(e) => {
                                            log::error!("i90:  coinbase:  Failed to parse outer JSON as str.
                                            response text: {}
                                            error: {}", &text, &e);
                                            if attempts > 3 {
                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}
                                                response text: {}", text, &e);
                                            }
                                            //continue ; 
                                        }
                                    }
                                },
                                Err(e) => {
                                    log::error!("i90:  coinbase:  Failed to get response text.
                                    error: {}", &e);
                                    if attempts > 3 {
                                        panic!("Failed to get response text after 3 attempts
                                        error: {}", &e);
                                    }
                                    //continue ; 
                                }
                            }
                        },
                        Err(e) => {
                            log::error!("i90:  coinbase:  Failed to execute request
                            error: {}", &e);
                            if attempts > 3 {
                                panic!("Failed to execute request after 3 attempts
                                error: {}", &e);
                            }
                            //continue; 
                        }
                    }
                },
                Err(e) => {
                    log::error!("i90:  coinbase:  Failed to build request
                    error: {}", &e);
                    if attempts > 3 {
                        panic!("Failed to build request after 3 attempts
                        error: {}", &e);
                    }
                    //continue; 
                }
            }
            //03/20/24 - unnecessary. just put the break above. but i will do it later. not trying to change the logic rn
            if success == true {
                break;
            }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
        }









    
    
    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 10 coinbase bitstamp: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;







            //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
	//	nonce is basically a unique id that needs to be different every time you make a request. 
	//	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
	//	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
	//	and just make it a random 36 char string from it.

	
	//the exact same as the Coinbase signature. we'll see if it works
	//apparently it doesnt so I will code comment it out for now
	//fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
	//	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
	//											.expect("HMAC can take key of any size");
	//	mac.update(bitstamp_message.as_bytes());
	//	let result = mac.finalize();
	//	let code_bytes = result.into_bytes();
	//	hex::encode(code_bytes)
	//}

	fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
			.expect("HMAC can take key of any size");
		mac.update(bitstamp_message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
	}
	

	let content_type = "application/x-www-form-urlencoded";
	let payload_string = "offset=1";



	let the_uuid = Uuid::new_v4();
	let bitstamp_nonce = the_uuid.to_string();
	let bitstamp_timestamp = now.timestamp_millis().to_string();
	//let content_type = "application/x-www-form-urlencoded";
	let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
			bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

	let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

	//03/03/24 - removed:
		// 	let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
		// 		.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
		// 		.header("X-Auth-Signature", bitstamp_signature)
		// 		.header("X-Auth-Nonce", bitstamp_nonce)
		// 		.header("X-Auth-Timestamp", bitstamp_timestamp)
		// 		.header("X-Auth-Version", "v2")
		// 		//.header("Content-Type", content_type)
		// 		//.body(payload_string)
		// 		.build()
		// 		.expect("\ncould not build bitstamp_request");

		// 	let bitstamp_response = client.execute(bitstamp_request).await
		// 		.expect("Failed to execute Bitstamp request");
		// 	let bitstamp_response_text = bitstamp_response.text().await
		// 		.expect("Failed to turn response into text");
		// 	//probably dont need "bitstamp" once we transfer this to the actual function
		//     let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
		//     .expect("Failed to parse JSON");

		// // Extract the bid and ask values
		//     let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
		//     //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
		//     //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
		// 	//println!("Bitstamp response:\n{:?}", bitstamp_response_text);
            
    









	//03/02/24 - added:
		let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while !success && attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//coinbase calculations to buy
															let coinbase_taker_fee = 0.008;
															let fraction_of_wallet_im_using = 0.10; //aka 10 percent
															let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
															let fee_for_purchase = total_spent*coinbase_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*coinbase_wallet -= total_spent;

															let amount_of_xlm = 
															money_going_to_xlm_after_fees/coinbase_buy_price_ask
																							.expect(&format!("i90: coinbase_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							coinbase_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&coinbase_buy_price_ask));

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let coinbase_wallet_unscaled = *coinbase_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is coinbase and bitstamp being updated, I will update:
																//  56, 57, 58
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 57, 58];
																let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/09/24 - added for unscaling:
																value_after = value_after_unscaled;
																*coinbase_wallet = coinbase_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i90: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i90: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after 3 attempts. response text: {}", &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i90: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. response text: {}
                                                error: {} ", &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i90: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts. error: {}", &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i90: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after 3 attemptserror: {}", &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i90: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after 3 attemptserror: {}", &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

		match value_after {
			Some(value) => return Ok(value),
			None => {
				//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
				panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
			}
		}
















			//03/02/24 - removed:
            // //coinbase calculations
            // let coinbase_taker_fee = 0.008;
            // let fraction_of_wallet_used = 0.03;
            // let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
            // let fee_for_purchase = total_spent*coinbase_taker_fee;
            // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            // //new state of coinbase wallet below
            // *coinbase_wallet -= total_spent;
            // let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;
    
            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
    
            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
    
            //         //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 58
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
    
            //     return Ok(value_after)

    }

    pub async fn s_i95_xlm_5_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
		//03/03/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // //let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }




    
    
    
		//03/03/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i95: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i95: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i95: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i95: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i95: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i95: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i95: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}













    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 5 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




		//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price_bid = 0.0;
            // //let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         //let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            //}
    











	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {

													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);


																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.05; //aka 5 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_xlm_before_withdraw_fee = 
																			money_going_to_xlm_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_xlm = amount_of_xlm_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is coinbase and kraken being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/09/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i95: failed to parse JSON to f64. response text: {}
                                                                    error: {}", &text, &e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                                        error: {}", &attempts, &text, &e);
																	}
                                                                    //03/26/24 - removed continues. seem unnecessary.
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i95: Failed to get bid. response text: {}
                                                            Bid: {:?}", &text, &before_parse_coinbase_sell_price_bid);
															if attempts > 3 {
																panic!("Failed to get bid after {} attempts. Bid: {:?}
                                                                response text: {}", &attempts, before_parse_coinbase_sell_price_bid, &text);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i95: failed to parse JSON as str. response text: {}
                                            error: {}", &text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                error: {}", &attempts, &text, &e);
											}
											//continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i95: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i95: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts. error: {}", &attempts, &e);
							}
							//continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i95: Failed to build request. error: {}", &e);
					if attempts > 3 {
						panic!("i95: Failed to build request after {} attempts. error: {}", &attempts, &e);
					}
					//continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }














            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


			//03/02/24 - removed:
            // //kraken calculations - buy
            //     let kraken_taker_fee = 0.0026;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*kraken_wallet);
            //     let fee_for_purchase = total_spent*kraken_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of kraken wallet
            //     *kraken_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            // //coinbase calculations - sell
            //     let coinbase_taker_fee = 0.008;
                    
            //     let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *coinbase_wallet += money_from_sell_after_fees;

            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            // //this will count as value after
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
        
    
            // return Ok(value_after)

    }

    pub async fn s_i96_xlm_6_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
		//03/03/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // //let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }




    
    
    
		//03/03/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i96: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i96: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i96: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i96: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i96: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i96: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i96: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}













    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 6 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




		//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price_bid = 0.0;
            // //let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         //let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            //}
    











	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {

													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);


																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.06; //aka 6 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_xlm_before_withdraw_fee = 
																			money_going_to_xlm_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_xlm = amount_of_xlm_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is coinbase and kraken being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/09/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i96: failed to parse JSON to f64. response text: {}
                                                                    error: {}", &text, &e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                                        error: {}", &attempts, &text, &e);
																	}
                                                                    //03/26/24 - removed continues. seem unnecessary.
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i96: Failed to get bid. response text: {}
                                                            Bid: {:?}", &text, &before_parse_coinbase_sell_price_bid);
															if attempts > 3 {
																panic!("Failed to get bid after {} attempts. Bid: {:?}
                                                                response text: {}", &attempts, before_parse_coinbase_sell_price_bid, &text);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i96: failed to parse JSON as str. response text: {}
                                            error: {}", &text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                error: {}", &attempts, &text, &e);
											}
											//continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i96: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i96: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts. error: {}", &attempts, &e);
							}
							//continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i96: Failed to build request. error: {}", &e);
					if attempts > 3 {
						panic!("i96: Failed to build request after {} attempts. error: {}", &attempts, &e);
					}
					//continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }














            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


			//03/02/24 - removed:
            // //kraken calculations - buy
            //     let kraken_taker_fee = 0.0026;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*kraken_wallet);
            //     let fee_for_purchase = total_spent*kraken_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of kraken wallet
            //     *kraken_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            // //coinbase calculations - sell
            //     let coinbase_taker_fee = 0.008;
                    
            //     let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *coinbase_wallet += money_from_sell_after_fees;

            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            // //this will count as value after
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
        
    
            // return Ok(value_after)

    }

    pub async fn s_i97_xlm_7_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
		//03/03/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // //let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }




    
    
    
		//03/03/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i97: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i97: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i97: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i97: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i97: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i97: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i97: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}













    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 7 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




		//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price_bid = 0.0;
            // //let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         //let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            //}
    











	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {

													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);


																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.07; //aka 7 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_xlm_before_withdraw_fee = 
																			money_going_to_xlm_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_xlm = amount_of_xlm_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is coinbase and kraken being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/09/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i97: failed to parse JSON to f64. response text: {}
                                                                    error: {}", &text, &e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                                        error: {}", &attempts, &text, &e);
																	}
                                                                    //03/26/24 - removed continues. seem unnecessary.
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i97: Failed to get bid. response text: {}
                                                            Bid: {:?}", &text, &before_parse_coinbase_sell_price_bid);
															if attempts > 3 {
																panic!("Failed to get bid after {} attempts. Bid: {:?}
                                                                response text: {}", &attempts, before_parse_coinbase_sell_price_bid, &text);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i97: failed to parse JSON as str. response text: {}
                                            error: {}", &text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                error: {}", &attempts, &text, &e);
											}
											//continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i97: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i97: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts. error: {}", &attempts, &e);
							}
							//continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i97: Failed to build request. error: {}", &e);
					if attempts > 3 {
						panic!("i97: Failed to build request after {} attempts. error: {}", &attempts, &e);
					}
					//continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }














            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


			//03/02/24 - removed:
            // //kraken calculations - buy
            //     let kraken_taker_fee = 0.0026;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*kraken_wallet);
            //     let fee_for_purchase = total_spent*kraken_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of kraken wallet
            //     *kraken_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            // //coinbase calculations - sell
            //     let coinbase_taker_fee = 0.008;
                    
            //     let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *coinbase_wallet += money_from_sell_after_fees;

            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            // //this will count as value after
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
        
    
            // return Ok(value_after)

    }

    pub async fn s_i98_xlm_8_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
		//03/03/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // //let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }




    
    
    
		//03/03/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i98: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i98: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i98: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i98: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i98: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i98: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i98: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}













    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 8 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




		//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price_bid = 0.0;
            // //let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         //let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            //}
    











	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {

													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);


																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.08; //aka 8 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_xlm_before_withdraw_fee = 
																			money_going_to_xlm_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_xlm = amount_of_xlm_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is coinbase and kraken being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/09/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i98: failed to parse JSON to f64. response text: {}
                                                                    error: {}", &text, &e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                                        error: {}", &attempts, &text, &e);
																	}
                                                                    //03/26/24 - removed continues. seem unnecessary.
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i98: Failed to get bid. response text: {}
                                                            Bid: {:?}", &text, &before_parse_coinbase_sell_price_bid);
															if attempts > 3 {
																panic!("Failed to get bid after {} attempts. Bid: {:?}
                                                                response text: {}", &attempts, before_parse_coinbase_sell_price_bid, &text);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i98: failed to parse JSON as str. response text: {}
                                            error: {}", &text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                error: {}", &attempts, &text, &e);
											}
											//continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i98: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i98: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts. error: {}", &attempts, &e);
							}
							//continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i98: Failed to build request. error: {}", &e);
					if attempts > 3 {
						panic!("i98: Failed to build request after {} attempts. error: {}", &attempts, &e);
					}
					//continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }














            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


			//03/02/24 - removed:
            // //kraken calculations - buy
            //     let kraken_taker_fee = 0.0026;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*kraken_wallet);
            //     let fee_for_purchase = total_spent*kraken_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of kraken wallet
            //     *kraken_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            // //coinbase calculations - sell
            //     let coinbase_taker_fee = 0.008;
                    
            //     let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *coinbase_wallet += money_from_sell_after_fees;

            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            // //this will count as value after
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
        
    
            // return Ok(value_after)

    }

    pub async fn s_i99_xlm_9_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
		//03/03/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // //let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }




    
    
    
		//03/03/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i99: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i99: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i99: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i99: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i99: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i99: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i99: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}













    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 9 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




		//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price_bid = 0.0;
            // //let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         //let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            //}
    











	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {

													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);


																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.09; //aka 9 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_xlm_before_withdraw_fee = 
																			money_going_to_xlm_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_xlm = amount_of_xlm_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is coinbase and kraken being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/09/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i99: failed to parse JSON to f64. response text: {}
                                                                    error: {}", &text, &e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                                        error: {}", &attempts, &text, &e);
																	}
                                                                    //03/26/24 - removed continues. seem unnecessary.
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i99: Failed to get bid. response text: {}
                                                            Bid: {:?}", &text, &before_parse_coinbase_sell_price_bid);
															if attempts > 3 {
																panic!("Failed to get bid after {} attempts. Bid: {:?}
                                                                response text: {}", &attempts, before_parse_coinbase_sell_price_bid, &text);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i99: failed to parse JSON as str. response text: {}
                                            error: {}", &text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                error: {}", &attempts, &text, &e);
											}
											//continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i99: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i99: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts. error: {}", &attempts, &e);
							}
							//continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i99: Failed to build request. error: {}", &e);
					if attempts > 3 {
						panic!("i99: Failed to build request after {} attempts. error: {}", &attempts, &e);
					}
					//continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }














            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


			//03/02/24 - removed:
            // //kraken calculations - buy
            //     let kraken_taker_fee = 0.0026;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*kraken_wallet);
            //     let fee_for_purchase = total_spent*kraken_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of kraken wallet
            //     *kraken_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            // //coinbase calculations - sell
            //     let coinbase_taker_fee = 0.008;
                    
            //     let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *coinbase_wallet += money_from_sell_after_fees;

            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            // //this will count as value after
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
        
    
            // return Ok(value_after)

    }

    pub async fn s_i100_xlm_10_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
    
            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XLMUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
		//03/03/24 - removed:
            // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            // //.body is nonce because in the Kraken code provided in cURL: 
            // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            // //--data-urlencode "nonce=<YOUR-NONCE>"
            // //		this means that nonce is added to the body of the request
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
    
    
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
    
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut kraken_buy_price_ask = 0.0;
            // //let mut kraken_sell_price_bid = 0.0;
            // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
            
            //     println!("i95 kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }




    
    
    
		//03/03/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i100: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i100: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i100: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i100: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i100: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i100: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i100: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}













    
    
    
    
    
    
            //02/09/24 - updated tokio. removed:  
                //delay_for(Duration::from_secs(3)).await;
            //02/09/24 - updated tokio. added in its place:
                println!("xlm 10 kraken coinbase: 5 sec delay");
                let when = tokio::time::Instant::now() + Duration::from_secs(5);
                tokio::time::sleep_until(when).await;




		//03/02/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);
    
            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build().map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};
    
            // let response = client.execute(request).await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};
    
    
            // let response_text = response.text().await.map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
    
            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
            // let mut coinbase_sell_price_bid = 0.0;
            // //let mut coinbase_buy_price_ask = 0.0;
    
            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         //let product_id = pricebook["product_id"].as_str().unwrap_or("");
            //         let bids = &pricebook["bids"][0];
            //         //let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().unwrap_or("price not found").parse::<f64>().unwrap_or(-1.0);
            //         let bid_size = bids["size"].as_str().unwrap_or("size not found");
            //         //coinbase_buy_price_ask = asks["price"].as_str().unwrap_or("ask price not found").parse::<f64>().unwrap_or(-1.0);
            //         //let ask_size = asks["size"].as_str().unwrap_or("ask size not found");
            
            //         //println!("Product ID: {}", product_id);
            //         println!("i95 Best sell bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            //}
    











	//03/02/24 - added:
		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);



		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XLM-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {

					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {

													let bids = &pricebook["bids"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();

													match before_parse_coinbase_sell_price_bid {
														Some(bid_str) => {
															match bid_str.parse::<f64>() {
																Ok(bid_str) => {
																	coinbase_sell_price_bid = Some(bid_str);


																	// Place your calculations and updates here
																		let kraken_taker_fee = 0.0026;
																		let fraction_of_wallet_im_using = 0.10; //aka 10 percent
																		let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																		let fee_for_purchase = total_spent*kraken_taker_fee;
																		let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
																		//03/05/24 - changed from -= money_going_to_sol_after_fees to
																		//				  total_spent;
																		*kraken_wallet -= total_spent;

																		let amount_of_xlm_before_withdraw_fee = 
																			money_going_to_xlm_after_fees/kraken_buy_price_ask
																										.expect(&format!("kraken_buy_price_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										kraken_buy_price_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&kraken_buy_price_ask));

																		let amount_of_xlm = amount_of_xlm_before_withdraw_fee - 0.01;

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let coinbase_wallet_unscaled = *coinbase_wallet;
																			let kraken_wallet_unscaled = *kraken_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is coinbase and kraken being updated, I will update:
																			//  56, 57, 59
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 59];
																			let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/09/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;
																			*kraken_wallet = kraken_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 59];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
																		// success = true;
																},
																Err(e) => {
																	log::error!("i100: failed to parse JSON to f64. response text: {}
                                                                    error: {}", &text, &e);
																	if attempts > 3 {
																		panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                                        error: {}", &attempts, &text, &e);
																	}
                                                                    //03/26/24 - removed continues. seem unnecessary.
																	//continue ;
																}
															}
														},
														None => {
															log::error!("i100: Failed to get bid. response text: {}
                                                            Bid: {:?}", &text, &before_parse_coinbase_sell_price_bid);
															if attempts > 3 {
																panic!("Failed to get bid after {} attempts. Bid: {:?}
                                                                response text: {}", &attempts, before_parse_coinbase_sell_price_bid, &text);
															}
															//continue ;
														}
													}
												}
											}
										},
										Err(e) => {
											log::error!("i100: failed to parse JSON as str. response text: {}
                                            error: {}", &text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. Response text: {}
                                                error: {}", &attempts, &text, &e);
											}
											//continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(e) => {
									log::error!("i100: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(e) => {
							log::error!("i100: Failed to execute request. error: {}", e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attempts. error: {}", &attempts, &e);
							}
							//continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(e) => {
					log::error!("i100: Failed to build request. error: {}", &e);
					if attempts > 3 {
						panic!("i100: Failed to build request after {} attempts. error: {}", &attempts, &e);
					}
					//continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }














            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};
    
            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);
    
            //println!("response:\n{:?}", kraken_response_text);
           // //coinbase calculations - buy
                //let coinbase_taker_fee = 0.008;
                //let fraction_of_wallet_used = 0.05;
                //let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
                //let fee_for_purchase = total_spent*coinbase_taker_fee;
                //let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
                ////new state of coinbase wallet below
                //*coinbase_wallet -= total_spent;
                //let amount_of_xlm = money_going_to_xlm_after_fees/coinbase_buy_price_ask;
    
            ////kraken calculations - sell
                //let kraken_taker_fee = 0.0026;
                
                //let money_from_sell_before_fees = amount_of_xlm * kraken_sell_price_bid;
                //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
                //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
                //*kraken_wallet += money_from_sell_after_fees;
    
                //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
    


			//03/02/24 - removed:
            // //kraken calculations - buy
            //     let kraken_taker_fee = 0.0026;
            //     let fraction_of_wallet_used = 0.05;
            //     let total_spent = fraction_of_wallet_used*(*kraken_wallet);
            //     let fee_for_purchase = total_spent*kraken_taker_fee;
            //     let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
            //     //new state of kraken wallet
            //     *kraken_wallet -= total_spent;
            //     let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;
    
            // //coinbase calculations - sell
            //     let coinbase_taker_fee = 0.008;
                    
            //     let money_from_sell_before_fees = amount_of_xlm * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     *coinbase_wallet += money_from_sell_after_fees;

            //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;



            // //this will count as value after
            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 59];
            //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;
        
    
            // return Ok(value_after)

    }

    pub async fn s_i105_xlm_5_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // //let mut kraken_sell_price_bid = 0.0;
        // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }





	//03/05/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i105: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i105: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i105: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i105: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i105: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i105: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i105: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


		println!("xlm 5 kraken bitstamp: 5 sec delay");
		let when = tokio::time::Instant::now() + Duration::from_secs(5);
		tokio::time::sleep_until(when).await;















                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

		//03/05/24 - removed:
        // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
        //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
        //     .header("X-Auth-Signature", bitstamp_signature)
        //     .header("X-Auth-Nonce", bitstamp_nonce)
        //     .header("X-Auth-Timestamp", bitstamp_timestamp)
        //     .header("X-Auth-Version", "v2")
        //     //.header("Content-Type", content_type)
        //     //.body(payload_string)
        //     .build()
        //     .expect("\ncould not build bitstamp_request");

        // let bitstamp_response = client.execute(bitstamp_request).await
        //     .expect("Failed to execute Bitstamp request");
        // let bitstamp_response_text = bitstamp_response.text().await
        //     .expect("Failed to turn response into text");
        // //probably dont need "bitstamp" once we transfer this to the actual function
        // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        // .expect("Failed to parse JSON");

        // // Extract the bid and ask values
        // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        // //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        // println!("Bid: {}", bitstamp_sell_price_bid, );
        // //println!("Ask: {}", bitstamp_buy_price_ask);
        // //println!("Bitstamp response:\n{:?}", bitstamp_response_text);


















	//03/05/24 - added:
        //03/13/24 - removed:
		// let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//kraken calculations - buy
															let kraken_taker_fee = 0.0026;
															let fraction_of_wallet_used = 0.05; //aka 5 percent
															let total_spent = fraction_of_wallet_used*(*kraken_wallet);
															let fee_for_purchase = total_spent*kraken_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*kraken_wallet -= total_spent;

															let amount_of_xlm_before_withdraw_fee = 
															money_going_to_xlm_after_fees/kraken_buy_price_ask
																							.expect(&format!("i105: kraken_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							kraken_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&kraken_buy_price_ask));

															let amount_of_xlm = amount_of_xlm_before_withdraw_fee -0.001;

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let kraken_wallet_unscaled = *kraken_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is bitstamp and kraken being updated, I will update:
																//  56, 58, 59
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 58, 59];
																let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/10/24 - added for unscaling:
																value_after = value_after_unscaled;
																*kraken_wallet = kraken_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i105: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i105: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after {} attempts. response text: {}", &attempts, &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i105: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. response text: {}
                                                error: {} ", &attempts, &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i105: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i105: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attemptserror: {}", &attempts, &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i105: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after {} attemptserror: {}", &attempts, &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
		}
	}
















        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_used = 0.05;
        // let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        // //new state of kraken wallet
        // *kraken_wallet -= total_spent;
        // let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        // //bitstamp calculations
        // let bitstamp_taker_fee = 0.004;
        // let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *bitstamp_wallet += money_from_sell_after_fees;



        // let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        // //value_after = 56
        // //coinbase = 57
        // //bitstamp = 58
        // //kraken = 59
        // //gemini = 60
        // //since this is bitstamp and kraken being updated, I will update:
        // //  56, 58, 59
        // let indices = [56, 58, 59];
        // let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;
        
        // return Ok(value_after)


    }

    pub async fn s_i106_xlm_6_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // //let mut kraken_sell_price_bid = 0.0;
        // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }





	//03/05/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i106: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i106: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i106: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i106: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i106: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i106: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i106: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


		println!("xlm 6 kraken bitstamp: 5 sec delay");
		let when = tokio::time::Instant::now() + Duration::from_secs(5);
		tokio::time::sleep_until(when).await;















                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

		//03/05/24 - removed:
        // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
        //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
        //     .header("X-Auth-Signature", bitstamp_signature)
        //     .header("X-Auth-Nonce", bitstamp_nonce)
        //     .header("X-Auth-Timestamp", bitstamp_timestamp)
        //     .header("X-Auth-Version", "v2")
        //     //.header("Content-Type", content_type)
        //     //.body(payload_string)
        //     .build()
        //     .expect("\ncould not build bitstamp_request");

        // let bitstamp_response = client.execute(bitstamp_request).await
        //     .expect("Failed to execute Bitstamp request");
        // let bitstamp_response_text = bitstamp_response.text().await
        //     .expect("Failed to turn response into text");
        // //probably dont need "bitstamp" once we transfer this to the actual function
        // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        // .expect("Failed to parse JSON");

        // // Extract the bid and ask values
        // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        // //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        // println!("Bid: {}", bitstamp_sell_price_bid, );
        // //println!("Ask: {}", bitstamp_buy_price_ask);
        // //println!("Bitstamp response:\n{:?}", bitstamp_response_text);


















	//03/05/24 - added:
        //03/13/24 - removed:
		// let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//kraken calculations - buy
															let kraken_taker_fee = 0.0026;
															let fraction_of_wallet_used = 0.06; //aka 6 percent
															let total_spent = fraction_of_wallet_used*(*kraken_wallet);
															let fee_for_purchase = total_spent*kraken_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*kraken_wallet -= total_spent;

															let amount_of_xlm_before_withdraw_fee = 
															money_going_to_xlm_after_fees/kraken_buy_price_ask
																							.expect(&format!("i106: kraken_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							kraken_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&kraken_buy_price_ask));

															let amount_of_xlm = amount_of_xlm_before_withdraw_fee -0.001;

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let kraken_wallet_unscaled = *kraken_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is bitstamp and kraken being updated, I will update:
																//  56, 58, 59
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 58, 59];
																let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/10/24 - added for unscaling:
																value_after = value_after_unscaled;
																*kraken_wallet = kraken_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i106: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i106: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after {} attempts. response text: {}", &attempts, &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i106: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. response text: {}
                                                error: {} ", &attempts, &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i106: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i106: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attemptserror: {}", &attempts, &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i106: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after {} attemptserror: {}", &attempts, &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
		}
	}
















        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_used = 0.05;
        // let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        // //new state of kraken wallet
        // *kraken_wallet -= total_spent;
        // let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        // //bitstamp calculations
        // let bitstamp_taker_fee = 0.004;
        // let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *bitstamp_wallet += money_from_sell_after_fees;



        // let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        // //value_after = 56
        // //coinbase = 57
        // //bitstamp = 58
        // //kraken = 59
        // //gemini = 60
        // //since this is bitstamp and kraken being updated, I will update:
        // //  56, 58, 59
        // let indices = [56, 58, 59];
        // let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;
        
        // return Ok(value_after)


    }

    pub async fn s_i107_xlm_7_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // //let mut kraken_sell_price_bid = 0.0;
        // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }





	//03/05/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i107: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i107: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i107: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i107: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i107: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i107: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i107: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


		println!("xlm 7 kraken bitstamp: 5 sec delay");
		let when = tokio::time::Instant::now() + Duration::from_secs(5);
		tokio::time::sleep_until(when).await;















                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

		//03/05/24 - removed:
        // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
        //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
        //     .header("X-Auth-Signature", bitstamp_signature)
        //     .header("X-Auth-Nonce", bitstamp_nonce)
        //     .header("X-Auth-Timestamp", bitstamp_timestamp)
        //     .header("X-Auth-Version", "v2")
        //     //.header("Content-Type", content_type)
        //     //.body(payload_string)
        //     .build()
        //     .expect("\ncould not build bitstamp_request");

        // let bitstamp_response = client.execute(bitstamp_request).await
        //     .expect("Failed to execute Bitstamp request");
        // let bitstamp_response_text = bitstamp_response.text().await
        //     .expect("Failed to turn response into text");
        // //probably dont need "bitstamp" once we transfer this to the actual function
        // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        // .expect("Failed to parse JSON");

        // // Extract the bid and ask values
        // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        // //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        // println!("Bid: {}", bitstamp_sell_price_bid, );
        // //println!("Ask: {}", bitstamp_buy_price_ask);
        // //println!("Bitstamp response:\n{:?}", bitstamp_response_text);


















	//03/05/24 - added:
    //03/13/24 - removed:
		// let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//kraken calculations - buy
															let kraken_taker_fee = 0.0026;
															let fraction_of_wallet_used = 0.07; //aka 7 percent
															let total_spent = fraction_of_wallet_used*(*kraken_wallet);
															let fee_for_purchase = total_spent*kraken_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*kraken_wallet -= total_spent;

															let amount_of_xlm_before_withdraw_fee = 
															money_going_to_xlm_after_fees/kraken_buy_price_ask
																							.expect(&format!("i107: kraken_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							kraken_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&kraken_buy_price_ask));

															let amount_of_xlm = amount_of_xlm_before_withdraw_fee -0.001;

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let kraken_wallet_unscaled = *kraken_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is bitstamp and kraken being updated, I will update:
																//  56, 58, 59
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 58, 59];
																let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/10/24 - added for unscaling:
																value_after = value_after_unscaled;
																*kraken_wallet = kraken_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i107: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i107: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after {} attempts. response text: {}", &attempts, &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i107: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. response text: {}
                                                error: {} ", &attempts, &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i107: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i107: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attemptserror: {}", &attempts, &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i107: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after {} attemptserror: {}", &attempts, &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
		}
	}
















        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_used = 0.05;
        // let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        // //new state of kraken wallet
        // *kraken_wallet -= total_spent;
        // let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        // //bitstamp calculations
        // let bitstamp_taker_fee = 0.004;
        // let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *bitstamp_wallet += money_from_sell_after_fees;



        // let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        // //value_after = 56
        // //coinbase = 57
        // //bitstamp = 58
        // //kraken = 59
        // //gemini = 60
        // //since this is bitstamp and kraken being updated, I will update:
        // //  56, 58, 59
        // let indices = [56, 58, 59];
        // let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;
        
        // return Ok(value_after)


    }

    pub async fn s_i108_xlm_8_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // //let mut kraken_sell_price_bid = 0.0;
        // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }





	//03/05/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i108: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i108: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i108: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i108: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i108: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i108: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i108: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


		println!("xlm 8 kraken bitstamp: 5 sec delay");
		let when = tokio::time::Instant::now() + Duration::from_secs(5);
		tokio::time::sleep_until(when).await;















                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

		//03/05/24 - removed:
        // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
        //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
        //     .header("X-Auth-Signature", bitstamp_signature)
        //     .header("X-Auth-Nonce", bitstamp_nonce)
        //     .header("X-Auth-Timestamp", bitstamp_timestamp)
        //     .header("X-Auth-Version", "v2")
        //     //.header("Content-Type", content_type)
        //     //.body(payload_string)
        //     .build()
        //     .expect("\ncould not build bitstamp_request");

        // let bitstamp_response = client.execute(bitstamp_request).await
        //     .expect("Failed to execute Bitstamp request");
        // let bitstamp_response_text = bitstamp_response.text().await
        //     .expect("Failed to turn response into text");
        // //probably dont need "bitstamp" once we transfer this to the actual function
        // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        // .expect("Failed to parse JSON");

        // // Extract the bid and ask values
        // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        // //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        // println!("Bid: {}", bitstamp_sell_price_bid, );
        // //println!("Ask: {}", bitstamp_buy_price_ask);
        // //println!("Bitstamp response:\n{:?}", bitstamp_response_text);


















	//03/05/24 - added:
        //03/13/24 - removed:
		// let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while  attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//kraken calculations - buy
															let kraken_taker_fee = 0.0026;
															let fraction_of_wallet_used = 0.08; //aka 8 percent
															let total_spent = fraction_of_wallet_used*(*kraken_wallet);
															let fee_for_purchase = total_spent*kraken_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*kraken_wallet -= total_spent;

															let amount_of_xlm_before_withdraw_fee = 
															money_going_to_xlm_after_fees/kraken_buy_price_ask
																							.expect(&format!("i108: kraken_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							kraken_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&kraken_buy_price_ask));

															let amount_of_xlm = amount_of_xlm_before_withdraw_fee -0.001;

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let kraken_wallet_unscaled = *kraken_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is bitstamp and kraken being updated, I will update:
																//  56, 58, 59
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 58, 59];
																let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/10/24 - added for unscaling:
																value_after = value_after_unscaled;
																*kraken_wallet = kraken_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i108: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i108: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after {} attempts. response text: {}", &attempts, &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i108: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. response text: {}
                                                error: {} ", &attempts, &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i108: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i108: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attemptserror: {}", &attempts, &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i108: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after {} attemptserror: {}", &attempts, &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
		}
	}
















        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_used = 0.05;
        // let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        // //new state of kraken wallet
        // *kraken_wallet -= total_spent;
        // let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        // //bitstamp calculations
        // let bitstamp_taker_fee = 0.004;
        // let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *bitstamp_wallet += money_from_sell_after_fees;



        // let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        // //value_after = 56
        // //coinbase = 57
        // //bitstamp = 58
        // //kraken = 59
        // //gemini = 60
        // //since this is bitstamp and kraken being updated, I will update:
        // //  56, 58, 59
        // let indices = [56, 58, 59];
        // let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;
        
        // return Ok(value_after)


    }

    pub async fn s_i109_xlm_9_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // //let mut kraken_sell_price_bid = 0.0;
        // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }





	//03/05/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i109: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i109: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i109: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i109: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i109: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i109: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i109: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


		println!("xlm 9 kraken bitstamp: 5 sec delay");
		let when = tokio::time::Instant::now() + Duration::from_secs(5);
		tokio::time::sleep_until(when).await;















                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

		//03/05/24 - removed:
        // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
        //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
        //     .header("X-Auth-Signature", bitstamp_signature)
        //     .header("X-Auth-Nonce", bitstamp_nonce)
        //     .header("X-Auth-Timestamp", bitstamp_timestamp)
        //     .header("X-Auth-Version", "v2")
        //     //.header("Content-Type", content_type)
        //     //.body(payload_string)
        //     .build()
        //     .expect("\ncould not build bitstamp_request");

        // let bitstamp_response = client.execute(bitstamp_request).await
        //     .expect("Failed to execute Bitstamp request");
        // let bitstamp_response_text = bitstamp_response.text().await
        //     .expect("Failed to turn response into text");
        // //probably dont need "bitstamp" once we transfer this to the actual function
        // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        // .expect("Failed to parse JSON");

        // // Extract the bid and ask values
        // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        // //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        // println!("Bid: {}", bitstamp_sell_price_bid, );
        // //println!("Ask: {}", bitstamp_buy_price_ask);
        // //println!("Bitstamp response:\n{:?}", bitstamp_response_text);


















	//03/05/24 - added:
        //03/13/24 - removed:
		// let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while  attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//kraken calculations - buy
															let kraken_taker_fee = 0.0026;
															let fraction_of_wallet_used = 0.09; //aka 9 percent
															let total_spent = fraction_of_wallet_used*(*kraken_wallet);
															let fee_for_purchase = total_spent*kraken_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*kraken_wallet -= total_spent;

															let amount_of_xlm_before_withdraw_fee = 
															money_going_to_xlm_after_fees/kraken_buy_price_ask
																							.expect(&format!("i109: kraken_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							kraken_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&kraken_buy_price_ask));

															let amount_of_xlm = amount_of_xlm_before_withdraw_fee -0.001;

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let kraken_wallet_unscaled = *kraken_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is bitstamp and kraken being updated, I will update:
																//  56, 58, 59
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 58, 59];
																let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/10/24 - added for unscaling:
																value_after = value_after_unscaled;
																*kraken_wallet = kraken_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i109: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i109: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after {} attempts. response text: {}", &attempts, &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i109: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. response text: {}
                                                error: {} ", &attempts, &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i109: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i109: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attemptserror: {}", &attempts, &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i109: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after {} attemptserror: {}", &attempts, &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
		}
	}
















        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_used = 0.05;
        // let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        // //new state of kraken wallet
        // *kraken_wallet -= total_spent;
        // let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        // //bitstamp calculations
        // let bitstamp_taker_fee = 0.004;
        // let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *bitstamp_wallet += money_from_sell_after_fees;



        // let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        // //value_after = 56
        // //coinbase = 57
        // //bitstamp = 58
        // //kraken = 59
        // //gemini = 60
        // //since this is bitstamp and kraken being updated, I will update:
        // //  56, 58, 59
        // let indices = [56, 58, 59];
        // let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;
        
        // return Ok(value_after)


    }

    pub async fn s_i110_xlm_10_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {
        //look at m, then look at functions to figure out current price of sol at coinbase,
    

    //---KRAKEN--//
    
        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XLMUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
        // //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        // //.body is nonce because in the Kraken code provided in cURL: 
        // //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        // //--data-urlencode "nonce=<YOUR-NONCE>"
        // //		this means that nonce is added to the body of the request
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).map_err(|e| -> Box<dyn std::error::Error + Send> { Box::new(e) })?;
        // let mut kraken_buy_price_ask = 0.0;
        // //let mut kraken_sell_price_bid = 0.0;
        // if let Some(xlmusd) = v["result"]["XXLMZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xlmusd["a"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        //     //kraken_sell_price_bid = xlmusd["b"][0].as_str().unwrap_or("").parse::<f64>().unwrap_or(0.0);
        
        //     println!("i105 kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }





	//03/05/24 - added in its place:
		let mut kraken_buy_price_ask: Option<f64> = None;
		//let mut kraken_sell_price_bid: Option<f64> = None;
		let mut attempts = 0;
		loop {
			attempts += 1;
			let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XLMUSD")
			.header("API-Key", kraken_api_key)
			.header("API-Sign", &kraken_signature)
			.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			.body(format!("nonce={}", nonce))
			.build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xlmusd) = value["result"]["XXLMZUSD"].as_object() {

												match xlmusd["a"][0].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask)=> {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
                                                            //03/26/24 - revamped
															Err(e) => log::error!("i110: Kraken: Failed to parse ask or bid as f64. response text: {}
                                                            error: {}", &kraken_response_text, &e),
														}
													},
													None => log::error!("i110: Kraken: Failed to get ask or bid as string. response text: {}", &kraken_response_text),
												}										
											}
											else {
												log::error!("i110: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i110: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i110: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i110: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i110: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}
            //03/26/24 - added:
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after {} attempts", &attempts);
			}
		}


		println!("xlm 10 kraken bitstamp: 5 sec delay");
		let when = tokio::time::Instant::now() + Duration::from_secs(5);
		tokio::time::sleep_until(when).await;















                //-------------------------Bitstamp---------------------------//
                //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.

        
        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}
        type HmacSha256 = Hmac<Sha256>;
        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }
        

        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








    //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xlm-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

		//03/05/24 - removed:
        // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
        //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
        //     .header("X-Auth-Signature", bitstamp_signature)
        //     .header("X-Auth-Nonce", bitstamp_nonce)
        //     .header("X-Auth-Timestamp", bitstamp_timestamp)
        //     .header("X-Auth-Version", "v2")
        //     //.header("Content-Type", content_type)
        //     //.body(payload_string)
        //     .build()
        //     .expect("\ncould not build bitstamp_request");

        // let bitstamp_response = client.execute(bitstamp_request).await
        //     .expect("Failed to execute Bitstamp request");
        // let bitstamp_response_text = bitstamp_response.text().await
        //     .expect("Failed to turn response into text");
        // //probably dont need "bitstamp" once we transfer this to the actual function
        // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
        // .expect("Failed to parse JSON");

        // // Extract the bid and ask values
        // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
        // //let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
        // println!("Bid: {}", bitstamp_sell_price_bid, );
        // //println!("Ask: {}", bitstamp_buy_price_ask);
        // //println!("Bitstamp response:\n{:?}", bitstamp_response_text);


















	//03/05/24 - added:
        //03/13/24 - removed:
		// let mut success = false;
		let mut attempts = 0;
		let mut value_after: Option<f64> = None;

		while attempts <=3 {
			attempts += 1;

			match client.get("https://www.bitstamp.net/api/v2/ticker/xlmusd/")
				.header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
				.header("X-Auth-Signature", &bitstamp_signature)
				.header("X-Auth-Nonce", &bitstamp_nonce)
				.header("X-Auth-Timestamp", &bitstamp_timestamp)
				.header("X-Auth-Version", "v2")
				.build() {
				Ok(bitstamp_request) => {
					match client.execute(bitstamp_request).await {
						Ok(bitstamp_response) => {
							match bitstamp_response.text().await {
								Ok(bitstamp_response_text) => {
									match serde_json::from_str::<Value>(&bitstamp_response_text) {
										Ok(v) => {
											let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
											//let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

											match before_parse_bitstamp_sell_price_bid {
												Some(bid_str) => {
													match bid_str.parse::<f64>() {
														Ok(bitstamp_sell_price_bid) => {

															// Place your calculations and updates here
															//kraken calculations - buy
															let kraken_taker_fee = 0.0026;
															let fraction_of_wallet_used = 0.10; //aka 10 percent
															let total_spent = fraction_of_wallet_used*(*kraken_wallet);
															let fee_for_purchase = total_spent*kraken_taker_fee;
															let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
															*kraken_wallet -= total_spent;

															let amount_of_xlm_before_withdraw_fee = 
															money_going_to_xlm_after_fees/kraken_buy_price_ask
																							.expect(&format!("i110: kraken_buy_price_ask is somehow Not Some. 
																							even though to get to this point it had to be Some. 
																							kraken_buy_price_ask: {:?}
																							Honestly restart the program from the last saved state. 
																							The most likely error is a bit got flipped after the loop",
																							&kraken_buy_price_ask));

															let amount_of_xlm = amount_of_xlm_before_withdraw_fee -0.001;

															//bitstamp calculations for sell

															let bitstamp_taker_fee = 0.004;
															let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
															let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
															let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
															*bitstamp_wallet += money_from_sell_after_fees;
															value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
															if let Some(mut value_after) = value_after {

																//03/10/24 - added for unscaling
																let value_after_unscaled = value_after;
																let kraken_wallet_unscaled = *kraken_wallet;
																let bitstamp_wallet_unscaled = *bitstamp_wallet;

																*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																
																//value_after = 56
																//coinbase = 57
																//bitstamp = 58
																//kraken = 59
																//gemini = 60
																//since this is bitstamp and kraken being updated, I will update:
																//  56, 58, 59
																//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																let indices = [56, 58, 59];
																let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																neural_network.update_input(&indices, &scaled_values).await;

																//03/10/24 - added for unscaling:
																value_after = value_after_unscaled;
																*kraken_wallet = kraken_wallet_unscaled;
																*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                //03/13/24 - added:
                                                                return Ok(value_after);
															}
															//03/08/24 - removed:
															// //value_after = 56
															// //coinbase = 57
															// //bitstamp = 58
															// //kraken = 59
															// //gemini = 60
															// //since this is coinbase and gemini being updated, I will update:
															// //  56, 57, 60
															// let indices = [56, 57, 58];
															// let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
															// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
															// neural_network.update_input(&indices, &scaled_values).await;

                                                            //03/13/24 - removed:
															// success = true;
														},
														Err(e) => {
															log::error!("i110: Failed to f64 parse bid. response text: {}
                                                            error: {} ", &bitstamp_response_text, &e);
															if attempts > 3 {
																panic!("Failed to parse f64 bid or ask price after 3 attempts. 
                                                                response text: {}
                                                                error: {}", &bitstamp_response_text, &e);
															}
                                                            //03/24/24 - removing continues because no point.
															//continue;
														}
													}
												},
												None => {
													log::error!("i110: Failed to originally parse bid or ask price. reponse text: {}", &bitstamp_response_text);
													if attempts > 3 {
														panic!("Failed to get bid or ask price after {} attempts. response text: {}", &attempts, &bitstamp_response_text);
													}
													//continue;
												}
											}
										},
										Err(e) => {
											log::error!("i110: Failed to parse JSONresponse text: {}
                                            error: {} ", &bitstamp_response_text, &e);
											if attempts > 3 {
												panic!("Failed to parse JSON after {} attempts. response text: {}
                                                error: {} ", &attempts, &bitstamp_response_text, &e);
											}
											//continue;
										}
									}
								},
								Err(e) => {
									log::error!("i110: failed to get response text. error: {}", &e);
									if attempts > 3 {
										panic!("Failed to get response text after {} attempts. error: {}", &attempts, &e);
									}
									//continue;
								}
							}
						},
						Err(e) => {
							log::error!("i110: Failed to execute request. error: {}", &e);
							if attempts > 3 {
								panic!("Failed to execute request after {} attemptserror: {}", &attempts, &e);
							}
							//continue;
						}
					}
				},
				Err(e) => {
					log::error!("i110: Failed to build requesterror: {}", &e);
					if attempts > 3 {
						panic!("Failed to build request after {} attemptserror: {}", &attempts, &e);
					}
					//continue;
				}
			}
            log::error!("10secwait");
            let when = tokio::time::Instant::now() +
                tokio::time::Duration::from_secs(10);
            tokio::time::sleep_until(when).await;
		}

	match value_after {
		Some(value) => return Ok(value),
		None => {
			//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
			panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
		}
	}
















        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_used = 0.05;
        // let total_spent = fraction_of_wallet_used*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xlm_after_fees = total_spent - fee_for_purchase;
        // //new state of kraken wallet
        // *kraken_wallet -= total_spent;
        // let amount_of_xlm = money_going_to_xlm_after_fees/kraken_buy_price_ask - 0.001;


        // //bitstamp calculations
        // let bitstamp_taker_fee = 0.004;
        // let money_from_sell_before_fees = amount_of_xlm * bitstamp_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *bitstamp_wallet += money_from_sell_after_fees;



        // let value_after = *kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        // //value_after = 56
        // //coinbase = 57
        // //bitstamp = 58
        // //kraken = 59
        // //gemini = 60
        // //since this is bitstamp and kraken being updated, I will update:
        // //  56, 58, 59
        // let indices = [56, 58, 59];
        // let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;
        
        // return Ok(value_after)


    }
//xrp
    //coinbase bitstamp = 3 AND UP for min of 10 USD on Bit and Coin
    pub async fn s_i113_xrp_3_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //02/28/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);

            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .expect("couldn't build request");
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};

            // let response = client.execute(request).await.expect("couldn't build response");
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};


            // let response_text = response.text().await.expect("couldn't build response_text");

            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            // let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;

            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
            //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
            //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
            //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);

            //02/28/24 added - 
                let now = Utc::now();
                let time_stamp = now.timestamp().to_string();
                let method = "GET";
                let request_path = "/api/v3/brokerage/best_bid_ask";
                let body = "";
                let message = format!("{}{}{}{}", &time_stamp, 
                &method, &request_path, &body);
                type HmacSha256 = Hmac<Sha256>;
                fn sign(message: &str, coinbase_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                            .expect("HMAC can take key of any size");
                mac.update(message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
                }
                let coinbase_signature = sign(&message, &coinbase_secret);

                
                let mut coinbase_buy_price_ask: Option<f64> = None;
                let mut attempts = 0;
                let mut success = false;
                loop {
                    attempts +=1;
                    let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
                    .header("CB-ACCESS-KEY", coinbase_api_key)
                    .header("CB-ACCESS-SIGN", &coinbase_signature)
                    .header("CB-ACCESS-TIMESTAMP", &time_stamp)
                    .build();

                    match request {
                        Ok(req) => {
                            let response = client.execute(req).await;
                            match response {
                                Ok(resp) => {
                                    let response_text = resp.text().await;
                                    match response_text {
                                        Ok(text) => {
                                            match serde_json::from_str::<Value>(&text) {
                                                Ok(v) => {
                                                    if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                        for pricebook in pricebooks {
                                                            //let product_id = pricebook["product_id"].as_str();
                                                            //let bids = &pricebook["bids"][0];
                                                            let asks = &pricebook["asks"][0];
                                                            //let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                            let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
                
                                                            match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
                                                                (/*Some(bid_str),*/ Some(ask_str)) => {
                                                                    match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
                                                                        (/*Ok(bid_str),*/ Ok(ask_str)) => {
                                                                            //coinbase_sell_price_bid = Some(bid_str);
                                                                            coinbase_buy_price_ask = Some(ask_str);
																			
                                                                                success = true;
                                                                        },
                                                                        _ => {
																			log::error!("i113: coinbase: Failed to parse json into f64");
                                                                            if attempts > 3 {
                                                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                                            }
                                                                            continue ;
                                                                        }
                                                                    }
                                                                },
                                                                _ => {
																	log::error!("i113: coinbase: Failed to get bid price ");
                                                                    if attempts > 3 {
                                                                        //panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
                                                                        panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                                    }
                                                                    continue ;
                                                                }
                                                            }
                                                        }
													//03/02/24 - added else condition
													} else {
														log::error!("i113: coinbase: Failed to get pricebooks as array.");
														if attempts > 3 {
															panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
														}
														continue;
													}
												},
                                                Err(_) => {
													log::error!("i113: coinbase: Failed to parse JSON to str");
                                                    if attempts > 3 {
                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                    }
                                                    continue ; // Continue to the next iteration if parsing fails
                                                }
                                            }
                                        },
                                        Err(_) => {
											log::error!("i113: coinbase: Failed to get response text");
                                            if attempts > 3 {
                                                panic!("Failed to get response text after 3 attempts");
                                            }
                                            continue ; // Continue to the next iteration if getting response text fails
                                        }
                                    }
                                },
                                Err(_) => {
									log::error!("i113: coinbase: Failed to execute request.");
                                    if attempts > 3 {
                                        panic!("Failed to execute request after 3 attempts");
                                    }
                                    continue; // Continue to the next iteration if executing request fails
                                }
                            }
                        },
                        Err(_) => {
							log::error!("i113: coinbase: Failed to build request");
                            if attempts > 3 {
                                panic!("Failed to build request after 3 attempts");
                            }
                            continue; // Continue to the next iteration if building request fails
                        }
                    }
                    if success == true {
                        break;
                    }
                }


















            println!("xrp 3 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        //02/28/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);



        //02/28/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

                                                                // Place your calculations and updates here
                                                                //coinbase calculations to buy
                                                                let coinbase_taker_fee = 0.008;
                                                                let fraction_of_wallet_im_using = 0.03; //aka 3 percent
                                                                let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
                                                                let fee_for_purchase = total_spent*coinbase_taker_fee;
                                                                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                *coinbase_wallet -= total_spent;

                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/coinbase_buy_price_ask
                                                                                                .expect(&format!("coinbase_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                coinbase_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &coinbase_buy_price_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let coinbase_wallet_unscaled = *coinbase_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is coinbase and bitstamp being updated, I will update:
																	//  56, 57, 58
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 57, 58];
																	let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*coinbase_wallet = coinbase_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 57, 58];
                                                                // let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i113: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i113: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i113: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i113: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i113: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i113: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
                }
            }

        //02/28/24 - removed:
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;

            //     let total_spent = 0.07*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;

            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     log::info!("state of: coinbase wallet: {}
            //         kraken wallet: {}
            //         gemini wallet: {}
            //         bitstamp wallet: {}
            //         coinbase buy price ask: {}
            //         bitstamp sell price bid: {}", 
            //             &coinbase_wallet, &kraken_wallet, &gemini_wallet, &bitstamp_wallet, 
            //             &coinbase_buy_price_ask, &bitstamp_sell_price_bid);
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;


            //    return Ok(value_after)

    }

    pub async fn s_i114_xrp_4_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //02/28/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);

            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .expect("couldn't build request");
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};

            // let response = client.execute(request).await.expect("couldn't build response");
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};


            // let response_text = response.text().await.expect("couldn't build response_text");

            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            // let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;

            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
            //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
            //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
            //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);

            //02/28/24 added - 
                let now = Utc::now();
                let time_stamp = now.timestamp().to_string();
                let method = "GET";
                let request_path = "/api/v3/brokerage/best_bid_ask";
                let body = "";
                let message = format!("{}{}{}{}", &time_stamp, 
                &method, &request_path, &body);
                type HmacSha256 = Hmac<Sha256>;
                fn sign(message: &str, coinbase_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                            .expect("HMAC can take key of any size");
                mac.update(message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
                }
                let coinbase_signature = sign(&message, &coinbase_secret);

                
                let mut coinbase_buy_price_ask: Option<f64> = None;
                let mut attempts = 0;
                let mut success = false;
                loop {
                    attempts +=1;
                    let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
                    .header("CB-ACCESS-KEY", coinbase_api_key)
                    .header("CB-ACCESS-SIGN", &coinbase_signature)
                    .header("CB-ACCESS-TIMESTAMP", &time_stamp)
                    .build();

                    match request {
                        Ok(req) => {
                            let response = client.execute(req).await;
                            match response {
                                Ok(resp) => {
                                    let response_text = resp.text().await;
                                    match response_text {
                                        Ok(text) => {
                                            match serde_json::from_str::<Value>(&text) {
                                                Ok(v) => {
                                                    if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                        for pricebook in pricebooks {
                                                            //let product_id = pricebook["product_id"].as_str();
                                                            //let bids = &pricebook["bids"][0];
                                                            let asks = &pricebook["asks"][0];
                                                            //let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                            let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
                
                                                            match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
                                                                (/*Some(bid_str),*/ Some(ask_str)) => {
                                                                    match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
                                                                        (/*Ok(bid_str),*/ Ok(ask_str)) => {
                                                                            //coinbase_sell_price_bid = Some(bid_str);
                                                                            coinbase_buy_price_ask = Some(ask_str);
            
                                                                                success = true;
																			},
																			_ => {
																				log::error!("i114: coinbase: Failed to parse json into f64");
																				if attempts > 3 {
																					panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																				}
																				continue ;
																			}
																		}
																	},
																	_ => {
																		log::error!("i114: coinbase: Failed to get bid price ");
																		if attempts > 3 {
																			//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																			panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
																		}
																		continue ;
																	}
																}
															}
														//03/02/24 - added else condition
														} else {
															log::error!("i114: coinbase: Failed to get pricebooks as array.");
															if attempts > 3 {
																panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
															}
															continue;
														}
													},
													Err(_) => {
														log::error!("i114: coinbase: Failed to parse JSON to str");
														if attempts > 3 {
															panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
														}
														continue ; // Continue to the next iteration if parsing fails
													}
												}
											},
											Err(_) => {
												log::error!("i114: coinbase: Failed to get response text");
												if attempts > 3 {
													panic!("Failed to get response text after 3 attempts");
												}
												continue ; // Continue to the next iteration if getting response text fails
											}
										}
									},
									Err(_) => {
										log::error!("i114: coinbase: Failed to execute request.");
										if attempts > 3 {
											panic!("Failed to execute request after 3 attempts");
										}
										continue; // Continue to the next iteration if executing request fails
									}
								}
							},
							Err(_) => {
								log::error!("i114: coinbase: Failed to build request");
								if attempts > 3 {
									panic!("Failed to build request after 3 attempts");
								}
								continue; // Continue to the next iteration if building request fails
							}
						}
						if success == true {
							break;
						}
					}


















            println!("xrp 4 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        //02/28/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);



        //02/28/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

                                                                // Place your calculations and updates here
                                                                //coinbase calculations to buy
                                                                let coinbase_taker_fee = 0.008;
                                                                let fraction_of_wallet_im_using = 0.04; //aka 4 percent
                                                                let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
                                                                let fee_for_purchase = total_spent*coinbase_taker_fee;
                                                                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                *coinbase_wallet -= total_spent;

                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/coinbase_buy_price_ask
                                                                                                .expect(&format!("coinbase_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                coinbase_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &coinbase_buy_price_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let coinbase_wallet_unscaled = *coinbase_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is coinbase and bitstamp being updated, I will update:
																	//  56, 57, 58
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 57, 58];
																	let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*coinbase_wallet = coinbase_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 57, 58];
                                                                // let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i114: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i114: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i114: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i114: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i114: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i114: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
                }
            }

        //02/28/24 - removed:
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;

            //     let total_spent = 0.07*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;

            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     log::info!("state of: coinbase wallet: {}
            //         kraken wallet: {}
            //         gemini wallet: {}
            //         bitstamp wallet: {}
            //         coinbase buy price ask: {}
            //         bitstamp sell price bid: {}", 
            //             &coinbase_wallet, &kraken_wallet, &gemini_wallet, &bitstamp_wallet, 
            //             &coinbase_buy_price_ask, &bitstamp_sell_price_bid);
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;


            //    return Ok(value_after)

    }

    pub async fn s_i115_xrp_5_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //02/28/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);

            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .expect("couldn't build request");
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};

            // let response = client.execute(request).await.expect("couldn't build response");
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};


            // let response_text = response.text().await.expect("couldn't build response_text");

            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            // let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;

            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
            //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
            //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
            //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);

            //02/28/24 added - 
                let now = Utc::now();
                let time_stamp = now.timestamp().to_string();
                let method = "GET";
                let request_path = "/api/v3/brokerage/best_bid_ask";
                let body = "";
                let message = format!("{}{}{}{}", &time_stamp, 
                &method, &request_path, &body);
                type HmacSha256 = Hmac<Sha256>;
                fn sign(message: &str, coinbase_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                            .expect("HMAC can take key of any size");
                mac.update(message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
                }
                let coinbase_signature = sign(&message, &coinbase_secret);

                
                let mut coinbase_buy_price_ask: Option<f64> = None;
                let mut attempts = 0;
                let mut success = false;
                loop {
                    attempts +=1;
                    let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
                    .header("CB-ACCESS-KEY", coinbase_api_key)
                    .header("CB-ACCESS-SIGN", &coinbase_signature)
                    .header("CB-ACCESS-TIMESTAMP", &time_stamp)
                    .build();

                    match request {
                        Ok(req) => {
                            let response = client.execute(req).await;
                            match response {
                                Ok(resp) => {
                                    let response_text = resp.text().await;
                                    match response_text {
                                        Ok(text) => {
                                            match serde_json::from_str::<Value>(&text) {
                                                Ok(v) => {
                                                    if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                        for pricebook in pricebooks {
                                                            //let product_id = pricebook["product_id"].as_str();
                                                            //let bids = &pricebook["bids"][0];
                                                            let asks = &pricebook["asks"][0];
                                                            //let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                            let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
                
                                                            match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
                                                                (/*Some(bid_str),*/ Some(ask_str)) => {
                                                                    match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
                                                                        (/*Ok(bid_str),*/ Ok(ask_str)) => {
                                                                            //coinbase_sell_price_bid = Some(bid_str);
                                                                            coinbase_buy_price_ask = Some(ask_str);
            
                                                                                success = true;
																			},
																			_ => {
																				log::error!("i115: coinbase: Failed to parse json into f64");
																				if attempts > 3 {
																					panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																				}
																				continue ;
																			}
																		}
																	},
																	_ => {
																		log::error!("i115: coinbase: Failed to get bid price ");
																		if attempts > 3 {
																			//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																			panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
																		}
																		continue ;
																	}
																}
															}
														//03/02/24 - added else condition
														} else {
															log::error!("i115: coinbase: Failed to get pricebooks as array.");
															if attempts > 3 {
																panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
															}
															continue;
														}
													},
													Err(_) => {
														log::error!("i115: coinbase: Failed to parse JSON to str");
														if attempts > 3 {
															panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
														}
														continue ; // Continue to the next iteration if parsing fails
													}
												}
											},
											Err(_) => {
												log::error!("i115: coinbase: Failed to get response text");
												if attempts > 3 {
													panic!("Failed to get response text after 3 attempts");
												}
												continue ; // Continue to the next iteration if getting response text fails
											}
										}
									},
									Err(_) => {
										log::error!("i115: coinbase: Failed to execute request.");
										if attempts > 3 {
											panic!("Failed to execute request after 3 attempts");
										}
										continue; // Continue to the next iteration if executing request fails
									}
								}
							},
							Err(_) => {
								log::error!("i115: coinbase: Failed to build request");
								if attempts > 3 {
									panic!("Failed to build request after 3 attempts");
								}
								continue; // Continue to the next iteration if building request fails
							}
						}
						if success == true {
							break;
						}
					}


















            println!("xrp 5 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        //02/28/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);



        //02/28/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

                                                                // Place your calculations and updates here
                                                                //coinbase calculations to buy
                                                                let coinbase_taker_fee = 0.008;
                                                                let fraction_of_wallet_im_using = 0.05; //aka 5 percent
                                                                let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
                                                                let fee_for_purchase = total_spent*coinbase_taker_fee;
                                                                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                *coinbase_wallet -= total_spent;

                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/coinbase_buy_price_ask
                                                                                                .expect(&format!("coinbase_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                coinbase_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &coinbase_buy_price_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let coinbase_wallet_unscaled = *coinbase_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is coinbase and bitstamp being updated, I will update:
																	//  56, 57, 58
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 57, 58];
																	let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*coinbase_wallet = coinbase_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 57, 58];
                                                                // let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i115: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i115: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i115: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i115: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i115: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i115: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
                }
            }

        //02/28/24 - removed:
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;

            //     let total_spent = 0.07*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;

            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     log::info!("state of: coinbase wallet: {}
            //         kraken wallet: {}
            //         gemini wallet: {}
            //         bitstamp wallet: {}
            //         coinbase buy price ask: {}
            //         bitstamp sell price bid: {}", 
            //             &coinbase_wallet, &kraken_wallet, &gemini_wallet, &bitstamp_wallet, 
            //             &coinbase_buy_price_ask, &bitstamp_sell_price_bid);
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;


            //    return Ok(value_after)

    }

    pub async fn s_i116_xrp_6_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //02/28/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);

            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .expect("couldn't build request");
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};

            // let response = client.execute(request).await.expect("couldn't build response");
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};


            // let response_text = response.text().await.expect("couldn't build response_text");

            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            // let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;

            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
            //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
            //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
            //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);

            //02/28/24 added - 
                let now = Utc::now();
                let time_stamp = now.timestamp().to_string();
                let method = "GET";
                let request_path = "/api/v3/brokerage/best_bid_ask";
                let body = "";
                let message = format!("{}{}{}{}", &time_stamp, 
                &method, &request_path, &body);
                type HmacSha256 = Hmac<Sha256>;
                fn sign(message: &str, coinbase_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                            .expect("HMAC can take key of any size");
                mac.update(message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
                }
                let coinbase_signature = sign(&message, &coinbase_secret);

                
                let mut coinbase_buy_price_ask: Option<f64> = None;
                let mut attempts = 0;
                let mut success = false;
                loop {
                    attempts +=1;
                    let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
                    .header("CB-ACCESS-KEY", coinbase_api_key)
                    .header("CB-ACCESS-SIGN", &coinbase_signature)
                    .header("CB-ACCESS-TIMESTAMP", &time_stamp)
                    .build();

                    match request {
                        Ok(req) => {
                            let response = client.execute(req).await;
                            match response {
                                Ok(resp) => {
                                    let response_text = resp.text().await;
                                    match response_text {
                                        Ok(text) => {
                                            match serde_json::from_str::<Value>(&text) {
                                                Ok(v) => {
                                                    if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                        for pricebook in pricebooks {
                                                            //let product_id = pricebook["product_id"].as_str();
                                                            //let bids = &pricebook["bids"][0];
                                                            let asks = &pricebook["asks"][0];
                                                            //let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                            let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
                
                                                            match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
                                                                (/*Some(bid_str),*/ Some(ask_str)) => {
                                                                    match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
                                                                        (/*Ok(bid_str),*/ Ok(ask_str)) => {
                                                                            //coinbase_sell_price_bid = Some(bid_str);
                                                                            coinbase_buy_price_ask = Some(ask_str);
            
                                                                                success = true;
																			},
																			_ => {
																				log::error!("i116: coinbase: Failed to parse json into f64");
																				if attempts > 3 {
																					panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																				}
																				continue ;
																			}
																		}
																	},
																	_ => {
																		log::error!("i116: coinbase: Failed to get bid price ");
																		if attempts > 3 {
																			//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																			panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
																		}
																		continue ;
																	}
																}
															}
														//03/02/24 - added else condition
														} else {
															log::error!("i116: coinbase: Failed to get pricebooks as array.");
															if attempts > 3 {
																panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
															}
															continue;
														}
													},
													Err(_) => {
														log::error!("i116: coinbase: Failed to parse JSON to str");
														if attempts > 3 {
															panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
														}
														continue ; // Continue to the next iteration if parsing fails
													}
												}
											},
											Err(_) => {
												log::error!("i116: coinbase: Failed to get response text");
												if attempts > 3 {
													panic!("Failed to get response text after 3 attempts");
												}
												continue ; // Continue to the next iteration if getting response text fails
											}
										}
									},
									Err(_) => {
										log::error!("i116: coinbase: Failed to execute request.");
										if attempts > 3 {
											panic!("Failed to execute request after 3 attempts");
										}
										continue; // Continue to the next iteration if executing request fails
									}
								}
							},
							Err(_) => {
								log::error!("i116: coinbase: Failed to build request");
								if attempts > 3 {
									panic!("Failed to build request after 3 attempts");
								}
								continue; // Continue to the next iteration if building request fails
							}
						}
						if success == true {
							break;
						}
					}


















            println!("xrp 6 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        //02/28/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);



        //02/28/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

                                                                // Place your calculations and updates here
                                                                //coinbase calculations to buy
                                                                let coinbase_taker_fee = 0.008;
                                                                let fraction_of_wallet_im_using = 0.06; //aka 6 percent
                                                                let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
                                                                let fee_for_purchase = total_spent*coinbase_taker_fee;
                                                                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                *coinbase_wallet -= total_spent;

                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/coinbase_buy_price_ask
                                                                                                .expect(&format!("coinbase_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                coinbase_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &coinbase_buy_price_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let coinbase_wallet_unscaled = *coinbase_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is coinbase and bitstamp being updated, I will update:
																	//  56, 57, 58
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 57, 58];
																	let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*coinbase_wallet = coinbase_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 57, 58];
                                                                // let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i116: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i116: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i116: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i116: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i116: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i116: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
                }
            }

        //02/28/24 - removed:
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;

            //     let total_spent = 0.07*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;

            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     log::info!("state of: coinbase wallet: {}
            //         kraken wallet: {}
            //         gemini wallet: {}
            //         bitstamp wallet: {}
            //         coinbase buy price ask: {}
            //         bitstamp sell price bid: {}", 
            //             &coinbase_wallet, &kraken_wallet, &gemini_wallet, &bitstamp_wallet, 
            //             &coinbase_buy_price_ask, &bitstamp_sell_price_bid);
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;


            //    return Ok(value_after)

    }

    pub async fn s_i117_xrp_7_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //02/28/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);

            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .expect("couldn't build request");
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};

            // let response = client.execute(request).await.expect("couldn't build response");
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};


            // let response_text = response.text().await.expect("couldn't build response_text");

            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            // let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;

            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
            //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
            //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
            //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);

            //02/28/24 added - 
                let now = Utc::now();
                let time_stamp = now.timestamp().to_string();
                let method = "GET";
                let request_path = "/api/v3/brokerage/best_bid_ask";
                let body = "";
                let message = format!("{}{}{}{}", &time_stamp, 
                &method, &request_path, &body);
                type HmacSha256 = Hmac<Sha256>;
                fn sign(message: &str, coinbase_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                            .expect("HMAC can take key of any size");
                mac.update(message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
                }
                let coinbase_signature = sign(&message, &coinbase_secret);

                
                let mut coinbase_buy_price_ask: Option<f64> = None;
                let mut attempts = 0;
                let mut success = false;
                loop {
                    attempts +=1;
                    let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
                    .header("CB-ACCESS-KEY", coinbase_api_key)
                    .header("CB-ACCESS-SIGN", &coinbase_signature)
                    .header("CB-ACCESS-TIMESTAMP", &time_stamp)
                    .build();

                    match request {
                        Ok(req) => {
                            let response = client.execute(req).await;
                            match response {
                                Ok(resp) => {
                                    let response_text = resp.text().await;
                                    match response_text {
                                        Ok(text) => {
                                            match serde_json::from_str::<Value>(&text) {
                                                Ok(v) => {
                                                    if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                        for pricebook in pricebooks {
                                                            //let product_id = pricebook["product_id"].as_str();
                                                            //let bids = &pricebook["bids"][0];
                                                            let asks = &pricebook["asks"][0];
                                                            //let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                            let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
															
                                                            match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
                                                                (/*Some(bid_str),*/ Some(ask_str)) => {
                                                                    match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
                                                                        (/*Ok(bid_str),*/ Ok(ask_str)) => {
                                                                            //coinbase_sell_price_bid = Some(bid_str);
                                                                            coinbase_buy_price_ask = Some(ask_str);
																			
                                                                                success = true;
																			},
																			_ => {
																				log::error!("i117: coinbase: Failed to parse json into f64");
																				if attempts > 3 {
																					panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																				}
																				continue ;
																			}
																		}
																	},
																	_ => {
																		log::error!("i117: coinbase: Failed to get bid price ");
																		if attempts > 3 {
																			//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																			panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
																		}
																		continue ;
																	}
																}
															}
														//03/02/24 - added else condition
														} else {
															log::error!("i117: coinbase: Failed to get pricebooks as array.");
															if attempts > 3 {
																panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
															}
															continue;
														}
													},
													Err(_) => {
														log::error!("i117: coinbase: Failed to parse JSON to str");
														if attempts > 3 {
															panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
														}
														continue ; // Continue to the next iteration if parsing fails
													}
												}
											},
											Err(_) => {
												log::error!("i117: coinbase: Failed to get response text");
												if attempts > 3 {
													panic!("Failed to get response text after 3 attempts");
												}
												continue ; // Continue to the next iteration if getting response text fails
											}
										}
									},
									Err(_) => {
										log::error!("i117: coinbase: Failed to execute request.");
										if attempts > 3 {
											panic!("Failed to execute request after 3 attempts");
										}
										continue; // Continue to the next iteration if executing request fails
									}
								}
							},
							Err(_) => {
								log::error!("i117: coinbase: Failed to build request");
								if attempts > 3 {
									panic!("Failed to build request after 3 attempts");
								}
								continue; // Continue to the next iteration if building request fails
							}
						}
						if success == true {
							break;
						}
					}


















            println!("xrp 7 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        //02/28/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);



        //02/28/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

                                                                // Place your calculations and updates here
                                                                //coinbase calculations to buy
                                                                let coinbase_taker_fee = 0.008;
                                                                let fraction_of_wallet_im_using = 0.07; //aka 7 percent
                                                                let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
                                                                let fee_for_purchase = total_spent*coinbase_taker_fee;
                                                                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                *coinbase_wallet -= total_spent;

                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/coinbase_buy_price_ask
                                                                                                .expect(&format!("coinbase_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                coinbase_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &coinbase_buy_price_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let coinbase_wallet_unscaled = *coinbase_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is coinbase and bitstamp being updated, I will update:
																	//  56, 57, 58
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 57, 58];
																	let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*coinbase_wallet = coinbase_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 57, 58];
                                                                // let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i117: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i117: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i117: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i117: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i117: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i117: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
                }
            }

        //02/28/24 - removed:
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;

            //     let total_spent = 0.07*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;

            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     log::info!("state of: coinbase wallet: {}
            //         kraken wallet: {}
            //         gemini wallet: {}
            //         bitstamp wallet: {}
            //         coinbase buy price ask: {}
            //         bitstamp sell price bid: {}", 
            //             &coinbase_wallet, &kraken_wallet, &gemini_wallet, &bitstamp_wallet, 
            //             &coinbase_buy_price_ask, &bitstamp_sell_price_bid);
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;


            //    return Ok(value_after)

    }

    pub async fn s_i118_xrp_8_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //02/28/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);

            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .expect("couldn't build request");
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};

            // let response = client.execute(request).await.expect("couldn't build response");
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};


            // let response_text = response.text().await.expect("couldn't build response_text");

            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            // let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;

            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
            //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
            //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
            //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);

            //02/28/24 added - 
                let now = Utc::now();
                let time_stamp = now.timestamp().to_string();
                let method = "GET";
                let request_path = "/api/v3/brokerage/best_bid_ask";
                let body = "";
                let message = format!("{}{}{}{}", &time_stamp, 
                &method, &request_path, &body);
                type HmacSha256 = Hmac<Sha256>;
                fn sign(message: &str, coinbase_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                            .expect("HMAC can take key of any size");
                mac.update(message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
                }
                let coinbase_signature = sign(&message, &coinbase_secret);

                
                let mut coinbase_buy_price_ask: Option<f64> = None;
                let mut attempts = 0;
                let mut success = false;
                loop {
                    attempts +=1;
                    let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
                    .header("CB-ACCESS-KEY", coinbase_api_key)
                    .header("CB-ACCESS-SIGN", &coinbase_signature)
                    .header("CB-ACCESS-TIMESTAMP", &time_stamp)
                    .build();

                    match request {
                        Ok(req) => {
                            let response = client.execute(req).await;
                            match response {
                                Ok(resp) => {
                                    let response_text = resp.text().await;
                                    match response_text {
                                        Ok(text) => {
                                            match serde_json::from_str::<Value>(&text) {
                                                Ok(v) => {
                                                    if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                        for pricebook in pricebooks {
                                                            //let product_id = pricebook["product_id"].as_str();
                                                            //let bids = &pricebook["bids"][0];
                                                            let asks = &pricebook["asks"][0];
                                                            //let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                            let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
                
                                                            match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
                                                                (/*Some(bid_str),*/ Some(ask_str)) => {
                                                                    match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
                                                                        (/*Ok(bid_str),*/ Ok(ask_str)) => {
                                                                            //coinbase_sell_price_bid = Some(bid_str);
                                                                            coinbase_buy_price_ask = Some(ask_str);
            
                                                                                success = true;
                                                                        },
                                                                        _ => {
																			log::error!("i118: coinbase: Failed to parse json into f64");
                                                                            if attempts > 3 {
                                                                                panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                                            }
                                                                            continue ;
                                                                        }
                                                                    }
                                                                },
                                                                _ => {
																	log::error!("i118: coinbase: Failed to get bid price ");
                                                                    if attempts > 3 {
                                                                        //panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
                                                                        panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
                                                                    }
                                                                    continue ;
                                                                }
                                                            }
                                                        }
													//03/02/24 - added else condition
													} else {
														log::error!("i118: coinbase: Failed to get pricebooks as array.");
														if attempts > 3 {
															panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
														}
														continue;
													}
												},
                                                Err(_) => {
													log::error!("i118: coinbase: Failed to parse JSON to str");
                                                    if attempts > 3 {
                                                        panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
                                                    }
                                                    continue ; // Continue to the next iteration if parsing fails
                                                }
                                            }
                                        },
                                        Err(_) => {
											log::error!("i118: coinbase: Failed to get response text");
                                            if attempts > 3 {
                                                panic!("Failed to get response text after 3 attempts");
                                            }
                                            continue ; // Continue to the next iteration if getting response text fails
                                        }
                                    }
                                },
                                Err(_) => {
									log::error!("i118: coinbase: Failed to execute request.");
                                    if attempts > 3 {
                                        panic!("Failed to execute request after 3 attempts");
                                    }
                                    continue; // Continue to the next iteration if executing request fails
                                }
                            }
                        },
                        Err(_) => {
							log::error!("i118: coinbase: Failed to build request");
                            if attempts > 3 {
                                panic!("Failed to build request after 3 attempts");
                            }
                            continue; // Continue to the next iteration if building request fails
                        }
                    }
                    if success == true {
                        break;
                    }
                }


















            println!("xrp 8 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        //02/28/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);



        //02/28/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

                                                                // Place your calculations and updates here
                                                                //coinbase calculations to buy
                                                                let coinbase_taker_fee = 0.008;
                                                                let fraction_of_wallet_im_using = 0.08; //aka 8 percent
                                                                let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
                                                                let fee_for_purchase = total_spent*coinbase_taker_fee;
                                                                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                *coinbase_wallet -= total_spent;

                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/coinbase_buy_price_ask
                                                                                                .expect(&format!("coinbase_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                coinbase_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &coinbase_buy_price_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let coinbase_wallet_unscaled = *coinbase_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is coinbase and bitstamp being updated, I will update:
																	//  56, 57, 58
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 57, 58];
																	let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*coinbase_wallet = coinbase_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 57, 58];
                                                                // let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i118: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i118: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i118: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i118: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i118: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i118: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
                }
            }

        //02/28/24 - removed:
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;

            //     let total_spent = 0.07*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;

            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     log::info!("state of: coinbase wallet: {}
            //         kraken wallet: {}
            //         gemini wallet: {}
            //         bitstamp wallet: {}
            //         coinbase buy price ask: {}
            //         bitstamp sell price bid: {}", 
            //             &coinbase_wallet, &kraken_wallet, &gemini_wallet, &bitstamp_wallet, 
            //             &coinbase_buy_price_ask, &bitstamp_sell_price_bid);
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;


            //    return Ok(value_after)

    }

    pub async fn s_i119_xrp_9_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //02/28/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);

            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .expect("couldn't build request");
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};

            // let response = client.execute(request).await.expect("couldn't build response");
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};


            // let response_text = response.text().await.expect("couldn't build response_text");

            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            // let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;

            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
            //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
            //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
            //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);

            //02/28/24 added - 
                let now = Utc::now();
                let time_stamp = now.timestamp().to_string();
                let method = "GET";
                let request_path = "/api/v3/brokerage/best_bid_ask";
                let body = "";
                let message = format!("{}{}{}{}", &time_stamp, 
                &method, &request_path, &body);
                type HmacSha256 = Hmac<Sha256>;
                fn sign(message: &str, coinbase_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                            .expect("HMAC can take key of any size");
                mac.update(message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
                }
                let coinbase_signature = sign(&message, &coinbase_secret);

                
                let mut coinbase_buy_price_ask: Option<f64> = None;
                let mut attempts = 0;
                let mut success = false;
                loop {
                    attempts +=1;
                    let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
                    .header("CB-ACCESS-KEY", coinbase_api_key)
                    .header("CB-ACCESS-SIGN", &coinbase_signature)
                    .header("CB-ACCESS-TIMESTAMP", &time_stamp)
                    .build();

                    match request {
                        Ok(req) => {
                            let response = client.execute(req).await;
                            match response {
                                Ok(resp) => {
                                    let response_text = resp.text().await;
                                    match response_text {
                                        Ok(text) => {
                                            match serde_json::from_str::<Value>(&text) {
                                                Ok(v) => {
                                                    if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                        for pricebook in pricebooks {
                                                            //let product_id = pricebook["product_id"].as_str();
                                                            //let bids = &pricebook["bids"][0];
                                                            let asks = &pricebook["asks"][0];
                                                            //let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                            let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
                
                                                            match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
                                                                (/*Some(bid_str),*/ Some(ask_str)) => {
                                                                    match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
                                                                        (/*Ok(bid_str),*/ Ok(ask_str)) => {
                                                                            //coinbase_sell_price_bid = Some(bid_str);
                                                                            coinbase_buy_price_ask = Some(ask_str);
            
                                                                                success = true;
																			},
																			_ => {
																				log::error!("i119: coinbase: Failed to parse json into f64");
																				if attempts > 3 {
																					panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																				}
																				continue ;
																			}
																		}
																	},
																	_ => {
																		log::error!("i119: coinbase: Failed to get bid price ");
																		if attempts > 3 {
																			//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																			panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
																		}
																		continue ;
																	}
																}
															}
														//03/02/24 - added else condition
														} else {
															log::error!("i119: coinbase: Failed to get pricebooks as array.");
															if attempts > 3 {
																panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
															}
															continue;
														}
													},
													Err(_) => {
														log::error!("i119: coinbase: Failed to parse JSON to str");
														if attempts > 3 {
															panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
														}
														continue ; // Continue to the next iteration if parsing fails
													}
												}
											},
											Err(_) => {
												log::error!("i119: coinbase: Failed to get response text");
												if attempts > 3 {
													panic!("Failed to get response text after 3 attempts");
												}
												continue ; // Continue to the next iteration if getting response text fails
											}
										}
									},
									Err(_) => {
										log::error!("i119: coinbase: Failed to execute request.");
										if attempts > 3 {
											panic!("Failed to execute request after 3 attempts");
										}
										continue; // Continue to the next iteration if executing request fails
									}
								}
							},
							Err(_) => {
								log::error!("i119: coinbase: Failed to build request");
								if attempts > 3 {
									panic!("Failed to build request after 3 attempts");
								}
								continue; // Continue to the next iteration if building request fails
							}
						}
						if success == true {
							break;
						}
					}


















            println!("xrp 9 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        //02/28/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);



        //02/28/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

                                                                // Place your calculations and updates here
                                                                //coinbase calculations to buy
                                                                let coinbase_taker_fee = 0.008;
                                                                let fraction_of_wallet_im_using = 0.09; //aka 9 percent
                                                                let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
                                                                let fee_for_purchase = total_spent*coinbase_taker_fee;
                                                                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                *coinbase_wallet -= total_spent;

                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/coinbase_buy_price_ask
                                                                                                .expect(&format!("coinbase_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                coinbase_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &coinbase_buy_price_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let coinbase_wallet_unscaled = *coinbase_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is coinbase and bitstamp being updated, I will update:
																	//  56, 57, 58
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 57, 58];
																	let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*coinbase_wallet = coinbase_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 57, 58];
                                                                // let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i119: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i119: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i113: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i119: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i119: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i119: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
                }
            }

        //02/28/24 - removed:
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;

            //     let total_spent = 0.07*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;

            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     log::info!("state of: coinbase wallet: {}
            //         kraken wallet: {}
            //         gemini wallet: {}
            //         bitstamp wallet: {}
            //         coinbase buy price ask: {}
            //         bitstamp sell price bid: {}", 
            //             &coinbase_wallet, &kraken_wallet, &gemini_wallet, &bitstamp_wallet, 
            //             &coinbase_buy_price_ask, &bitstamp_sell_price_bid);
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;


            //    return Ok(value_after)

    }

    pub async fn s_i120_xrp_10_coinbase_bitstamp( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        //02/28/24 - removed:
            // let now = Utc::now();
            // let time_stamp = now.timestamp().to_string();
            // let method = "GET";
            // let request_path = "/api/v3/brokerage/best_bid_ask";
            // let body = "";
            // let message = format!("{}{}{}{}", &time_stamp, 
            // &method, &request_path, &body);
            // type HmacSha256 = Hmac<Sha256>;
            // fn sign(message: &str, coinbase_secret: &str) -> String {
            // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
            //             .expect("HMAC can take key of any size");
            // mac.update(message.as_bytes());
            // let result = mac.finalize();
            // let code_bytes = result.into_bytes();
            // hex::encode(code_bytes)
            // }
            // let coinbase_signature = sign(&message, &coinbase_secret);

            // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            // .header("CB-ACCESS-KEY", coinbase_api_key)
            // .header("CB-ACCESS-SIGN", &coinbase_signature)
            // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            // .build()
            // .expect("couldn't build request");
            // //manages the error I described above
            // //let request = match request {
            // //Ok(req) => req,
            // //Err(e) => {
            // //eprintln!("Failed to build request: \n{}", e);
            // //return Err(e);
            // //}
            // //};

            // let response = client.execute(request).await.expect("couldn't build response");
            // //let response = match response {
            // //    Ok(resp) => resp,
            // //    Err(e) => {
            // //        eprintln!("Failed to execute request: \n{}", e);
            // //        return Err(e);
            // //    }
            // //};


            // let response_text = response.text().await.expect("couldn't build response_text");

            // //added 12/29/23
            // //this is the parsing
            // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
            // let mut coinbase_sell_price_bid = 0.0;
            // let mut coinbase_buy_price_ask = 0.0;

            // // Access the pricebooks array
            // if let Some(pricebooks) = v["pricebooks"].as_array() {
            //     // Iterate over each pricebook
            //     for pricebook in pricebooks {
            //         // Access the product_id, bids, and asks
            //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
            //         let bids = &pricebook["bids"][0];
            //         let asks = &pricebook["asks"][0];
            
            //         // Access the price and size of the bids and asks
            //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
            //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
            //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
            //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
            
            //         //println!("Product ID: {}", product_id);
            //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
            //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
            //     }
            // }

            //manages any errors from line above
            //let response_text = match response_text {
            //    Ok(t) => t,
            //    Err(e) => {
            //        eprintln!("Failed to read response text: \n{}", e);
            //        return;
            //    }
            //};

            //prints the actual response
            //println!("list accounts response\n{:?}", &response_text);

            //02/28/24 added - 
                let now = Utc::now();
                let time_stamp = now.timestamp().to_string();
                let method = "GET";
                let request_path = "/api/v3/brokerage/best_bid_ask";
                let body = "";
                let message = format!("{}{}{}{}", &time_stamp, 
                &method, &request_path, &body);
                type HmacSha256 = Hmac<Sha256>;
                fn sign(message: &str, coinbase_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                            .expect("HMAC can take key of any size");
                mac.update(message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
                }
                let coinbase_signature = sign(&message, &coinbase_secret);

                
                let mut coinbase_buy_price_ask: Option<f64> = None;
                let mut attempts = 0;
                let mut success = false;
                loop {
                    attempts +=1;
                    let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
                    .header("CB-ACCESS-KEY", coinbase_api_key)
                    .header("CB-ACCESS-SIGN", &coinbase_signature)
                    .header("CB-ACCESS-TIMESTAMP", &time_stamp)
                    .build();

                    match request {
                        Ok(req) => {
                            let response = client.execute(req).await;
                            match response {
                                Ok(resp) => {
                                    let response_text = resp.text().await;
                                    match response_text {
                                        Ok(text) => {
                                            match serde_json::from_str::<Value>(&text) {
                                                Ok(v) => {
                                                    if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                        for pricebook in pricebooks {
                                                            //let product_id = pricebook["product_id"].as_str();
                                                            //let bids = &pricebook["bids"][0];
                                                            let asks = &pricebook["asks"][0];
                                                            //let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                            let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
                
                                                            match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
                                                                (/*Some(bid_str),*/ Some(ask_str)) => {
                                                                    match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
                                                                        (/*Ok(bid_str),*/ Ok(ask_str)) => {
                                                                            //coinbase_sell_price_bid = Some(bid_str);
                                                                            coinbase_buy_price_ask = Some(ask_str);
            
                                                                                success = true;
																			},
																			_ => {
																				log::error!("i120: coinbase: Failed to parse json into f64");
																				if attempts > 3 {
																					panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																				}
																				continue ;
																			}
																		}
																	},
																	_ => {
																		log::error!("i120: coinbase: Failed to get bid price ");
																		if attempts > 3 {
																			//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																			panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
																		}
																		continue ;
																	}
																}
															}
														//03/02/24 - added else condition
														} else {
															log::error!("i120: coinbase: Failed to get pricebooks as array.");
															if attempts > 3 {
																panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
															}
															continue;
														}
													},
													Err(_) => {
														log::error!("i120: coinbase: Failed to parse JSON to str");
														if attempts > 3 {
															panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
														}
														continue ; // Continue to the next iteration if parsing fails
													}
												}
											},
											Err(_) => {
												log::error!("i120: coinbase: Failed to get response text");
												if attempts > 3 {
													panic!("Failed to get response text after 3 attempts");
												}
												continue ; // Continue to the next iteration if getting response text fails
											}
										}
									},
									Err(_) => {
										log::error!("i120: coinbase: Failed to execute request.");
										if attempts > 3 {
											panic!("Failed to execute request after 3 attempts");
										}
										continue; // Continue to the next iteration if executing request fails
									}
								}
							},
							Err(_) => {
								log::error!("i120: coinbase: Failed to build request");
								if attempts > 3 {
									panic!("Failed to build request after 3 attempts");
								}
								continue; // Continue to the next iteration if building request fails
							}
						}
						if success == true {
							break;
						}
					}


















            println!("xrp 10 coinbase bitstamp: 8 sec delay");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;












        //-------------------------Bitstamp---------------------------//
                    //Bitstamp for some reason needs nonce to be 36 characters long. 
        //	nonce is basically a unique id that needs to be different every time you make a request. 
        //	usually time-since-UNIX epoch will do but for some reason bitstmap requires both a timestamp
        //	and a nonce. Because of the nonce needing to be 36 chars, it's easier to use a uuid crate 
        //	and just make it a random 36 char string from it.


        //the exact same as the Coinbase signature. we'll see if it works
        //apparently it doesnt so I will code comment it out for now
        //fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
        //	let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
        //											.expect("HMAC can take key of any size");
        //	mac.update(bitstamp_message.as_bytes());
        //	let result = mac.finalize();
        //	let code_bytes = result.into_bytes();
        //	hex::encode(code_bytes)
        //}

        fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
            let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                .expect("HMAC can take key of any size");
            mac.update(bitstamp_message.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            hex::encode(code_bytes)
        }


        let content_type = "application/x-www-form-urlencoded";
        let payload_string = "offset=1";
        //if we needed content_type, it is here
        //let content_type = "application/json";
        //this is the bitstamp message IF we needed content_type
        //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
        //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








        //--------------------Account-balances------------------------------------------//



        let the_uuid = Uuid::new_v4();
        let bitstamp_nonce = the_uuid.to_string();
        let bitstamp_timestamp = now.timestamp_millis().to_string();
        //let content_type = "application/x-www-form-urlencoded";
        let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

        let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

        //02/28/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);



        //02/28/24 - added:
            //03/13/24 - removed:
            let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while !success && attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

                                                                // Place your calculations and updates here
                                                                //coinbase calculations to buy
                                                                let coinbase_taker_fee = 0.008;
                                                                let fraction_of_wallet_im_using = 0.10; //aka 10 percent
                                                                let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
                                                                let fee_for_purchase = total_spent*coinbase_taker_fee;
                                                                let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                *coinbase_wallet -= total_spent;

                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/coinbase_buy_price_ask
                                                                                                .expect(&format!("coinbase_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                coinbase_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &coinbase_buy_price_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let coinbase_wallet_unscaled = *coinbase_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is coinbase and bitstamp being updated, I will update:
																	//  56, 57, 58
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 57, 58];
																	let scaled_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*coinbase_wallet = coinbase_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 57, 58];
                                                                // let new_values = [value_after, Some(*coinbase_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                success = true;
                                                            },
															_ => {
																log::error!("i120: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i120: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i120: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i120: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i120: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i120: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: coinbase_buy_price_ask = {:?}", attempts, coinbase_buy_price_ask);
                }
            }

        //02/28/24 - removed:
            // //coinbase calculations
            //     let coinbase_taker_fee = 0.008;

            //     let total_spent = 0.07*(*coinbase_wallet);
            //     let fee_for_purchase = total_spent*coinbase_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of coinbase wallet below
            //     *coinbase_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

            // //kraken calculations
            //     //let kraken_taker_fee = 0.0026;
                
            //     //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //     //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //     //*kraken_wallet += money_from_sell_after_fees;

            //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            // //bitstamp calculations
            //     let bitstamp_taker_fee = 0.004;
            //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *bitstamp_wallet += money_from_sell_after_fees;



            // //this will count as value after
            //     let value_after = kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


            //     //value_after = 56
            //     //coinbase = 57
            //     //bitstamp = 58
            //     //kraken = 59
            //     //gemini = 60
            //     //since this is coinbase and kraken being updated, I will update:
            //     //  56, 57, 59
            //     let indices = [56, 57, 58];
            //     let new_values = [value_after, *coinbase_wallet, *bitstamp_wallet];
            //     log::info!("state of: coinbase wallet: {}
            //         kraken wallet: {}
            //         gemini wallet: {}
            //         bitstamp wallet: {}
            //         coinbase buy price ask: {}
            //         bitstamp sell price bid: {}", 
            //             &coinbase_wallet, &kraken_wallet, &gemini_wallet, &bitstamp_wallet, 
            //             &coinbase_buy_price_ask, &bitstamp_sell_price_bid);
            //     //01/24/24 - removed and added:
            //         //neural_network.update_input(&indices, &new_values);
            //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //         //neural_network.update_input(&indices, &transformed_values).await;
            //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //         neural_network.update_input(&indices, &scaled_values).await;


            //    return Ok(value_after)

    }
//gemini bitstamp   = 3 AND UP for min of 10 USD on Gemini and Bit
    pub async fn s_i123_xrp_3_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
			//03/05/24 - removed:
            // let gemini_request = client.get(gemini_url)
            //         .header("Content-Type", gemini_content_type)
            //         .header("Content-Length", gemini_content_length)
            //         .header("X-GEMINI-APIKEY", gemini_api_key)
            //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
            //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
            //         .header("Cache-Control", gemini_cache_control)
            //         .build()
            //         .expect("couldn't build gemini request");
            // let gemini_response = client.execute(gemini_request).await
            //                         .expect("Failed to execute Gemini request");
            // let gemini_response_text = gemini_response.text().await
            //                         .expect("Failed to turn response into text");
            // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
            //                         .expect("Failed to parse JSON");
            // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            // //CAN ONLY BUY. NOT SELL
            // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        



	//03/05/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();

			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i123: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i123: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i123: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i123: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i123: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i123: gemini:  Couldn't build gemini request"),
			}

			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}











            println!("xrp 3 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);
















			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {


																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.03; // aka 3 percent
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;


                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                gemini_buy_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &gemini_buy_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let gemini_wallet_unscaled = *gemini_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;

																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and gemini being updated, I will update:
																	//  56, 58, 60
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 60];
																	let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;

																	//03/01/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*gemini_wallet = gemini_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 60, 58];
                                                                // let new_values = [value_after, Some(*gemini_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i123: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i123: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i123: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i123: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i123: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i123: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
                }
            }


















        //         //gemini calculations for buy 
        //             //this should equal 0.4%
        //             let gemini_taker_fee = 0.004;
        //             let fraction_of_wallet_im_using = 0.03;

        //             let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //             let fee_for_purchase = total_spent*gemini_taker_fee;
        //             let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //             //new state of gemini wallet below
        //             *gemini_wallet -= total_spent;
        //             let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

        //         //bitstamp calculations - sell
        //             let bitstamp_taker_fee = 0.004;
        //             let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //             let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //             let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //             *bitstamp_wallet += money_from_sell_after_fees;

        //             //this will count as value after
        //             let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
        //             //println!("value after:\n\t{}",value_after);
        
    
        //             //value_after = 56
        //             //coinbase = 57
        //             //bitstamp = 58
        //             //kraken = 59
        //             //gemini = 60
        //             //since this is bitstamp and gemini being updated, I will update:
        //             //  56, 58, 64
        //             let indices = [56, 58, 64];
        //             let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
        //             //01/24/24 - removed and added:
        //                 //neural_network.update_input(&indices, &new_values);
        //                 //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //                 //neural_network.update_input(&indices, &transformed_values).await;
        //                 let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //                 neural_network.update_input(&indices, &scaled_values).await;
    
        
        // return Ok(value_after)
    }

    pub async fn s_i124_xrp_4_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
			//03/05/24 - removed:
            // let gemini_request = client.get(gemini_url)
            //         .header("Content-Type", gemini_content_type)
            //         .header("Content-Length", gemini_content_length)
            //         .header("X-GEMINI-APIKEY", gemini_api_key)
            //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
            //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
            //         .header("Cache-Control", gemini_cache_control)
            //         .build()
            //         .expect("couldn't build gemini request");
            // let gemini_response = client.execute(gemini_request).await
            //                         .expect("Failed to execute Gemini request");
            // let gemini_response_text = gemini_response.text().await
            //                         .expect("Failed to turn response into text");
            // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
            //                         .expect("Failed to parse JSON");
            // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            // //CAN ONLY BUY. NOT SELL
            // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        



	//03/05/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();

			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i124: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i124: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i124: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i124: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i124: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i124: gemini:  Couldn't build gemini request"),
			}

			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}











            println!("xrp 4 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);
















			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {


																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.04; // aka 4 percent
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;


                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                gemini_buy_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &gemini_buy_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let gemini_wallet_unscaled = *gemini_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;

																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and gemini being updated, I will update:
																	//  56, 58, 60
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 60];
																	let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;

																	//03/01/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*gemini_wallet = gemini_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 60, 58];
                                                                // let new_values = [value_after, Some(*gemini_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i124: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i124: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i124: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i124: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i124: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i124: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
                }
            }


















        //         //gemini calculations for buy 
        //             //this should equal 0.4%
        //             let gemini_taker_fee = 0.004;
        //             let fraction_of_wallet_im_using = 0.03;

        //             let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //             let fee_for_purchase = total_spent*gemini_taker_fee;
        //             let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //             //new state of gemini wallet below
        //             *gemini_wallet -= total_spent;
        //             let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

        //         //bitstamp calculations - sell
        //             let bitstamp_taker_fee = 0.004;
        //             let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //             let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //             let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //             *bitstamp_wallet += money_from_sell_after_fees;

        //             //this will count as value after
        //             let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
        //             //println!("value after:\n\t{}",value_after);
        
    
        //             //value_after = 56
        //             //coinbase = 57
        //             //bitstamp = 58
        //             //kraken = 59
        //             //gemini = 60
        //             //since this is bitstamp and gemini being updated, I will update:
        //             //  56, 58, 64
        //             let indices = [56, 58, 64];
        //             let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
        //             //01/24/24 - removed and added:
        //                 //neural_network.update_input(&indices, &new_values);
        //                 //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //                 //neural_network.update_input(&indices, &transformed_values).await;
        //                 let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //                 neural_network.update_input(&indices, &scaled_values).await;
    
        
        // return Ok(value_after)
    }

    pub async fn s_i125_xrp_5_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
			//03/05/24 - removed:
            // let gemini_request = client.get(gemini_url)
            //         .header("Content-Type", gemini_content_type)
            //         .header("Content-Length", gemini_content_length)
            //         .header("X-GEMINI-APIKEY", gemini_api_key)
            //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
            //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
            //         .header("Cache-Control", gemini_cache_control)
            //         .build()
            //         .expect("couldn't build gemini request");
            // let gemini_response = client.execute(gemini_request).await
            //                         .expect("Failed to execute Gemini request");
            // let gemini_response_text = gemini_response.text().await
            //                         .expect("Failed to turn response into text");
            // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
            //                         .expect("Failed to parse JSON");
            // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            // //CAN ONLY BUY. NOT SELL
            // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        



	//03/05/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();

			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i125: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i125: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i125: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i125: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i125: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i125: gemini:  Couldn't build gemini request"),
			}

			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}











            println!("xrp 5 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);
















			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {

																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.05; // aka 5 percent
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;

                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                gemini_buy_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &gemini_buy_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let gemini_wallet_unscaled = *gemini_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;

																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and gemini being updated, I will update:
																	//  56, 58, 60
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 60];
																	let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;

																	//03/01/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*gemini_wallet = gemini_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 60, 58];
                                                                // let new_values = [value_after, Some(*gemini_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i125: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i125: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i125: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i125: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i125: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i125: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
                }
            }


















        //         //gemini calculations for buy 
        //             //this should equal 0.4%
        //             let gemini_taker_fee = 0.004;
        //             let fraction_of_wallet_im_using = 0.03;

        //             let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //             let fee_for_purchase = total_spent*gemini_taker_fee;
        //             let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //             //new state of gemini wallet below
        //             *gemini_wallet -= total_spent;
        //             let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

        //         //bitstamp calculations - sell
        //             let bitstamp_taker_fee = 0.004;
        //             let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //             let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //             let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //             *bitstamp_wallet += money_from_sell_after_fees;

        //             //this will count as value after
        //             let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
        //             //println!("value after:\n\t{}",value_after);
        
    
        //             //value_after = 56
        //             //coinbase = 57
        //             //bitstamp = 58
        //             //kraken = 59
        //             //gemini = 60
        //             //since this is bitstamp and gemini being updated, I will update:
        //             //  56, 58, 64
        //             let indices = [56, 58, 64];
        //             let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
        //             //01/24/24 - removed and added:
        //                 //neural_network.update_input(&indices, &new_values);
        //                 //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //                 //neural_network.update_input(&indices, &transformed_values).await;
        //                 let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //                 neural_network.update_input(&indices, &scaled_values).await;
    
        
        // return Ok(value_after)
    }

    pub async fn s_i126_xrp_6_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
			//03/05/24 - removed:
            // let gemini_request = client.get(gemini_url)
            //         .header("Content-Type", gemini_content_type)
            //         .header("Content-Length", gemini_content_length)
            //         .header("X-GEMINI-APIKEY", gemini_api_key)
            //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
            //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
            //         .header("Cache-Control", gemini_cache_control)
            //         .build()
            //         .expect("couldn't build gemini request");
            // let gemini_response = client.execute(gemini_request).await
            //                         .expect("Failed to execute Gemini request");
            // let gemini_response_text = gemini_response.text().await
            //                         .expect("Failed to turn response into text");
            // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
            //                         .expect("Failed to parse JSON");
            // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            // //CAN ONLY BUY. NOT SELL
            // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        



	//03/05/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();

			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i126: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i126: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i126: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i126: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i126: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i126: gemini:  Couldn't build gemini request"),
			}

			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}











            println!("xrp 6 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);
















			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {


																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.06; // aka 6 percent
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;


                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                gemini_buy_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &gemini_buy_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let gemini_wallet_unscaled = *gemini_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;

																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and gemini being updated, I will update:
																	//  56, 58, 60
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 60];
																	let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;

																	//03/01/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*gemini_wallet = gemini_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 60, 58];
                                                                // let new_values = [value_after, Some(*gemini_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i126: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i126: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i126: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i126: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i126: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i126: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
                }
            }


















        //         //gemini calculations for buy 
        //             //this should equal 0.4%
        //             let gemini_taker_fee = 0.004;
        //             let fraction_of_wallet_im_using = 0.03;

        //             let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //             let fee_for_purchase = total_spent*gemini_taker_fee;
        //             let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //             //new state of gemini wallet below
        //             *gemini_wallet -= total_spent;
        //             let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

        //         //bitstamp calculations - sell
        //             let bitstamp_taker_fee = 0.004;
        //             let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //             let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //             let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //             *bitstamp_wallet += money_from_sell_after_fees;

        //             //this will count as value after
        //             let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
        //             //println!("value after:\n\t{}",value_after);
        
    
        //             //value_after = 56
        //             //coinbase = 57
        //             //bitstamp = 58
        //             //kraken = 59
        //             //gemini = 60
        //             //since this is bitstamp and gemini being updated, I will update:
        //             //  56, 58, 64
        //             let indices = [56, 58, 64];
        //             let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
        //             //01/24/24 - removed and added:
        //                 //neural_network.update_input(&indices, &new_values);
        //                 //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //                 //neural_network.update_input(&indices, &transformed_values).await;
        //                 let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //                 neural_network.update_input(&indices, &scaled_values).await;
    
        
        // return Ok(value_after)
    }

    pub async fn s_i127_xrp_7_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
			//03/05/24 - removed:
            // let gemini_request = client.get(gemini_url)
            //         .header("Content-Type", gemini_content_type)
            //         .header("Content-Length", gemini_content_length)
            //         .header("X-GEMINI-APIKEY", gemini_api_key)
            //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
            //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
            //         .header("Cache-Control", gemini_cache_control)
            //         .build()
            //         .expect("couldn't build gemini request");
            // let gemini_response = client.execute(gemini_request).await
            //                         .expect("Failed to execute Gemini request");
            // let gemini_response_text = gemini_response.text().await
            //                         .expect("Failed to turn response into text");
            // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
            //                         .expect("Failed to parse JSON");
            // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            // //CAN ONLY BUY. NOT SELL
            // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        



	//03/05/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();

			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i127: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i127: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i127: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i127: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i127: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i127: gemini:  Couldn't build gemini request"),
			}

			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}











            println!("xrp 7 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);
















			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {


																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.07; // aka 7 percent
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;


                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                gemini_buy_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &gemini_buy_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let gemini_wallet_unscaled = *gemini_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;

																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and gemini being updated, I will update:
																	//  56, 58, 60
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 60];
																	let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;

																	//03/01/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*gemini_wallet = gemini_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 60, 58];
                                                                // let new_values = [value_after, Some(*gemini_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i127: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i127: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i127: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i127: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i127: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i127: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
                }
            }


















        //         //gemini calculations for buy 
        //             //this should equal 0.4%
        //             let gemini_taker_fee = 0.004;
        //             let fraction_of_wallet_im_using = 0.03;

        //             let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //             let fee_for_purchase = total_spent*gemini_taker_fee;
        //             let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //             //new state of gemini wallet below
        //             *gemini_wallet -= total_spent;
        //             let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

        //         //bitstamp calculations - sell
        //             let bitstamp_taker_fee = 0.004;
        //             let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //             let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //             let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //             *bitstamp_wallet += money_from_sell_after_fees;

        //             //this will count as value after
        //             let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
        //             //println!("value after:\n\t{}",value_after);
        
    
        //             //value_after = 56
        //             //coinbase = 57
        //             //bitstamp = 58
        //             //kraken = 59
        //             //gemini = 60
        //             //since this is bitstamp and gemini being updated, I will update:
        //             //  56, 58, 64
        //             let indices = [56, 58, 64];
        //             let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
        //             //01/24/24 - removed and added:
        //                 //neural_network.update_input(&indices, &new_values);
        //                 //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //                 //neural_network.update_input(&indices, &transformed_values).await;
        //                 let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //                 neural_network.update_input(&indices, &scaled_values).await;
    
        
        // return Ok(value_after)
    }

    pub async fn s_i128_xrp_8_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
			//03/05/24 - removed:
            // let gemini_request = client.get(gemini_url)
            //         .header("Content-Type", gemini_content_type)
            //         .header("Content-Length", gemini_content_length)
            //         .header("X-GEMINI-APIKEY", gemini_api_key)
            //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
            //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
            //         .header("Cache-Control", gemini_cache_control)
            //         .build()
            //         .expect("couldn't build gemini request");
            // let gemini_response = client.execute(gemini_request).await
            //                         .expect("Failed to execute Gemini request");
            // let gemini_response_text = gemini_response.text().await
            //                         .expect("Failed to turn response into text");
            // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
            //                         .expect("Failed to parse JSON");
            // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            // //CAN ONLY BUY. NOT SELL
            // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        



	//03/05/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();

			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i128: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i128: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i128: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i128: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i128: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i128: gemini:  Couldn't build gemini request"),
			}

			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}











            println!("xrp 8 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);
















			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {


																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.08; // aka 8 percent
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;


                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                gemini_buy_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &gemini_buy_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let gemini_wallet_unscaled = *gemini_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;

																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and gemini being updated, I will update:
																	//  56, 58, 60
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 60];
																	let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;

																	//03/01/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*gemini_wallet = gemini_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 60, 58];
                                                                // let new_values = [value_after, Some(*gemini_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i128: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i128: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i128: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i128: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i128: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i128: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
                }
            }


















        //         //gemini calculations for buy 
        //             //this should equal 0.4%
        //             let gemini_taker_fee = 0.004;
        //             let fraction_of_wallet_im_using = 0.03;

        //             let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //             let fee_for_purchase = total_spent*gemini_taker_fee;
        //             let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //             //new state of gemini wallet below
        //             *gemini_wallet -= total_spent;
        //             let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

        //         //bitstamp calculations - sell
        //             let bitstamp_taker_fee = 0.004;
        //             let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //             let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //             let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //             *bitstamp_wallet += money_from_sell_after_fees;

        //             //this will count as value after
        //             let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
        //             //println!("value after:\n\t{}",value_after);
        
    
        //             //value_after = 56
        //             //coinbase = 57
        //             //bitstamp = 58
        //             //kraken = 59
        //             //gemini = 60
        //             //since this is bitstamp and gemini being updated, I will update:
        //             //  56, 58, 64
        //             let indices = [56, 58, 64];
        //             let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
        //             //01/24/24 - removed and added:
        //                 //neural_network.update_input(&indices, &new_values);
        //                 //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //                 //neural_network.update_input(&indices, &transformed_values).await;
        //                 let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //                 neural_network.update_input(&indices, &scaled_values).await;
    
        
        // return Ok(value_after)
    }

    pub async fn s_i129_xrp_9_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
			//03/05/24 - removed:
            // let gemini_request = client.get(gemini_url)
            //         .header("Content-Type", gemini_content_type)
            //         .header("Content-Length", gemini_content_length)
            //         .header("X-GEMINI-APIKEY", gemini_api_key)
            //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
            //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
            //         .header("Cache-Control", gemini_cache_control)
            //         .build()
            //         .expect("couldn't build gemini request");
            // let gemini_response = client.execute(gemini_request).await
            //                         .expect("Failed to execute Gemini request");
            // let gemini_response_text = gemini_response.text().await
            //                         .expect("Failed to turn response into text");
            // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
            //                         .expect("Failed to parse JSON");
            // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            // //CAN ONLY BUY. NOT SELL
            // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        



	//03/05/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();

			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i129: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i129: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i129: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i129: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i129: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i129: gemini:  Couldn't build gemini request"),
			}

			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}











            println!("xrp 9 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);
















			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {


																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.09; // aka 9 percent
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;


                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                gemini_buy_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &gemini_buy_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let gemini_wallet_unscaled = *gemini_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;

																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and gemini being updated, I will update:
																	//  56, 58, 60
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 60];
																	let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;

																	//03/01/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*gemini_wallet = gemini_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 60, 58];
                                                                // let new_values = [value_after, Some(*gemini_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i129: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i129: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i129: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i129: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i129: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i129: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
                }
            }


















        //         //gemini calculations for buy 
        //             //this should equal 0.4%
        //             let gemini_taker_fee = 0.004;
        //             let fraction_of_wallet_im_using = 0.03;

        //             let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //             let fee_for_purchase = total_spent*gemini_taker_fee;
        //             let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //             //new state of gemini wallet below
        //             *gemini_wallet -= total_spent;
        //             let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

        //         //bitstamp calculations - sell
        //             let bitstamp_taker_fee = 0.004;
        //             let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //             let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //             let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //             *bitstamp_wallet += money_from_sell_after_fees;

        //             //this will count as value after
        //             let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
        //             //println!("value after:\n\t{}",value_after);
        
    
        //             //value_after = 56
        //             //coinbase = 57
        //             //bitstamp = 58
        //             //kraken = 59
        //             //gemini = 60
        //             //since this is bitstamp and gemini being updated, I will update:
        //             //  56, 58, 64
        //             let indices = [56, 58, 64];
        //             let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
        //             //01/24/24 - removed and added:
        //                 //neural_network.update_input(&indices, &new_values);
        //                 //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //                 //neural_network.update_input(&indices, &transformed_values).await;
        //                 let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //                 neural_network.update_input(&indices, &scaled_values).await;
    
        
        // return Ok(value_after)
    }

    pub async fn s_i130_xrp_10_gemini_bitstamp( coinbase_wallet: &f64, kraken_wallet: &f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &mut f64, gemini_secret: &str, gemini_api_key: &str, client: reqwest::Client, bitstamp_secret: &str, bitstamp_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
                let encoded_payload = encode(gemini_payload.to_string());
                let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                                .expect("HMAC can take key of any size");
                mac.update(encoded_payload.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                let gemini_signature = hex::encode(code_bytes);
                println!("Gemini signature:\n{}", &gemini_signature);
                gemini_signature
        
            }
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time.
            //		let now = Utc::now();
            let now = Utc::now();
            let gemini_time_stamp = now.timestamp().to_string();
            let gemini_nonce = gemini_time_stamp;
            let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
            let gemini_payload = json!({
                "request": "/v1/mytrades",
                "nonce": &gemini_nonce
            });
            let base64_encoded_payload = encode(gemini_payload.to_string());
            let gemini_content_type = "text/plain";
            let gemini_content_length = "0";
            let gemini_cache_control = "no-cache";
            let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
            
			//03/05/24 - removed:
            // let gemini_request = client.get(gemini_url)
            //         .header("Content-Type", gemini_content_type)
            //         .header("Content-Length", gemini_content_length)
            //         .header("X-GEMINI-APIKEY", gemini_api_key)
            //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
            //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
            //         .header("Cache-Control", gemini_cache_control)
            //         .build()
            //         .expect("couldn't build gemini request");
            // let gemini_response = client.execute(gemini_request).await
            //                         .expect("Failed to execute Gemini request");
            // let gemini_response_text = gemini_response.text().await
            //                         .expect("Failed to turn response into text");
            // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
            //                         .expect("Failed to parse JSON");
            // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
            // //CAN ONLY BUY. NOT SELL
            // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
            // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
        



	//03/05/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();

			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i130: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i130: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i130: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i130: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i130: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i130: gemini:  Couldn't build gemini request"),
			}

			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}











            println!("xrp 10 gemini bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;





            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);








            //--------------------Account-balances------------------------------------------//



            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // println!("Bitstamp:\n{:?}", bitstamp_response_text);
















			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {


																let gemini_taker_fee = 0.004;
																let fraction_of_wallet_im_using = 0.10; // aka 10 percent
																let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																let fee_for_purchase = total_spent*gemini_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																//new state of gemini wallet below
																*gemini_wallet -= total_spent;


                                                                let amount_of_xrp = 
                                                                money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                gemini_buy_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &gemini_buy_ask));

                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let gemini_wallet_unscaled = *gemini_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;

																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and gemini being updated, I will update:
																	//  56, 58, 60
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 60];
																	let scaled_values = [value_after, *bitstamp_wallet, *gemini_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;

																	//03/01/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*gemini_wallet = gemini_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is coinbase and gemini being updated, I will update:
                                                                // //  56, 57, 60
                                                                // let indices = [56, 60, 58];
                                                                // let new_values = [value_after, Some(*gemini_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i130: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i130: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i130: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i130: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i130: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i130: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: gemini_buy_ask = {:?}", attempts, gemini_buy_ask);
                }
            }


















        //         //gemini calculations for buy 
        //             //this should equal 0.4%
        //             let gemini_taker_fee = 0.004;
        //             let fraction_of_wallet_im_using = 0.03;

        //             let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //             let fee_for_purchase = total_spent*gemini_taker_fee;
        //             let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //             //new state of gemini wallet below
        //             *gemini_wallet -= total_spent;
        //             let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
        

        //         //bitstamp calculations - sell
        //             let bitstamp_taker_fee = 0.004;
        //             let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //             let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //             let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //             *bitstamp_wallet += money_from_sell_after_fees;

        //             //this will count as value after
        //             let value_after = kraken_wallet + coinbase_wallet + *gemini_wallet + *bitstamp_wallet;
        //             //println!("value after:\n\t{}",value_after);
        
    
        //             //value_after = 56
        //             //coinbase = 57
        //             //bitstamp = 58
        //             //kraken = 59
        //             //gemini = 60
        //             //since this is bitstamp and gemini being updated, I will update:
        //             //  56, 58, 64
        //             let indices = [56, 58, 64];
        //             let new_values = [value_after, *bitstamp_wallet, *gemini_wallet];
        //             //01/24/24 - removed and added:
        //                 //neural_network.update_input(&indices, &new_values);
        //                 //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //                 //neural_network.update_input(&indices, &transformed_values).await;
        //                 let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //                 neural_network.update_input(&indices, &scaled_values).await;
    
        
        // return Ok(value_after)
    }
//kraken bitstamp   = 4 AND UP for min of 25 XRP withdraw = 15 dollars. 3 and up should work but just in case
    pub async fn s_i134_xrp_4_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XRPUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
			//03/05/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            // //println!("kraken response:{}", kraken_response_text);
            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    










		//03/05/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

													match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i134: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i134: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i134: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i134: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i134: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i134: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i134: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}













            println!("xrp 4 kraken bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;








            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // //println!("Bitstamp:\n{:?}", bitstamp_response_text);












			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																let kraken_taker_fee = 0.0026;
																let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
																let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																let fee_for_purchase = total_spent*kraken_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																
																//new state of gemini wallet below
																*kraken_wallet -= total_spent;

                                                                let amount_of_xrp_before_withdraw_fee = 
                                                                money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                                .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                kraken_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &kraken_buy_price_ask));

																let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;
                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let kraken_wallet_unscaled = *kraken_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and kraken being updated, I will update:
																	//  56, 58, 59
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 59];
																	let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*kraken_wallet = kraken_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is kraken and bitstamp being updated, I will update:
                                                                // //  56, 59, 58
                                                                // let indices = [56, 59, 58];
                                                                // let new_values = [value_after, Some(*kraken_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i134: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i134: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i134: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i134: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i134: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i134: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
                }
            }















		//03/05/24 - removed:
		// //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_xrp_after_fees;
        //     let amount_of_xrp_before_withdraw_fee = 
        //                     money_going_to_xrp_after_fees/kraken_buy_price_ask;
        //     let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

            


        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;

        // //bitstamp calculations for sell
        //     let bitstamp_taker_fee = 0.004;
        //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *bitstamp_wallet += money_from_sell_after_fees;


        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is bitstamp and kraken being updated, I will update:
        //         //  56, 58, 59
        //         let indices = [56, 58, 59];
        //         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;


        //     return Ok(value_after)
	}

    pub async fn s_i135_xrp_5_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XRPUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
			//03/05/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            // //println!("kraken response:{}", kraken_response_text);
            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    










		//03/05/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

													match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);
																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i135: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i135: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i135: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i135: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i135: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i135: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i135: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}













            println!("xrp 5 kraken bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;








            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // //println!("Bitstamp:\n{:?}", bitstamp_response_text);












			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																let kraken_taker_fee = 0.0026;
																let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
																let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																let fee_for_purchase = total_spent*kraken_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																
																//new state of gemini wallet below
																*kraken_wallet -= total_spent;

                                                                let amount_of_xrp_before_withdraw_fee = 
                                                                money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                                .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                kraken_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &kraken_buy_price_ask));

																let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;
                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let kraken_wallet_unscaled = *kraken_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and kraken being updated, I will update:
																	//  56, 58, 59
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 59];
																	let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*kraken_wallet = kraken_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is kraken and bitstamp being updated, I will update:
                                                                // //  56, 59, 58
                                                                // let indices = [56, 59, 58];
                                                                // let new_values = [value_after, Some(*kraken_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i135: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i135: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i135: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i135: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i135: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i135: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
                }
            }















		//03/05/24 - removed:
		// //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_xrp_after_fees;
        //     let amount_of_xrp_before_withdraw_fee = 
        //                     money_going_to_xrp_after_fees/kraken_buy_price_ask;
        //     let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

            


        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;

        // //bitstamp calculations for sell
        //     let bitstamp_taker_fee = 0.004;
        //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *bitstamp_wallet += money_from_sell_after_fees;


        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is bitstamp and kraken being updated, I will update:
        //         //  56, 58, 59
        //         let indices = [56, 58, 59];
        //         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;


        //     return Ok(value_after)
	}

    pub async fn s_i136_xrp_6_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XRPUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
			//03/05/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            // //println!("kraken response:{}", kraken_response_text);
            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    










		//03/05/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

													match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i136: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i136: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i136: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i136: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i136: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i136: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i136: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}













            println!("xrp 6 kraken bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;








            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // //println!("Bitstamp:\n{:?}", bitstamp_response_text);












			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																let kraken_taker_fee = 0.0026;
																let fraction_of_wallet_im_using = 0.06;  //aka 6 percent
																let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																let fee_for_purchase = total_spent*kraken_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																
																//new state of gemini wallet below
																*kraken_wallet -= total_spent;

                                                                let amount_of_xrp_before_withdraw_fee = 
                                                                money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                                .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                kraken_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &kraken_buy_price_ask));

																let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;
                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let kraken_wallet_unscaled = *kraken_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and kraken being updated, I will update:
																	//  56, 58, 59
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 59];
																	let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*kraken_wallet = kraken_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is kraken and bitstamp being updated, I will update:
                                                                // //  56, 59, 58
                                                                // let indices = [56, 59, 58];
                                                                // let new_values = [value_after, Some(*kraken_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i136: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i136: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i136: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i136: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i136: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i136: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
                }
            }















		//03/05/24 - removed:
		// //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_xrp_after_fees;
        //     let amount_of_xrp_before_withdraw_fee = 
        //                     money_going_to_xrp_after_fees/kraken_buy_price_ask;
        //     let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

            


        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;

        // //bitstamp calculations for sell
        //     let bitstamp_taker_fee = 0.004;
        //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *bitstamp_wallet += money_from_sell_after_fees;


        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is bitstamp and kraken being updated, I will update:
        //         //  56, 58, 59
        //         let indices = [56, 58, 59];
        //         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;


        //     return Ok(value_after)
	}

    pub async fn s_i137_xrp_7_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XRPUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
			//03/05/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            // //println!("kraken response:{}", kraken_response_text);
            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    










		//03/05/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

													match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i137: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i137: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i137: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i137: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i137: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i137: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i137: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}













            println!("xrp 7 kraken bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;








            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // //println!("Bitstamp:\n{:?}", bitstamp_response_text);












			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																let kraken_taker_fee = 0.0026;
																let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
																let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																let fee_for_purchase = total_spent*kraken_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																
																//new state of gemini wallet below
																*kraken_wallet -= total_spent;

                                                                let amount_of_xrp_before_withdraw_fee = 
                                                                money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                                .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                kraken_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &kraken_buy_price_ask));

																let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;
                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let kraken_wallet_unscaled = *kraken_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and kraken being updated, I will update:
																	//  56, 58, 59
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 59];
																	let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*kraken_wallet = kraken_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is kraken and bitstamp being updated, I will update:
                                                                // //  56, 59, 58
                                                                // let indices = [56, 59, 58];
                                                                // let new_values = [value_after, Some(*kraken_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i137: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i137: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i137: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i137: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i137: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i137: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
                }
            }















		//03/05/24 - removed:
		// //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_xrp_after_fees;
        //     let amount_of_xrp_before_withdraw_fee = 
        //                     money_going_to_xrp_after_fees/kraken_buy_price_ask;
        //     let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

            


        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;

        // //bitstamp calculations for sell
        //     let bitstamp_taker_fee = 0.004;
        //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *bitstamp_wallet += money_from_sell_after_fees;


        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is bitstamp and kraken being updated, I will update:
        //         //  56, 58, 59
        //         let indices = [56, 58, 59];
        //         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;


        //     return Ok(value_after)
	}

    pub async fn s_i138_xrp_8_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XRPUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
			//03/05/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            // //println!("kraken response:{}", kraken_response_text);
            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    










		//03/05/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

													match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i138: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i138: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i138: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i138: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i138: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i138: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i138: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}













            println!("xrp 8 kraken bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;








            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // //println!("Bitstamp:\n{:?}", bitstamp_response_text);












			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																let kraken_taker_fee = 0.0026;
																let fraction_of_wallet_im_using = 0.08;  //aka 8 percent
																let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																let fee_for_purchase = total_spent*kraken_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																
																//new state of gemini wallet below
																*kraken_wallet -= total_spent;

                                                                let amount_of_xrp_before_withdraw_fee = 
                                                                money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                                .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                kraken_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &kraken_buy_price_ask));

																let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;
                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let kraken_wallet_unscaled = *kraken_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and kraken being updated, I will update:
																	//  56, 58, 59
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 59];
																	let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*kraken_wallet = kraken_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is kraken and bitstamp being updated, I will update:
                                                                // //  56, 59, 58
                                                                // let indices = [56, 59, 58];
                                                                // let new_values = [value_after, Some(*kraken_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i138: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i138: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i138: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i138: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i138: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i138: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
                }
            }















		//03/05/24 - removed:
		// //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_xrp_after_fees;
        //     let amount_of_xrp_before_withdraw_fee = 
        //                     money_going_to_xrp_after_fees/kraken_buy_price_ask;
        //     let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

            


        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;

        // //bitstamp calculations for sell
        //     let bitstamp_taker_fee = 0.004;
        //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *bitstamp_wallet += money_from_sell_after_fees;


        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is bitstamp and kraken being updated, I will update:
        //         //  56, 58, 59
        //         let indices = [56, 58, 59];
        //         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;


        //     return Ok(value_after)
	}

    pub async fn s_i139_xrp_9_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XRPUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
			//03/05/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            // //println!("kraken response:{}", kraken_response_text);
            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    










		//03/05/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

													match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i139: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i139: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i139: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i139: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i139: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i139: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i139: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}













            println!("xrp 9 kraken bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;








            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // //println!("Bitstamp:\n{:?}", bitstamp_response_text);












			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while  attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																let kraken_taker_fee = 0.0026;
																let fraction_of_wallet_im_using = 0.09;  //aka 9 percent
																let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																let fee_for_purchase = total_spent*kraken_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																
																//new state of gemini wallet below
																*kraken_wallet -= total_spent;

                                                                let amount_of_xrp_before_withdraw_fee = 
                                                                money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                                .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                kraken_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &kraken_buy_price_ask));

																let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;
                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let kraken_wallet_unscaled = *kraken_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and kraken being updated, I will update:
																	//  56, 58, 59
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 59];
																	let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*kraken_wallet = kraken_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is kraken and bitstamp being updated, I will update:
                                                                // //  56, 59, 58
                                                                // let indices = [56, 59, 58];
                                                                // let new_values = [value_after, Some(*kraken_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i139: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i139: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i139: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i139: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i139: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i139: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
                }
            }















		//03/05/24 - removed:
		// //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_xrp_after_fees;
        //     let amount_of_xrp_before_withdraw_fee = 
        //                     money_going_to_xrp_after_fees/kraken_buy_price_ask;
        //     let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

            


        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;

        // //bitstamp calculations for sell
        //     let bitstamp_taker_fee = 0.004;
        //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *bitstamp_wallet += money_from_sell_after_fees;


        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is bitstamp and kraken being updated, I will update:
        //         //  56, 58, 59
        //         let indices = [56, 58, 59];
        //         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;


        //     return Ok(value_after)
	}
    //-----NEED-TO-APPEND-TO-END-----//
    pub async fn s_i140_xrp_10_kraken_bitstamp( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &mut f64,
        gemini_wallet: &f64, bitstamp_secret: &str, bitstamp_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

            //---KRAKEN--//
    
            //basically Kraken requires a value that is always increasing to be in each request.
            //I didnt use now.timestamp().to_string()  because just in case I have 2 
            //	requests in a second I dont want to be penalized.
            //if no "now" in scope when moving file, 
            //	the code is this:
            ////returns current time. MAY NEED TO USE LOCAL TIME
            let now = Utc::now();
            let nonce = now.timestamp_millis().to_string();
            let data = vec![
                ("nonce", &nonce),
                // Add more parameters as needed
            ];
            //let post_data: String = form_urlencoded::Serializer::new(String::new())
            //    .extend_pairs(data)
            //    .finish();
            
            let url_path = "/0/public/Ticker?pair=XRPUSD";
            //let message = format!("{}{}{}", url_path, nonce, post_data);
    
            fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
            -> String {
                // Create the post data
                let post_data: String = form_urlencoded::Serializer::new(String::new())
                    .extend_pairs(data)
                    .finish();
                //FOR DEBUGGING
                //println!("Private key:\n{}", secret);
                //println!("Nonce:\n{}", nonce_str);
                //println!("Encoded payload:\n{}", post_data);
                //println!("URI Path:\n{}", url_path);
            
                // Create the encoded string (nonce + post data) and hash it
                let encoded = format!("{}{}", nonce_str, post_data);
                let mut hasher = sha2::Sha256::new();
                hasher.update(encoded);
                let encoded_hash = hasher.finalize();
            
                // Create the message (url_path + encoded_hash as bytes)
                let mut message = url_path.as_bytes().to_vec();
                message.extend_from_slice(&encoded_hash);
            
                // Create a HMAC-SHA512 object with the base64-decoded secret
                let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
                let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                    .expect("HMAC can take key of any size");
            
                // Compute the HMAC of the message
                mac.update(&message);
                let result = mac.finalize();
            
                // Return the base64-encoded HMAC
                let signature = base64::encode(result.into_bytes());
                //println!("Kraken signature:\n{}", signature);
            
                signature
            }
    
            let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);
    
            //kraken asked for 3 headers: key, sign, and content type with its corresponding info
            //.body is nonce because in the Kraken code provided in cURL: 
            //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
            //--data-urlencode "nonce=<YOUR-NONCE>"
            //		this means that nonce is added to the body of the request
			//03/05/24 - removed:
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");
            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");
            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            // //println!("kraken response:{}", kraken_response_text);
            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
    










		//03/05/24 - added in its place:
			let mut kraken_buy_price_ask: Option<f64> = None;
			//let mut kraken_sell_price_bid: Option<f64> = None;
			let mut attempts = 0;
			loop {
				attempts += 1;
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
				.header("API-Key", kraken_api_key)
				.header("API-Sign", &kraken_signature)
				.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
				.body(format!("nonce={}", nonce))
				.build();

				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

													match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
														(Some(ask_str), /*Some(bid_str)*/) => {
															match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
																(Ok(ask), /*Ok(bid)*/) => {
																	kraken_buy_price_ask = Some(ask);
																	//kraken_sell_price_bid = Some(bid);

																	//03/05/24 - dont think this break is necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i140: Kraken: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i140: Kraken: Failed to get ask or bid as string"),
													}										
												}
												else {
													log::error!("i140: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i140: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i140: Kraken: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i140: Kraken: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i140: Kraken: Failed to build kraken request. Error was: {}", e),
				}
				if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
					break; // Exit the loop if everything is successful
				}

				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}













            println!("xrp 10 kraken bitstamp  delay: 8 sec...");
            let when = tokio::time::Instant::now() + Duration::from_secs(8);
            //02/09/21 - tokio update. changed from delay_until to sleep_until
            tokio::time::sleep_until(when).await;








            //-------bitstamp--------------------//
            type HmacSha256 = Hmac<Sha256>;
            fn bitstamp_sign(bitstamp_message: &str, bitstamp_secret: &str) -> String {
                let mut mac = HmacSha256::new_from_slice(&bitstamp_secret.as_bytes())
                    .expect("HMAC can take key of any size");
                mac.update(bitstamp_message.as_bytes());
                let result = mac.finalize();
                let code_bytes = result.into_bytes();
                hex::encode(code_bytes)
            }


            let content_type = "application/x-www-form-urlencoded";
            let payload_string = "offset=1";
            //if we needed content_type, it is here
            //let content_type = "application/json";
            //this is the bitstamp message IF we needed content_type
            //let bitstamp_message = format!("BITSTAMP {}POSThttps://www.bitstamp.net/api/v2/account_balances/{}{}{}v2{}", 
            //	bitstamp_api_key, content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);


            let the_uuid = Uuid::new_v4();
            let bitstamp_nonce = the_uuid.to_string();
            let bitstamp_timestamp = now.timestamp_millis().to_string();
            //let content_type = "application/x-www-form-urlencoded";
            let bitstamp_message = format!("BITSTAMP {}GETwww.bitstamp.net/api/v2/ticker/xrp-usd/{}{}{}{}v2{}", 
                    bitstamp_api_key, "", content_type, bitstamp_nonce, bitstamp_timestamp, payload_string);

            let bitstamp_signature = bitstamp_sign(&bitstamp_message, &bitstamp_secret);

			//03/05/24 - removed:
            // let bitstamp_request = client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
            //     .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
            //     .header("X-Auth-Signature", bitstamp_signature)
            //     .header("X-Auth-Nonce", bitstamp_nonce)
            //     .header("X-Auth-Timestamp", bitstamp_timestamp)
            //     .header("X-Auth-Version", "v2")
            //     //.header("Content-Type", content_type)
            //     //.body(payload_string)
            //     .build()
            //     .expect("\ncould not build bitstamp_request");

            // let bitstamp_response = client.execute(bitstamp_request).await
            //     .expect("Failed to execute Bitstamp request");
            // let bitstamp_response_text = bitstamp_response.text().await
            //     .expect("Failed to turn response into text");
            // //probably dont need "bitstamp" once we transfer this to the actual function
            // let v: serde_json::Value = serde_json::from_str(&bitstamp_response_text)
            // .expect("Failed to parse JSON");

            // // Extract the bid and ask values
            // let bitstamp_sell_price_bid = v["bid"].as_str().unwrap().parse::<f64>().unwrap();
            // let bitstamp_buy_price_ask = v["ask"].as_str().unwrap().parse::<f64>().unwrap();
            // //println!("Bid: {}, Ask: {}", bitstamp_sell_price_bid, bitstamp_buy_price_ask);
            // //println!("Bitstamp:\n{:?}", bitstamp_response_text);












			//03/05/24 - added:
            //03/13/24 - removed:
            // let mut success = false;
            let mut attempts = 0;
            let mut value_after: Option<f64> = None;

            while attempts <=3 {
                attempts += 1;

                match client.get("https://www.bitstamp.net/api/v2/ticker/xrpusd/")
                    .header("X-Auth", format!("BITSTAMP {}", bitstamp_api_key))
                    .header("X-Auth-Signature", &bitstamp_signature)
                    .header("X-Auth-Nonce", &bitstamp_nonce)
                    .header("X-Auth-Timestamp", &bitstamp_timestamp)
                    .header("X-Auth-Version", "v2")
                    .build() {
                    Ok(bitstamp_request) => {
                        match client.execute(bitstamp_request).await {
                            Ok(bitstamp_response) => {
                                match bitstamp_response.text().await {
                                    Ok(bitstamp_response_text) => {
                                        match serde_json::from_str::<Value>(&bitstamp_response_text) {
                                            Ok(v) => {
                                                let before_parse_bitstamp_sell_price_bid = v["bid"].as_str();
                                                let before_parse_bitstamp_buy_price_ask = v["ask"].as_str();

                                                match (before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask) {
                                                    (Some(bid_str), Some(ask_str)) => {
                                                        match (bid_str.parse::<f64>(), ask_str.parse::<f64>()) {
                                                            (Ok(bitstamp_sell_price_bid), Ok(bitstamp_buy_price_ask)) => {
																let kraken_taker_fee = 0.0026;
																let fraction_of_wallet_im_using = 0.10;  //aka 10 percent
																let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
																let fee_for_purchase = total_spent*kraken_taker_fee;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																
																//new state of gemini wallet below
																*kraken_wallet -= total_spent;

                                                                let amount_of_xrp_before_withdraw_fee = 
                                                                money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                                .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                                even though to get to this point it had to be Some. 
                                                                                                kraken_buy_price_ask: {:?}
                                                                                                Honestly restart the program from the last saved state. 
                                                                                                The most likely error is a bit got flipped after the loop",
                                                                                                &kraken_buy_price_ask));

																let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;
                                                                //bitstamp calculations for sell

                                                                let bitstamp_taker_fee = 0.004;
                                                                let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
                                                                let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
                                                                let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                *bitstamp_wallet += money_from_sell_after_fees;
                                                                value_after = Some(*kraken_wallet + coinbase_wallet + gemini_wallet + *bitstamp_wallet);
																if let Some(mut value_after) = value_after {

																	//03/10/24 - added for unscaling
																	let value_after_unscaled = value_after;
																	let kraken_wallet_unscaled = *kraken_wallet;
																	let bitstamp_wallet_unscaled = *bitstamp_wallet;
	
																	*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																	*bitstamp_wallet = standardization_functions::normal_wallet_standardization(&bitstamp_wallet);
																	value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																	
																	//value_after = 56
																	//coinbase = 57
																	//bitstamp = 58
																	//kraken = 59
																	//gemini = 60
																	//since this is bitstamp and kraken being updated, I will update:
																	//  56, 58, 59
																	//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																	let indices = [56, 58, 59];
																	let scaled_values = [value_after, *bitstamp_wallet, *kraken_wallet];
																	//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	neural_network.update_input(&indices, &scaled_values).await;
	
																	//03/10/24 - added for unscaling:
																	value_after = value_after_unscaled;
																	*kraken_wallet = kraken_wallet_unscaled;
																	*bitstamp_wallet = bitstamp_wallet_unscaled;

                                                                    //03/13/24 - added:
                                                                    return Ok(value_after);
																}
																//03/08/24 - removed:
                                                                // //value_after = 56
                                                                // //coinbase = 57
                                                                // //bitstamp = 58
                                                                // //kraken = 59
                                                                // //gemini = 60
                                                                // //since this is kraken and bitstamp being updated, I will update:
                                                                // //  56, 59, 58
                                                                // let indices = [56, 59, 58];
                                                                // let new_values = [value_after, Some(*kraken_wallet), Some(*bitstamp_wallet)];
                                                                // let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
                                                                // neural_network.update_input(&indices, &scaled_values).await;

                                                                //03/13/24 - removed:
                                                                // success = true;
                                                            },
															_ => {
																log::error!("i140: Failed to f64 parse bid or ask price");
																if attempts > 3 {
																	panic!("Failed to parse f64 bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
																}
																continue;
															}
														}
													},
													_ => {
														log::error!("i140: Failed to originally parse bid or ask price");
														if attempts > 3 {
															panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}, Ask: {:?}", before_parse_bitstamp_sell_price_bid, before_parse_bitstamp_buy_price_ask);
														}
														continue;
													}
												}
											},
											Err(_) => {
												log::error!("i140: Failed to parse JSON");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", bitstamp_response_text);
												}
												continue;
											}
										}
									},
									Err(_) => {
										log::error!("i140: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue;
									}
								}
							},
							Err(_) => {
								log::error!("i140: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue;
							}
						}
					},
					Err(_) => {
						log::error!("i140: Failed to build request");
						if attempts > 3 {
							panic!("Failed to build request after 3 attempts");
						}
						continue;
					}
				}
			}

            match value_after {
                Some(value) => return Ok(value),
                None => {
                    //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                    panic!("Failed to get a valid value after {} attempts. Final values: kraken_buy_price_ask = {:?}", attempts, kraken_buy_price_ask);
                }
            }















		//03/05/24 - removed:
		// //kraken calculations - buy
        //     let kraken_taker_fee = 0.0026;
        //     let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
        //     let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        //     let fee_for_purchase = total_spent*kraken_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     *kraken_wallet -= money_going_to_xrp_after_fees;
        //     let amount_of_xrp_before_withdraw_fee = 
        //                     money_going_to_xrp_after_fees/kraken_buy_price_ask;
        //     let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

            


        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;

        // //bitstamp calculations for sell
        //     let bitstamp_taker_fee = 0.004;
        //     let money_from_sell_before_fees = amount_of_xrp * bitstamp_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     *bitstamp_wallet += money_from_sell_after_fees;


        // //this will count as value after
        //     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        //     //println!("sol1_kraken_bitstamp\tvalue after\n\t{}", value_after);



        //         //value_after = 56
        //         //coinbase = 57
        //         //bitstamp = 58
        //         //kraken = 59
        //         //gemini = 60
        //         //since this is bitstamp and kraken being updated, I will update:
        //         //  56, 58, 59
        //         let indices = [56, 58, 59];
        //         let new_values = [value_after, *bitstamp_wallet, *kraken_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;


        //     return Ok(value_after)
	}
//gemini coinbase   = 3 AND UP for gemini/coin
	pub async fn s_i143_xrp_3_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
		gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
			let encoded_payload = encode(gemini_payload.to_string());
			let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
							.expect("HMAC can take key of any size");
			mac.update(encoded_payload.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			let gemini_signature = hex::encode(code_bytes);
			println!("Gemini signature:\n{}", &gemini_signature);
			gemini_signature

		}
		//if no "now" in scope when moving file, 
		//	the code is this:
		////returns current time.
		//		let now = Utc::now();
		let now = Utc::now();
		let gemini_time_stamp = now.timestamp().to_string();
		let gemini_nonce = gemini_time_stamp;
		let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
		let gemini_payload = json!({
			"request": "/v1/mytrades",
			"nonce": &gemini_nonce
		});
		let base64_encoded_payload = encode(gemini_payload.to_string());
		let gemini_content_type = "text/plain";
		let gemini_content_length = "0";
		let gemini_cache_control = "no-cache";
		let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
		
		// let gemini_request = client.get(gemini_url)
		//         .header("Content-Type", gemini_content_type)
		//         .header("Content-Length", gemini_content_length)
		//         .header("X-GEMINI-APIKEY", gemini_api_key)
		//         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
		//         .header("X-GEMINI-SIGNATURE", &gemini_signature)
		//         .header("Cache-Control", gemini_cache_control)
		//         .build()
		//         .expect("couldn't build gemini request");


		// let gemini_response = client.execute(gemini_request).await
		//                         .expect("Failed to execute Gemini request");
		// let gemini_response_text = gemini_response.text().await
		//                         .expect("Failed to turn response into text");
		// let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
		//                         .expect("Failed to parse JSON");
		// let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
		// //CAN ONLY BUY. NOT SELL
		// let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
		// //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
	//02/27/24 - added:
		let mut attempts = 0;
		let gemini_buy_ask: Option<f64>;
		loop {
			let gemini_request = client.get(gemini_url)
				.header("Content-Type", gemini_content_type)
				.header("Content-Length", gemini_content_length)
				.header("X-GEMINI-APIKEY", gemini_api_key)
				.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
				.header("X-GEMINI-SIGNATURE", &gemini_signature)
				.header("Cache-Control", gemini_cache_control)
				.build();
		
			match gemini_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							let gemini_response_text = response.text().await;
							match gemini_response_text {
								Ok(text) => {

									match serde_json::from_str::<Value>(&text) {
										//03/02/24 - replaced:
										// Ok(value) => {
										//     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
										//         .ok_or_else(|| "Failed to get ask as string")
										//         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
								
										//     match gemini_buy_ask_result {
										//         Ok(ask) => {
										//             gemini_buy_ask = Some(ask);
										//             // Continue with your logic here using `ask`
										//             break; // Exit the loop if everything is successful
										//         },
										//         Err(e) => log::error!("{}", e),
										//     }
										// },
										// Err(_) => log::error!("Failed to parse JSON"),
										//03/02/24 - added in its place:
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i143: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i143: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i143: gemini:  Failed to parse JSON"),
									}
								},
								Err(_) => log::error!("i143: gemini:  Failed to turn response into text"),
							}
						},
						Err(_) => log::error!("i143: gemini:  Failed to execute Gemini request"),
					}
				},
				Err(_) => log::error!("i143: gemini:  Couldn't build gemini request"),
			}
		
			attempts += 1;
			//03/02/24 - changed from >= to >
			if attempts > 3 {
				panic!("Failed after 3 attempts");
			}
		}




		println!("xrp 3 gemini coinbase simulated 8 sec delay...");
		let when = tokio::time::Instant::now() + Duration::from_secs(8);
		//02/09/21 - tokio update. changed from delay_until to sleep_until
		tokio::time::sleep_until(when).await;



		//------------COINBASE------------//
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);

	//02/27/24 - removed:
		// let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
		// .header("CB-ACCESS-KEY", coinbase_api_key)
		// .header("CB-ACCESS-SIGN", &coinbase_signature)
		// .header("CB-ACCESS-TIMESTAMP", &time_stamp)
		// .build()
		// .expect("couldn't build Coinbase request");
		// //manages the error I described above
		// //let request = match request {
		// //Ok(req) => req,
		// //Err(e) => {
		// //eprintln!("Failed to build request: \n{}", e);
		// //return Err(e);
		// //}
		// //};

		// let response = client.execute(request).await.expect("couldn't build response");
		// //let response = match response {
		// //    Ok(resp) => resp,
		// //    Err(e) => {
		// //        eprintln!("Failed to execute request: \n{}", e);
		// //        return Err(e);
		// //    }
		// //};


		// let response_text = response.text().await.expect("couldn't build response_text");

		// //added 12/29/23
		// //this is the parsing
		// let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
		// let mut coinbase_sell_price_bid = 0.0;
		// let mut coinbase_buy_price_ask = 0.0;

		// // Access the pricebooks array
		// if let Some(pricebooks) = v["pricebooks"].as_array() {
		//     // Iterate over each pricebook
		//     for pricebook in pricebooks {
		//         // Access the product_id, bids, and asks
		//         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
		//         let bids = &pricebook["bids"][0];
		//         let asks = &pricebook["asks"][0];
		
		//         // Access the price and size of the bids and asks
		//         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
		//         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
		//         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
		//         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
		
		//         //println!("Product ID: {}", product_id);
		//         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
		//         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
		//     }
		// }
	//02/27/24 - added in its place:
		let mut attempts = 0;
		let mut coinbase_sell_price_bid: Option<f64> = None;
		//let coinbase_buy_price_ask: Option<f64>;
		let mut value_after: Option<f64> = None;
		//02/28/24 - changed to false
        //03/13/24 - removed:
		// let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();
			//.expect("couldn't build request");
			//manages the error I described above
			//let request = match request {
			//Ok(req) => req,
			//Err(e) => {
			//eprintln!("Failed to build request: \n{}", e);
			//return Err(e);
			//}
			//};
			match request {
				Ok(req) => {
			//      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													//let product_id = pricebook["product_id"].as_str();
													let bids = &pricebook["bids"][0];
													//let asks = &pricebook["asks"][0];
													let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
													//let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
		
													match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
														(Some(bid_str), /*Some(ask_str)*/) => {
															match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
																(Ok(bid_str), /*Ok(ask_str)*/) => {
																	coinbase_sell_price_bid = Some(bid_str);
																	//coinbase_buy_price_ask = Some(ask_str);

																	// Place your calculations and updates here
																		let gemini_taker_fee = 0.004;
																		let fraction_of_wallet_im_using = 0.03; //aka 3 percent
																		let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																		let fee_for_purchase = total_spent*gemini_taker_fee;
																		let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																		*gemini_wallet -= total_spent;

																		let amount_of_xrp = 
																		money_going_to_xrp_after_fees/gemini_buy_ask
																										.expect(&format!("gemini_buy_ask is somehow Not Some. 
																										even though to get to this point it had to be Some. 
																										gemini_buy_ask: {:?}
																										Honestly restart the program from the last saved state. 
																										The most likely error is a bit got flipped after the loop",
																										&gemini_buy_ask));

																		//coinbase calculations for sell

																		let coinbase_taker_fee = 0.008;
																		let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
																		let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
																		let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
																		*coinbase_wallet += money_from_sell_after_fees;
																		value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let gemini_wallet_unscaled = *gemini_wallet;
																			let coinbase_wallet_unscaled = *coinbase_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is bitstamp and gemini being updated, I will update:
																			//  56, 57, 60
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 60];
																			let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*gemini_wallet = gemini_wallet_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 60];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
																		// success = true;
																	},
																	_ => {
																		log::error!("i143: failed to parse JSON to f64");
																		if attempts > 3 {
																			panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																		}
																		continue ;
																	}
																}
															},
															_ => {
																log::error!("i143: Failed to get bid");
																if attempts > 3 {
																	panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																}
																continue ;
															}
														}
													}
												}
											},
											Err(_) => {
												log::error!("i143: failed to parse JSON as str");
												if attempts > 3 {
													panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
												}
												continue ; // Continue to the next iteration if parsing fails
											}
										}
									},
									Err(_) => {
										log::error!("i143: failed to get response text");
										if attempts > 3 {
											panic!("Failed to get response text after 3 attempts");
										}
										continue ; // Continue to the next iteration if getting response text fails
									}
								}
							},
							Err(_) => {
								log::error!("i143: Failed to execute request");
								if attempts > 3 {
									panic!("Failed to execute request after 3 attempts");
								}
								continue; // Continue to the next iteration if executing request fails
							}
						}
					},
					Err(_) => {
						log::error!("i143: Failed to build request");
						if attempts > 3 {
							panic!("i143: Failed to build request after 3 attempts");
						}
						continue; // Continue to the next iteration if building request fails
					}
				}
                //03/13/24 - removed:
				// if success == true {
				// 	break;
				// }
			}

        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
		// 		//panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
		// 		panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
		// 	}
		// }
		//02/27/24 - removed and placed above^
			//         //gemini calculations for buy 
			//     //this should equal 0.4%
			//     let gemini_taker_fee = 0.004;
			//     let fraction_of_wallet_im_using = 0.06; //aka 6 percent

			//     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
			//     let fee_for_purchase = total_spent*gemini_taker_fee;
			//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
			//     //new state of gemini wallet below
			//     *gemini_wallet -= total_spent;
			//     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




			// //coinbase calculations for sell

			//     let coinbase_taker_fee = 0.008;
			//     let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//     *coinbase_wallet += money_from_sell_after_fees;






			//     //coinbase calculations for buy - not needed in this so code commented out
				
			//         //let coinbase_taker_fee = 0.008;
		
			//         //let total_spent = 0.10*(*coinbase_wallet);
			//         //let fee_for_purchase = total_spent*coinbase_taker_fee;
			//         //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
			//         ////new state of coinbase wallet below
			//         //*coinbase_wallet -= total_spent;
			//         //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
		
			//     //kraken calculations - for sell
			//         //let kraken_taker_fee = 0.0026;
					
			//         //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
			//         //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
			//         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
			//         //*kraken_wallet += money_from_sell_after_fees;
		
			//         //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
		
		
			//     //bitstamp calculations - for sell
			//         //let bitstamp_taker_fee = 0.004;
			//         //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
			//         //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
			//         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
			//         //*bitstamp_wallet += money_from_sell_after_fees;



			//     //this will count as value after
			//         let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
		
			//         //value_after = 56
			//         //coinbase = 57
			//         //bitstamp = 58
			//         //kraken = 59
			//         //gemini = 60
			//         //since this is coinbase and gemini being updated, I will update:
			//         //  56, 57, 60
			//         let indices = [56, 57, 60];
			//         let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
			//         //01/24/24 - removed and added:
			//             //neural_network.update_input(&indices, &new_values);
			//             //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//             //neural_network.update_input(&indices, &transformed_values).await;
			//             let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//             neural_network.update_input(&indices, &scaled_values).await;
		
			// return Ok(value_after)
	}

    pub async fn s_i144_xrp_4_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
    //02/27/24 - added:
        let mut attempts = 0;
        let gemini_buy_ask: Option<f64>;
        loop {
            let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build();
        
            match gemini_request {
                Ok(request) => {
                    match client.execute(request).await {
                        Ok(response) => {
                            let gemini_response_text = response.text().await;
                            match gemini_response_text {
                                Ok(text) => {

                                    match serde_json::from_str::<Value>(&text) {
                                        //03/02/24 - replaced:
                                    // Ok(value) => {
                                    //     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                    //         .ok_or_else(|| "Failed to get ask as string")
                                    //         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                            
                                    //     match gemini_buy_ask_result {
                                    //         Ok(ask) => {
                                    //             gemini_buy_ask = Some(ask);
                                    //             // Continue with your logic here using `ask`
                                    //             break; // Exit the loop if everything is successful
                                    //         },
                                    //         Err(e) => log::error!("{}", e),
                                    //     }
                                    // },
                                    // Err(_) => log::error!("Failed to parse JSON"),
                                    //03/02/24 - added in its place:
                                    Ok(value) => {
                                        match value["ask"].as_str() {
                                            Some(ask_str) => {
                                                match ask_str.parse::<f64>() {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(_) => log::error!("i144: gemini:  Failed to parse ask as f64"),
                                                }
                                            },
                                            None => log::error!("i144:gemini:  Failed to get ask as string"),
                                        }
                                    },
                                    Err(_) => log::error!("i144: gemini:  Failed to parse JSON"),
                                    }
                                },
                                Err(_) => log::error!("i144: gemini:  Failed to turn response into text"),
                            }
                        },
                        Err(_) => log::error!("i144: gemini:  Failed to execute Gemini request"),
                    }
                },
                Err(_) => log::error!("i144: gemini:  Couldn't build gemini request"),
            }
        
            attempts += 1;
            if attempts >= 3 {
                panic!("Failed after 3 attempts");
            }
        }




        println!("xrp 4 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

    //02/27/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build Coinbase request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }
    //02/27/24 - added in its place:
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        //03/13/24 - removed:
        // let mut success = false;
        loop {
            attempts +=1;
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let gemini_taker_fee = 0.004;
                                                                        let fraction_of_wallet_im_using = 0.04; //aka 4 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                                        let fee_for_purchase = total_spent*gemini_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *gemini_wallet -= total_spent;

                                                                        let amount_of_xrp = 
                                                                        money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                        .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                        even though to get to this point it had to be Some. 
                                                                                                        gemini_buy_ask: {:?}
                                                                                                        Honestly restart the program from the last saved state. 
                                                                                                        The most likely error is a bit got flipped after the loop",
                                                                                                        &gemini_buy_ask));

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let gemini_wallet_unscaled = *gemini_wallet;
																			let coinbase_wallet_unscaled = *coinbase_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is bitstamp and gemini being updated, I will update:
																			//  56, 57, 60
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 60];
																			let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*gemini_wallet = gemini_wallet_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 60];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
                                                                        // success = true;
																},
																_ => {
																	log::error!("i144: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i144: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i144: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i144: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i144: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i144: Failed to build request");
					if attempts > 3 {
						panic!("i144: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
        // match value_after {
        //     Some(value) => return Ok(value),
        //     None => {
        //         //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
        //         panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
        //     }
        // }
        //02/27/24 - removed and placed above^
            //         //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.06; //aka 6 percent

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //     //coinbase calculations for buy - not needed in this so code commented out
                
            //         //let coinbase_taker_fee = 0.008;
        
            //         //let total_spent = 0.10*(*coinbase_wallet);
            //         //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //         //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //         ////new state of coinbase wallet below
            //         //*coinbase_wallet -= total_spent;
            //         //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
        
            //     //kraken calculations - for sell
            //         //let kraken_taker_fee = 0.0026;
                    
            //         //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //         //*kraken_wallet += money_from_sell_after_fees;
        
            //         //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        
            //     //bitstamp calculations - for sell
            //         //let bitstamp_taker_fee = 0.004;
            //         //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //         //*bitstamp_wallet += money_from_sell_after_fees;



            //     //this will count as value after
            //         let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        
            //         //value_after = 56
            //         //coinbase = 57
            //         //bitstamp = 58
            //         //kraken = 59
            //         //gemini = 60
            //         //since this is coinbase and gemini being updated, I will update:
            //         //  56, 57, 60
            //         let indices = [56, 57, 60];
            //         let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //         //01/24/24 - removed and added:
            //             //neural_network.update_input(&indices, &new_values);
            //             //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //             //neural_network.update_input(&indices, &transformed_values).await;
            //             let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //             neural_network.update_input(&indices, &scaled_values).await;
        
            // return Ok(value_after)
    }

    pub async fn s_i145_xrp_5_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
    //02/27/24 - added:
        let mut attempts = 0;
        let gemini_buy_ask: Option<f64>;
        loop {
            let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build();
        
            match gemini_request {
                Ok(request) => {
                    match client.execute(request).await {
                        Ok(response) => {
                            let gemini_response_text = response.text().await;
                            match gemini_response_text {
                                Ok(text) => {

                                    match serde_json::from_str::<Value>(&text) {
                                        //03/02/24 - replaced:
                                    // Ok(value) => {
                                    //     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                    //         .ok_or_else(|| "Failed to get ask as string")
                                    //         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                            
                                    //     match gemini_buy_ask_result {
                                    //         Ok(ask) => {
                                    //             gemini_buy_ask = Some(ask);
                                    //             // Continue with your logic here using `ask`
                                    //             break; // Exit the loop if everything is successful
                                    //         },
                                    //         Err(e) => log::error!("{}", e),
                                    //     }
                                    // },
                                    // Err(_) => log::error!("Failed to parse JSON"),
                                    //03/02/24 - added in its place:
                                    Ok(value) => {
                                        match value["ask"].as_str() {
                                            Some(ask_str) => {
                                                match ask_str.parse::<f64>() {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(_) => log::error!("i145: gemini:  Failed to parse ask as f64"),
                                                }
                                            },
                                            None => log::error!("i145: gemini:  Failed to get ask as string"),
                                        }
                                    },
                                    Err(_) => log::error!("i145: gemini:  Failed to parse JSON"),
                                    }
                                },
                                Err(_) => log::error!("i145: gemini:  Failed to turn response into text"),
                            }
                        },
                        Err(_) => log::error!("i145: gemini:  Failed to execute Gemini request"),
                    }
                },
                Err(_) => log::error!("i145: gemini:  Couldn't build gemini request"),
            }
        
            attempts += 1;
            if attempts >= 3 {
                panic!("Failed after 3 attempts");
            }
        }




        println!("xrp 5 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

    //02/27/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build Coinbase request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }
    //02/27/24 - added in its place:
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        //03/13/24 - removed:
        // let mut success = false;
        loop {
            attempts +=1;
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let gemini_taker_fee = 0.004;
                                                                        let fraction_of_wallet_im_using = 0.05; //aka 5 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                                        let fee_for_purchase = total_spent*gemini_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *gemini_wallet -= total_spent;

                                                                        let amount_of_xrp = 
                                                                        money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                        .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                        even though to get to this point it had to be Some. 
                                                                                                        gemini_buy_ask: {:?}
                                                                                                        Honestly restart the program from the last saved state. 
                                                                                                        The most likely error is a bit got flipped after the loop",
                                                                                                        &gemini_buy_ask));

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let gemini_wallet_unscaled = *gemini_wallet;
																			let coinbase_wallet_unscaled = *coinbase_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is bitstamp and gemini being updated, I will update:
																			//  56, 57, 60
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 60];
																			let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*gemini_wallet = gemini_wallet_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 60];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
                                                                        // success = true;
																},
																_ => {
																	log::error!("i145: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i145: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i145: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i145: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i145: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i145: Failed to build request");
					if attempts > 3 {
						panic!("i145: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
        // match value_after {
        //     Some(value) => return Ok(value),
        //     None => {
        //         //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
        //         panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
        //     }
        // }
        //02/27/24 - removed and placed above^
            //         //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.06; //aka 6 percent

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //     //coinbase calculations for buy - not needed in this so code commented out
                
            //         //let coinbase_taker_fee = 0.008;
        
            //         //let total_spent = 0.10*(*coinbase_wallet);
            //         //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //         //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //         ////new state of coinbase wallet below
            //         //*coinbase_wallet -= total_spent;
            //         //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
        
            //     //kraken calculations - for sell
            //         //let kraken_taker_fee = 0.0026;
                    
            //         //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //         //*kraken_wallet += money_from_sell_after_fees;
        
            //         //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        
            //     //bitstamp calculations - for sell
            //         //let bitstamp_taker_fee = 0.004;
            //         //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //         //*bitstamp_wallet += money_from_sell_after_fees;



            //     //this will count as value after
            //         let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        
            //         //value_after = 56
            //         //coinbase = 57
            //         //bitstamp = 58
            //         //kraken = 59
            //         //gemini = 60
            //         //since this is coinbase and gemini being updated, I will update:
            //         //  56, 57, 60
            //         let indices = [56, 57, 60];
            //         let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //         //01/24/24 - removed and added:
            //             //neural_network.update_input(&indices, &new_values);
            //             //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //             //neural_network.update_input(&indices, &transformed_values).await;
            //             let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //             neural_network.update_input(&indices, &scaled_values).await;
        
            // return Ok(value_after)
    }

    pub async fn s_i146_xrp_6_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
    //02/27/24 - added:
        let mut attempts = 0;
        let gemini_buy_ask: Option<f64>;
        loop {
            let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build();
        
            match gemini_request {
                Ok(request) => {
                    match client.execute(request).await {
                        Ok(response) => {
                            let gemini_response_text = response.text().await;
                            match gemini_response_text {
                                Ok(text) => {

                                    match serde_json::from_str::<Value>(&text) {
                                        //03/02/24 - replaced:
                                    // Ok(value) => {
                                    //     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                    //         .ok_or_else(|| "Failed to get ask as string")
                                    //         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                            
                                    //     match gemini_buy_ask_result {
                                    //         Ok(ask) => {
                                    //             gemini_buy_ask = Some(ask);
                                    //             // Continue with your logic here using `ask`
                                    //             break; // Exit the loop if everything is successful
                                    //         },
                                    //         Err(e) => log::error!("{}", e),
                                    //     }
                                    // },
                                    // Err(_) => log::error!("Failed to parse JSON"),
                                    //03/02/24 - added in its place:
                                    Ok(value) => {
                                        match value["ask"].as_str() {
                                            Some(ask_str) => {
                                                match ask_str.parse::<f64>() {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(_) => log::error!("i146: gemini:  Failed to parse ask as f64"),
                                                }
                                            },
                                            None => log::error!("i146: gemini:  Failed to get ask as string"),
                                        }
                                    },
                                    Err(_) => log::error!("i146: gemini:  Failed to parse JSON"),
                                    }
                                },
                                Err(_) => log::error!("i146: gemini:  Failed to turn response into text"),
                            }
                        },
                        Err(_) => log::error!("i146: gemini:  Failed to execute Gemini request"),
                    }
                },
                Err(_) => log::error!("i146: gemini:  Couldn't build gemini request"),
            }
        
            attempts += 1;
            if attempts >= 3 {
                panic!("Failed after 3 attempts");
            }
        }




        println!("xrp 6 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

    //02/27/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build Coinbase request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }
    //02/27/24 - added in its place:
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        //03/13/24 - removed:
        // let mut success = false;
        loop {
            attempts +=1;
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let gemini_taker_fee = 0.004;
                                                                        let fraction_of_wallet_im_using = 0.06; //aka 6 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                                        let fee_for_purchase = total_spent*gemini_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *gemini_wallet -= total_spent;

                                                                        let amount_of_xrp = 
                                                                        money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                        .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                        even though to get to this point it had to be Some. 
                                                                                                        gemini_buy_ask: {:?}
                                                                                                        Honestly restart the program from the last saved state. 
                                                                                                        The most likely error is a bit got flipped after the loop",
                                                                                                        &gemini_buy_ask));

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let gemini_wallet_unscaled = *gemini_wallet;
																			let coinbase_wallet_unscaled = *coinbase_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is bitstamp and gemini being updated, I will update:
																			//  56, 57, 60
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 60];
																			let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*gemini_wallet = gemini_wallet_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 60];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
                                                                        // success = true;
																},
																_ => {
																	log::error!("i146: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i146: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i146: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i146: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i146: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i146: Failed to build request");
					if attempts > 3 {
						panic!("i146: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
        // match value_after {
        //     Some(value) => return Ok(value),
        //     None => {
        //         //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
        //         panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
        //     }
        // }
        //02/27/24 - removed and placed above^
            //         //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.06; //aka 6 percent

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //     //coinbase calculations for buy - not needed in this so code commented out
                
            //         //let coinbase_taker_fee = 0.008;
        
            //         //let total_spent = 0.10*(*coinbase_wallet);
            //         //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //         //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //         ////new state of coinbase wallet below
            //         //*coinbase_wallet -= total_spent;
            //         //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
        
            //     //kraken calculations - for sell
            //         //let kraken_taker_fee = 0.0026;
                    
            //         //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //         //*kraken_wallet += money_from_sell_after_fees;
        
            //         //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        
            //     //bitstamp calculations - for sell
            //         //let bitstamp_taker_fee = 0.004;
            //         //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //         //*bitstamp_wallet += money_from_sell_after_fees;



            //     //this will count as value after
            //         let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        
            //         //value_after = 56
            //         //coinbase = 57
            //         //bitstamp = 58
            //         //kraken = 59
            //         //gemini = 60
            //         //since this is coinbase and gemini being updated, I will update:
            //         //  56, 57, 60
            //         let indices = [56, 57, 60];
            //         let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //         //01/24/24 - removed and added:
            //             //neural_network.update_input(&indices, &new_values);
            //             //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //             //neural_network.update_input(&indices, &transformed_values).await;
            //             let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //             neural_network.update_input(&indices, &scaled_values).await;
        
            // return Ok(value_after)
    }

    pub async fn s_i147_xrp_7_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
    //02/27/24 - added:
        let mut attempts = 0;
        let gemini_buy_ask: Option<f64>;
        loop {
            let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build();
        
            match gemini_request {
                Ok(request) => {
                    match client.execute(request).await {
                        Ok(response) => {
                            let gemini_response_text = response.text().await;
                            match gemini_response_text {
                                Ok(text) => {

                                    match serde_json::from_str::<Value>(&text) {
                                        //03/02/24 - replaced:
                                    // Ok(value) => {
                                    //     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                    //         .ok_or_else(|| "Failed to get ask as string")
                                    //         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                            
                                    //     match gemini_buy_ask_result {
                                    //         Ok(ask) => {
                                    //             gemini_buy_ask = Some(ask);
                                    //             // Continue with your logic here using `ask`
                                    //             break; // Exit the loop if everything is successful
                                    //         },
                                    //         Err(e) => log::error!("{}", e),
                                    //     }
                                    // },
                                    // Err(_) => log::error!("Failed to parse JSON"),
                                    //03/02/24 - added in its place:
                                    Ok(value) => {
                                        match value["ask"].as_str() {
                                            Some(ask_str) => {
                                                match ask_str.parse::<f64>() {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(_) => log::error!("i147:gemini:   Failed to parse ask as f64"),
                                                }
                                            },
                                            None => log::error!("i147: gemini:  Failed to get ask as string"),
                                        }
                                    },
                                    Err(_) => log::error!("i147: gemini:  Failed to parse JSON"),
                                    }
                                },
                                Err(_) => log::error!("i147:gemini:   Failed to turn response into text"),
                            }
                        },
                        Err(_) => log::error!("i147:gemini:   Failed to execute Gemini request"),
                    }
                },
                Err(_) => log::error!("i147:gemini:   Couldn't build gemini request"),
            }
        
            attempts += 1;
            if attempts >= 3 {
                panic!("Failed after 3 attempts");
            }
        }




        println!("xrp 7 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

    //02/27/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build Coinbase request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }
    //02/27/24 - added in its place:
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        //03/13/24 - removed:
        // let mut success = false;
        loop {
            attempts +=1;
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let gemini_taker_fee = 0.004;
                                                                        let fraction_of_wallet_im_using = 0.07; //aka 7 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                                        let fee_for_purchase = total_spent*gemini_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *gemini_wallet -= total_spent;

                                                                        let amount_of_xrp = 
                                                                        money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                        .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                        even though to get to this point it had to be Some. 
                                                                                                        gemini_buy_ask: {:?}
                                                                                                        Honestly restart the program from the last saved state. 
                                                                                                        The most likely error is a bit got flipped after the loop",
                                                                                                        &gemini_buy_ask));

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let gemini_wallet_unscaled = *gemini_wallet;
																			let coinbase_wallet_unscaled = *coinbase_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is bitstamp and gemini being updated, I will update:
																			//  56, 57, 60
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 60];
																			let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*gemini_wallet = gemini_wallet_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 60];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
                                                                        // success = true;
																},
																_ => {
																	log::error!("i147: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i147: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i147: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i147: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i147: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i147: Failed to build request");
					if attempts > 3 {
						panic!("i147: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
        // match value_after {
        //     Some(value) => return Ok(value),
        //     None => {
        //         //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
        //         panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
        //     }
        // }
        //02/27/24 - removed and placed above^
            //         //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.06; //aka 6 percent

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //     //coinbase calculations for buy - not needed in this so code commented out
                
            //         //let coinbase_taker_fee = 0.008;
        
            //         //let total_spent = 0.10*(*coinbase_wallet);
            //         //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //         //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //         ////new state of coinbase wallet below
            //         //*coinbase_wallet -= total_spent;
            //         //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
        
            //     //kraken calculations - for sell
            //         //let kraken_taker_fee = 0.0026;
                    
            //         //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //         //*kraken_wallet += money_from_sell_after_fees;
        
            //         //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        
            //     //bitstamp calculations - for sell
            //         //let bitstamp_taker_fee = 0.004;
            //         //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //         //*bitstamp_wallet += money_from_sell_after_fees;



            //     //this will count as value after
            //         let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        
            //         //value_after = 56
            //         //coinbase = 57
            //         //bitstamp = 58
            //         //kraken = 59
            //         //gemini = 60
            //         //since this is coinbase and gemini being updated, I will update:
            //         //  56, 57, 60
            //         let indices = [56, 57, 60];
            //         let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //         //01/24/24 - removed and added:
            //             //neural_network.update_input(&indices, &new_values);
            //             //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //             //neural_network.update_input(&indices, &transformed_values).await;
            //             let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //             neural_network.update_input(&indices, &scaled_values).await;
        
            // return Ok(value_after)
    }

    pub async fn s_i148_xrp_8_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
    //02/27/24 - added:
        let mut attempts = 0;
        let gemini_buy_ask: Option<f64>;
        loop {
            let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build();
        
            match gemini_request {
                Ok(request) => {
                    match client.execute(request).await {
                        Ok(response) => {
                            let gemini_response_text = response.text().await;
                            match gemini_response_text {
                                Ok(text) => {

                                    match serde_json::from_str::<Value>(&text) {
                                        //03/02/24 - replaced:
                                    // Ok(value) => {
                                    //     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                    //         .ok_or_else(|| "Failed to get ask as string")
                                    //         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                            
                                    //     match gemini_buy_ask_result {
                                    //         Ok(ask) => {
                                    //             gemini_buy_ask = Some(ask);
                                    //             // Continue with your logic here using `ask`
                                    //             break; // Exit the loop if everything is successful
                                    //         },
                                    //         Err(e) => log::error!("{}", e),
                                    //     }
                                    // },
                                    // Err(_) => log::error!("Failed to parse JSON"),
                                    //03/02/24 - added in its place:
                                    Ok(value) => {
                                        match value["ask"].as_str() {
                                            Some(ask_str) => {
                                                match ask_str.parse::<f64>() {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(_) => log::error!("i148: gemini: Failed to parse ask as f64"),
                                                }
                                            },
                                            None => log::error!("i148: gemini:  Failed to get ask as string"),
                                        }
                                    },
                                    Err(_) => log::error!("i148: gemini:  Failed to parse JSON"),
                                    }
                                },
                                Err(_) => log::error!("i148: gemini:  Failed to turn response into text"),
                            }
                        },
                        Err(_) => log::error!("i148: gemini:  Failed to execute Gemini request"),
                    }
                },
                Err(_) => log::error!("i148: gemini:  Couldn't build gemini request"),
            }
        
            attempts += 1;
            if attempts >= 3 {
                panic!("Failed after 3 attempts");
            }
        }




        println!("xrp 8 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

    //02/27/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build Coinbase request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }
    //02/27/24 - added in its place:
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        //03/13/24 - removed:
        // let mut success = false;
        loop {
            attempts +=1;
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let gemini_taker_fee = 0.004;
                                                                        let fraction_of_wallet_im_using = 0.08; //aka 8 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                                        let fee_for_purchase = total_spent*gemini_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *gemini_wallet -= total_spent;

                                                                        let amount_of_xrp = 
                                                                        money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                        .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                        even though to get to this point it had to be Some. 
                                                                                                        gemini_buy_ask: {:?}
                                                                                                        Honestly restart the program from the last saved state. 
                                                                                                        The most likely error is a bit got flipped after the loop",
                                                                                                        &gemini_buy_ask));

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let gemini_wallet_unscaled = *gemini_wallet;
																			let coinbase_wallet_unscaled = *coinbase_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is bitstamp and gemini being updated, I will update:
																			//  56, 57, 60
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 60];
																			let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*gemini_wallet = gemini_wallet_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 60];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
                                                                        // success = true;
																},
																_ => {
																	log::error!("i148: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i148: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i148: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i148: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i148: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i148: Failed to build request");
					if attempts > 3 {
						panic!("i148: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
        // match value_after {
        //     Some(value) => return Ok(value),
        //     None => {
        //         //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
        //         panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
        //     }
        // }
        //02/27/24 - removed and placed above^
            //         //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.06; //aka 6 percent

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //     //coinbase calculations for buy - not needed in this so code commented out
                
            //         //let coinbase_taker_fee = 0.008;
        
            //         //let total_spent = 0.10*(*coinbase_wallet);
            //         //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //         //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //         ////new state of coinbase wallet below
            //         //*coinbase_wallet -= total_spent;
            //         //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
        
            //     //kraken calculations - for sell
            //         //let kraken_taker_fee = 0.0026;
                    
            //         //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //         //*kraken_wallet += money_from_sell_after_fees;
        
            //         //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        
            //     //bitstamp calculations - for sell
            //         //let bitstamp_taker_fee = 0.004;
            //         //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //         //*bitstamp_wallet += money_from_sell_after_fees;



            //     //this will count as value after
            //         let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        
            //         //value_after = 56
            //         //coinbase = 57
            //         //bitstamp = 58
            //         //kraken = 59
            //         //gemini = 60
            //         //since this is coinbase and gemini being updated, I will update:
            //         //  56, 57, 60
            //         let indices = [56, 57, 60];
            //         let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //         //01/24/24 - removed and added:
            //             //neural_network.update_input(&indices, &new_values);
            //             //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //             //neural_network.update_input(&indices, &transformed_values).await;
            //             let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //             neural_network.update_input(&indices, &scaled_values).await;
        
            // return Ok(value_after)
    }

    pub async fn s_i149_xrp_9_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
    //02/27/24 - added:
        let mut attempts = 0;
        let gemini_buy_ask: Option<f64>;
        loop {
            let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build();
        
            match gemini_request {
                Ok(request) => {
                    match client.execute(request).await {
                        Ok(response) => {
                            let gemini_response_text = response.text().await;
                            match gemini_response_text {
                                Ok(text) => {

                                    match serde_json::from_str::<Value>(&text) {
                                        //03/02/24 - replaced:
                                    // Ok(value) => {
                                    //     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                    //         .ok_or_else(|| "Failed to get ask as string")
                                    //         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                            
                                    //     match gemini_buy_ask_result {
                                    //         Ok(ask) => {
                                    //             gemini_buy_ask = Some(ask);
                                    //             // Continue with your logic here using `ask`
                                    //             break; // Exit the loop if everything is successful
                                    //         },
                                    //         Err(e) => log::error!("{}", e),
                                    //     }
                                    // },
                                    // Err(_) => log::error!("Failed to parse JSON"),
                                    //03/02/24 - added in its place:
                                    Ok(value) => {
                                        match value["ask"].as_str() {
                                            Some(ask_str) => {
                                                match ask_str.parse::<f64>() {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        // Continue with your logic here using `ask`
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(_) => log::error!("i149: gemini:  Failed to parse ask as f64"),
                                                }
                                            },
                                            None => log::error!("i149: gemini:  Failed to get ask as string"),
                                        }
                                    },
                                    Err(_) => log::error!("i149: gemini:  Failed to parse JSON"),
                                    }
                                },
                                Err(_) => log::error!("i149: gemini:  Failed to turn response into text"),
                            }
                        },
                        Err(_) => log::error!("i149: gemini:  Failed to execute Gemini request"),
                    }
                },
                Err(_) => log::error!("i149: gemini:  Couldn't build gemini request"),
            }
        
            attempts += 1;
            if attempts >= 3 {
                panic!("Failed after 3 attempts");
            }
        }




        println!("xrp 9 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

    //02/27/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build Coinbase request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }
    //02/27/24 - added in its place:
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        //03/13/24 - removed:
        // let mut success = false;
        loop {
            attempts +=1;
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let gemini_taker_fee = 0.004;
                                                                        let fraction_of_wallet_im_using = 0.09; //aka 9 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                                        let fee_for_purchase = total_spent*gemini_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *gemini_wallet -= total_spent;

                                                                        let amount_of_xrp = 
                                                                        money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                        .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                        even though to get to this point it had to be Some. 
                                                                                                        gemini_buy_ask: {:?}
                                                                                                        Honestly restart the program from the last saved state. 
                                                                                                        The most likely error is a bit got flipped after the loop",
                                                                                                        &gemini_buy_ask));

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let gemini_wallet_unscaled = *gemini_wallet;
																			let coinbase_wallet_unscaled = *coinbase_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is bitstamp and gemini being updated, I will update:
																			//  56, 57, 60
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 60];
																			let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*gemini_wallet = gemini_wallet_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 60];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
                                                                        // success = true;
																},
																_ => {
																	log::error!("i149: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i149: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i149: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i149: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i149: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i149: Failed to build request");
					if attempts > 3 {
						panic!("i149: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
        // match value_after {
        //     Some(value) => return Ok(value),
        //     None => {
        //         //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
        //         panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
        //     }
        // }
        //02/27/24 - removed and placed above^
            //         //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.06; //aka 6 percent

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //     //coinbase calculations for buy - not needed in this so code commented out
                
            //         //let coinbase_taker_fee = 0.008;
        
            //         //let total_spent = 0.10*(*coinbase_wallet);
            //         //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //         //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //         ////new state of coinbase wallet below
            //         //*coinbase_wallet -= total_spent;
            //         //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
        
            //     //kraken calculations - for sell
            //         //let kraken_taker_fee = 0.0026;
                    
            //         //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //         //*kraken_wallet += money_from_sell_after_fees;
        
            //         //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        
            //     //bitstamp calculations - for sell
            //         //let bitstamp_taker_fee = 0.004;
            //         //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //         //*bitstamp_wallet += money_from_sell_after_fees;



            //     //this will count as value after
            //         let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        
            //         //value_after = 56
            //         //coinbase = 57
            //         //bitstamp = 58
            //         //kraken = 59
            //         //gemini = 60
            //         //since this is coinbase and gemini being updated, I will update:
            //         //  56, 57, 60
            //         let indices = [56, 57, 60];
            //         let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //         //01/24/24 - removed and added:
            //             //neural_network.update_input(&indices, &new_values);
            //             //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //             //neural_network.update_input(&indices, &transformed_values).await;
            //             let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //             neural_network.update_input(&indices, &scaled_values).await;
        
            // return Ok(value_after)
    }

    pub async fn s_i150_xrp_10_gemini_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);
        
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);
    //02/27/24 - added:
        let mut attempts = 0;
        let gemini_buy_ask: Option<f64>;
        loop {
            let gemini_request = client.get(gemini_url)
                .header("Content-Type", gemini_content_type)
                .header("Content-Length", gemini_content_length)
                .header("X-GEMINI-APIKEY", gemini_api_key)
                .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                .header("X-GEMINI-SIGNATURE", &gemini_signature)
                .header("Cache-Control", gemini_cache_control)
                .build();
        
            match gemini_request {
                Ok(request) => {
                    match client.execute(request).await {
                        Ok(response) => {
                            let gemini_response_text = response.text().await;
                            match gemini_response_text {
                                Ok(text) => {

                                    match serde_json::from_str::<Value>(&text) {
                                        //03/02/24 - replaced:
                                    // Ok(value) => {
                                    //     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
                                    //         .ok_or_else(|| "Failed to get ask as string")
                                    //         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
                            
                                    //     match gemini_buy_ask_result {
                                    //         Ok(ask) => {
                                    //             gemini_buy_ask = Some(ask);
                                    //             // Continue with your logic here using `ask`
                                    //             break; // Exit the loop if everything is successful
                                    //         },
                                    //         Err(e) => log::error!("{}", e),
                                    //     }
                                    // },
                                    // Err(_) => log::error!("Failed to parse JSON"),
                                    //03/02/24 - added in its place:
                                    Ok(value) => {
                                        match value["ask"].as_str() {
                                            Some(ask_str) => {
                                                match ask_str.parse::<f64>() {
                                                    Ok(ask) => {
                                                        gemini_buy_ask = Some(ask);
                                                        break; // Exit the loop if everything is successful
                                                    },
                                                    Err(_) => log::error!("i150: gemini:  Failed to parse ask as f64"),
                                                }
                                            },
                                            None => log::error!("i150: gemini:  Failed to get ask as string"),
                                        }
                                    },
                                    Err(_) => log::error!("i150: gemini:  Failed to parse JSON"),
                                    }
                                },
                                Err(_) => log::error!("i150: gemini:  Failed to turn response into text"),
                            }
                        },
                        Err(_) => log::error!("i150: gemini:  Failed to execute Gemini request"),
                    }
                },
                Err(_) => log::error!("i150: gemini:  Couldn't build gemini request"),
            }
        
            attempts += 1;
            if attempts >= 3 {
                panic!("Failed after 3 attempts");
            }
        }




        println!("xrp 10 gemini coinbase simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //------------COINBASE------------//
        let now = Utc::now();
        let time_stamp = now.timestamp().to_string();
        let method = "GET";
        let request_path = "/api/v3/brokerage/best_bid_ask";
        let body = "";
        let message = format!("{}{}{}{}", &time_stamp, 
        &method, &request_path, &body);
        type HmacSha256 = Hmac<Sha256>;
        fn sign(message: &str, coinbase_secret: &str) -> String {
        let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                    .expect("HMAC can take key of any size");
        mac.update(message.as_bytes());
        let result = mac.finalize();
        let code_bytes = result.into_bytes();
        hex::encode(code_bytes)
        }
        let coinbase_signature = sign(&message, &coinbase_secret);

    //02/27/24 - removed:
        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build Coinbase request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }
    //02/27/24 - added in its place:
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        //03/13/24 - removed:
        // let mut success = false;
        loop {
            attempts +=1;
            let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
            .header("CB-ACCESS-KEY", coinbase_api_key)
            .header("CB-ACCESS-SIGN", &coinbase_signature)
            .header("CB-ACCESS-TIMESTAMP", &time_stamp)
            .build();
            //.expect("couldn't build request");
            //manages the error I described above
            //let request = match request {
            //Ok(req) => req,
            //Err(e) => {
            //eprintln!("Failed to build request: \n{}", e);
            //return Err(e);
            //}
            //};
            match request {
                Ok(req) => {
            //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                    let response = client.execute(req).await;
                    match response {
                        Ok(resp) => {
                            let response_text = resp.text().await;
                            match response_text {
                                Ok(text) => {
                                    match serde_json::from_str::<Value>(&text) {
                                        Ok(v) => {
                                            if let Some(pricebooks) = v["pricebooks"].as_array() {
                                                for pricebook in pricebooks {
                                                    //let product_id = pricebook["product_id"].as_str();
                                                    let bids = &pricebook["bids"][0];
                                                    //let asks = &pricebook["asks"][0];
                                                    let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                    //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
        
                                                    match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                        (Some(bid_str), /*Some(ask_str)*/) => {
                                                            match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                                (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                    coinbase_sell_price_bid = Some(bid_str);
                                                                    //coinbase_buy_price_ask = Some(ask_str);

                                                                    // Place your calculations and updates here
                                                                        let gemini_taker_fee = 0.004;
                                                                        let fraction_of_wallet_im_using = 0.10; //aka 10 percent
                                                                        let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
                                                                        let fee_for_purchase = total_spent*gemini_taker_fee;
                                                                        let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                        *gemini_wallet -= total_spent;

                                                                        let amount_of_xrp = 
                                                                        money_going_to_xrp_after_fees/gemini_buy_ask
                                                                                                        .expect(&format!("gemini_buy_ask is somehow Not Some. 
                                                                                                        even though to get to this point it had to be Some. 
                                                                                                        gemini_buy_ask: {:?}
                                                                                                        Honestly restart the program from the last saved state. 
                                                                                                        The most likely error is a bit got flipped after the loop",
                                                                                                        &gemini_buy_ask));

                                                                        //coinbase calculations for sell

                                                                        let coinbase_taker_fee = 0.008;
                                                                        let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                        let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                        let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                        *coinbase_wallet += money_from_sell_after_fees;
                                                                        value_after = Some(kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																		if let Some(mut value_after) = value_after {

																			//03/10/24 - added for unscaling
																			let value_after_unscaled = value_after;
																			let gemini_wallet_unscaled = *gemini_wallet;
																			let coinbase_wallet_unscaled = *coinbase_wallet;

																			*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																			*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																			value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																			
																			//value_after = 56
																			//coinbase = 57
																			//bitstamp = 58
																			//kraken = 59
																			//gemini = 60
																			//since this is bitstamp and gemini being updated, I will update:
																			//  56, 57, 60
																			//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																			let indices = [56, 57, 60];
																			let scaled_values = [value_after, *coinbase_wallet, *gemini_wallet];
																			//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																			neural_network.update_input(&indices, &scaled_values).await;

																			//03/10/24 - added for unscaling:
																			value_after = value_after_unscaled;
																			*gemini_wallet = gemini_wallet_unscaled;
																			*coinbase_wallet = coinbase_wallet_unscaled;

                                                                            //03/13/24 - added:
                                                                            return Ok(value_after);
																		}
																		//03/08/24 - removed:
																		// //value_after = 56
																		// //coinbase = 57
																		// //bitstamp = 58
																		// //kraken = 59
																		// //gemini = 60
																		// //since this is coinbase and gemini being updated, I will update:
																		// //  56, 57, 60
																		// let indices = [56, 57, 60];
																		// let new_values = [value_after, Some(*coinbase_wallet), Some(*gemini_wallet)];
																		// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		// neural_network.update_input(&indices, &scaled_values).await;

                                                                        //03/13/24 - removed:
                                                                        // success = true;
																},
																_ => {
																	log::error!("i150: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i150: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i150: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i150: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i150: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i150: Failed to build request");
					if attempts > 3 {
						panic!("i150: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
            //03/13/24 - removed:
			// if success == true {
			// 	break;
			// }
		}
        //03/13/24 - removed:
        // match value_after {
        //     Some(value) => return Ok(value),
        //     None => {
        //         //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
        //         panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
        //     }
        // }
        //02/27/24 - removed and placed above^
            //         //gemini calculations for buy 
            //     //this should equal 0.4%
            //     let gemini_taker_fee = 0.004;
            //     let fraction_of_wallet_im_using = 0.06; //aka 6 percent

            //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
            //     let fee_for_purchase = total_spent*gemini_taker_fee;
            //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
            //     //new state of gemini wallet below
            //     *gemini_wallet -= total_spent;
            //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
    
    
    

            // //coinbase calculations for sell

            //     let coinbase_taker_fee = 0.008;
            //     let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
            //     let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
            //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //     *coinbase_wallet += money_from_sell_after_fees;
    
    
    
    


            //     //coinbase calculations for buy - not needed in this so code commented out
                
            //         //let coinbase_taker_fee = 0.008;
        
            //         //let total_spent = 0.10*(*coinbase_wallet);
            //         //let fee_for_purchase = total_spent*coinbase_taker_fee;
            //         //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
            //         ////new state of coinbase wallet below
            //         //*coinbase_wallet -= total_spent;
            //         //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;
        
            //     //kraken calculations - for sell
            //         //let kraken_taker_fee = 0.0026;
                    
            //         //let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
            //         //*kraken_wallet += money_from_sell_after_fees;
        
            //         //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;
        
        
            //     //bitstamp calculations - for sell
            //         //let bitstamp_taker_fee = 0.004;
            //         //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
            //         //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
            //         //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
            //         //*bitstamp_wallet += money_from_sell_after_fees;



            //     //this will count as value after
            //         let value_after = kraken_wallet + *coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        
            //         //value_after = 56
            //         //coinbase = 57
            //         //bitstamp = 58
            //         //kraken = 59
            //         //gemini = 60
            //         //since this is coinbase and gemini being updated, I will update:
            //         //  56, 57, 60
            //         let indices = [56, 57, 60];
            //         let new_values = [value_after, *coinbase_wallet, *gemini_wallet];
            //         //01/24/24 - removed and added:
            //             //neural_network.update_input(&indices, &new_values);
            //             //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
            //             //neural_network.update_input(&indices, &transformed_values).await;
            //             let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
            //             neural_network.update_input(&indices, &scaled_values).await;
        
            // return Ok(value_after)
    }
//gemini kraken     = 3 AND UP for min of 10 USD for gemini. min buy of 10 XRP for kraken so maximal min is 6 dollars.
	pub async fn s_i153_xrp_3_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
			let encoded_payload = encode(gemini_payload.to_string());
			let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
							.expect("HMAC can take key of any size");
			mac.update(encoded_payload.as_bytes());
			let result = mac.finalize();
			let code_bytes = result.into_bytes();
			let gemini_signature = hex::encode(code_bytes);
			println!("Gemini signature:\n{}", &gemini_signature);
			gemini_signature

		}
		//if no "now" in scope when moving file, 
		//	the code is this:
		////returns current time.
		//		let now = Utc::now();
		let now = Utc::now();
		let gemini_time_stamp = now.timestamp().to_string();
		let gemini_nonce = gemini_time_stamp;
		let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
		let gemini_payload = json!({
			"request": "/v1/mytrades",
			"nonce": &gemini_nonce
		});
		let base64_encoded_payload = encode(gemini_payload.to_string());
		let gemini_content_type = "text/plain";
		let gemini_content_length = "0";
		let gemini_cache_control = "no-cache";
		let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

		//02/07/24 - added:
			let mut attempts = 0;
			let gemini_buy_ask: Option<f64>;
			loop {
				let gemini_request = client.get(gemini_url)
					.header("Content-Type", gemini_content_type)
					.header("Content-Length", gemini_content_length)
					.header("X-GEMINI-APIKEY", gemini_api_key)
					.header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
					.header("X-GEMINI-SIGNATURE", &gemini_signature)
					.header("Cache-Control", gemini_cache_control)
					.build();
			
				match gemini_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								let gemini_response_text = response.text().await;
								match gemini_response_text {
									Ok(text) => {

										match serde_json::from_str::<Value>(&text) {
										//03/02/24 - replaced:
										// Ok(value) => {
										//     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
										//         .ok_or_else(|| "Failed to get ask as string")
										//         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
								
										//     match gemini_buy_ask_result {
										//         Ok(ask) => {
										//             gemini_buy_ask = Some(ask);
										//             // Continue with your logic here using `ask`
										//             break; // Exit the loop if everything is successful
										//         },
										//         Err(e) => log::error!("{}", e),
										//     }
										// },
										// Err(_) => log::error!("Failed to parse JSON"),
										//03/02/24 - added in its place:
										Ok(value) => {
											match value["ask"].as_str() {
												Some(ask_str) => {
													match ask_str.parse::<f64>() {
														Ok(ask) => {
															gemini_buy_ask = Some(ask);
															// Continue with your logic here using `ask`
															break; // Exit the loop if everything is successful
														},
														Err(_) => log::error!("i153: gemini:  Failed to parse ask as f64"),
													}
												},
												None => log::error!("i153: gemini:  Failed to get ask as string"),
											}
										},
										Err(_) => log::error!("i153: gemini:  Failed to parse JSON"),
										}
									},
									Err(_) => log::error!("i153: gemini:  Failed to turn response into text"),
								}
							},
							Err(_) => log::error!("i153: gemini:  Failed to execute Gemini request"),
						}
					},
					Err(_) => log::error!("i153: gemini:  Couldn't build gemini request"),
				}
			
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}





	//02/07/24 - removed
		// let gemini_request = client.get(gemini_url)
		//         .header("Content-Type", gemini_content_type)
		//         .header("Content-Length", gemini_content_length)
		//         .header("X-GEMINI-APIKEY", gemini_api_key)
		//         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
		//         .header("X-GEMINI-SIGNATURE", &gemini_signature)
		//         .header("Cache-Control", gemini_cache_control)
		//         .build()
		//         .expect("couldn't build gemini request");


		// let gemini_response = client.execute(gemini_request).await
		//                         .expect("Failed to execute Gemini request");
		// let gemini_response_text = gemini_response.text().await
		//                         .expect("Failed to turn response into text");
		// let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
		//                         .expect("Failed to parse JSON");
		// let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
		// //CAN ONLY BUY. NOT SELL
		// let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
		// //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





		println!("xrp 3 gemini kraken simulated exchange delay: 8 sec...");
		let when = tokio::time::Instant::now() + Duration::from_secs(8);
		//02/09/24 - updated tokio. changed to sleep_until
		tokio::time::sleep_until(when).await;



		//---KRAKEN--//

		//basically Kraken requires a value that is always increasing to be in each request.
		//I didnt use now.timestamp().to_string()  because just in case I have 2 
		//	requests in a second I dont want to be penalized.
		//if no "now" in scope when moving file, 
		//	the code is this:
		////returns current time. MAY NEED TO USE LOCAL TIME
		let now = Utc::now();
		let nonce = now.timestamp_millis().to_string();
		let data = vec![
			("nonce", &nonce),
			// Add more parameters as needed
		];
		//let post_data: String = form_urlencoded::Serializer::new(String::new())
		//    .extend_pairs(data)
		//    .finish();
		
		let url_path = "/0/public/Ticker?pair=XRPUSD";
		//let message = format!("{}{}{}", url_path, nonce, post_data);

		fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
		-> String {
			// Create the post data
			let post_data: String = form_urlencoded::Serializer::new(String::new())
				.extend_pairs(data)
				.finish();
			//FOR DEBUGGING
			//println!("Private key:\n{}", secret);
			//println!("Nonce:\n{}", nonce_str);
			//println!("Encoded payload:\n{}", post_data);
			//println!("URI Path:\n{}", url_path);
		
			// Create the encoded string (nonce + post data) and hash it
			let encoded = format!("{}{}", nonce_str, post_data);
			let mut hasher = sha2::Sha256::new();
			hasher.update(encoded);
			let encoded_hash = hasher.finalize();
		
			// Create the message (url_path + encoded_hash as bytes)
			let mut message = url_path.as_bytes().to_vec();
			message.extend_from_slice(&encoded_hash);
		
			// Create a HMAC-SHA512 object with the base64-decoded secret
			let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
			let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
				.expect("HMAC can take key of any size");
		
			// Compute the HMAC of the message
			mac.update(&message);
			let result = mac.finalize();
		
			// Return the base64-encoded HMAC
			let signature = base64::encode(result.into_bytes());
			//println!("Kraken signature:\n{}", signature);
		
			signature
		}

		let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//kraken asked for 3 headers: key, sign, and content type with its corresponding info
		//.body is nonce because in the Kraken code provided in cURL: 
		//https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
		//--data-urlencode "nonce=<YOUR-NONCE>"
		//		this means that nonce is added to the body of the request



		//02/07/24 - removed
			// let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
			//         .header("API-Key", kraken_api_key)
			//         .header("API-Sign", &kraken_signature)
			//         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			//         .body(format!("nonce={}", nonce))
			//         .build()
			//         .expect("Failed to build kraken request");


			// let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

			// let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
			
			// //println!("kraken response:{}", kraken_response_text);

			// let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
			// let mut kraken_buy_price_ask = 0.0;
			// let mut kraken_sell_price_bid = 0.0;
			// if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
			//     // Access the ask and bid prices
			//     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
			//     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
			
			//     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
			//     //println!("xrp Bid price: {}", kraken_sell_price_bid );
			// }
			// else {
			//     println!("didnt parse kraken correctly.");
			// }
		//02/07/24 - replaced with:
			let mut kraken_sell_price_bid: Option<f64> = None;
			let mut kraken_buy_price_ask: Option<f64> = None;
			let mut value_after: Option<f64> = None;
			let mut attempts = 0;
			
			loop {
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
			
				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
													//03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	//Gemini calculations
																	let gemini_taker_fee = 0.004;
																	let fraction_of_wallet_im_using = 0.03; //aka 3 percent
																	let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																	let fee_for_purchase = total_spent*gemini_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*gemini_wallet -= total_spent;
																	
																	if let Some(gemini_buy_ask) = gemini_buy_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/09/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let gemini_wallet_unscaled = *gemini_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is bitstamp and gemini being updated, I will update:
																						//  56, 57, 60
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 59, 60];
																						let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;

																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*gemini_wallet = gemini_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is kraken and gemini being updated, I will update:
																					// //  56, 59, 60
																					// let indices = [56, 59, 60];
																					// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i153: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i153: gemini buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i153: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i153: Failed to get ask or bid as string"),
													}
												} 
												else {
													log::error!("i153: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i153: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i153: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i153: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i153: Failed to build kraken request. Error was: {}", e),
				}
			
				// Continue with your logic here...
				// Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
                //03/13/24 - removed:
				// if kraken_sell_price_bid.is_some() {
				// 	break; // Exit the loop if everything is successful
				// }
			
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}




		// //gemini calculations for buy 
		//     //this should equal 0.4%
		//     let gemini_taker_fee = 0.004;
		//     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

		//     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
		//     let fee_for_purchase = total_spent*gemini_taker_fee;
		//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
		//     //new state of gemini wallet below
		//     *gemini_wallet -= total_spent;
		//     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




		// //coinbase calculations for sell

		//     //let coinbase_taker_fee = 0.008;
		//     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
		//     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
		//     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
		//     //*coinbase_wallet += money_from_sell_after_fees;



		// //coinbase calculations for buy - not needed in this so code commented out
		
		//     //let coinbase_taker_fee = 0.008;

		//     //let total_spent = 0.10*(*coinbase_wallet);
		//     //let fee_for_purchase = total_spent*coinbase_taker_fee;
		//     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
		//     ////new state of coinbase wallet below
		//     //*coinbase_wallet -= total_spent;
		//     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

		// //kraken calculations - for sell
		//     let kraken_taker_fee = 0.0026;
			
		//     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
		//     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
		//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
		//     *kraken_wallet += money_from_sell_after_fees;

		//     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


		// //bitstamp calculations - for sell
		//     //let bitstamp_taker_fee = 0.004;
		//     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
		//     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
		//     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
		//     //*bitstamp_wallet += money_from_sell_after_fees;



		// //this will count as value after
		//     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
		//     //println!("value after:\n\t{}",value_after);


		//     //value_after = 56
		//     //coinbase = 57
		//     //bitstamp = 58
		//     //kraken = 59
		//     //gemini = 60
		//     //since this is kraken and gemini being updated, I will update:
		//     //  56, 59, 64
		//     let indices = [56, 59, 64];
		//     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
		//     //01/24/24 - removed and added:
		//         //neural_network.update_input(&indices, &new_values);
		//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
		//         //neural_network.update_input(&indices, &transformed_values).await;
		//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
		//         neural_network.update_input(&indices, &scaled_values).await;

		//     return Ok(value_after)
        //03/13/24 - removed:
		// match value_after {
		// 	Some(value) => return Ok(value),
		// 	None => {
				
		// 		panic!("Failed to get a valid value after {} attempts. 
		// 		Final values: kraken_sell_price_bid = {:?}
		// 		gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
		// 	}
		// }
	}

    pub async fn s_i154_xrp_4_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
											//03/02/24 - replaced:
											// Ok(value) => {
											//     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
											//         .ok_or_else(|| "Failed to get ask as string")
											//         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
									
											//     match gemini_buy_ask_result {
											//         Ok(ask) => {
											//             gemini_buy_ask = Some(ask);
											//             // Continue with your logic here using `ask`
											//             break; // Exit the loop if everything is successful
											//         },
											//         Err(e) => log::error!("{}", e),
											//     }
											// },
											// Err(_) => log::error!("Failed to parse JSON"),
											//03/02/24 - added in its place:
											Ok(value) => {
												match value["ask"].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask) => {
																gemini_buy_ask = Some(ask);
																// Continue with your logic here using `ask`
																break; // Exit the loop if everything is successful
															},
															Err(_) => log::error!("i154: gemini: Failed to parse ask as f64"),
														}
													},
													None => log::error!("i154: gemini:  Failed to get ask as string"),
												}
											},
											Err(_) => log::error!("i154: gemini:  Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("i154: gemini:  Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("i154: gemini:  Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("i154: gemini:  Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 4 gemini kraken simulated 8 sec delay...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    //03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	//Gemini calculations
																	let gemini_taker_fee = 0.004;
																	let fraction_of_wallet_im_using = 0.04; //aka 4 percent
																	let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																	let fee_for_purchase = total_spent*gemini_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*gemini_wallet -= total_spent;
																	
																	if let Some(gemini_buy_ask) = gemini_buy_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/09/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let gemini_wallet_unscaled = *gemini_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is bitstamp and gemini being updated, I will update:
																						//  56, 57, 60
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 59, 60];
																						let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;

																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*gemini_wallet = gemini_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is kraken and gemini being updated, I will update:
																					// //  56, 59, 60
																					// let indices = [56, 59, 60];
																					// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i154: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i154: gemini buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i154: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i154: Failed to get ask or bid as string"),
													}
                                                } 
                                                else {
                                                    log::error!("i154: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("i154: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("i154: Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("i154: Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("i154: Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
				//03/05/24 - removed the && ...
                //03/13/24 - removed:
                // if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
                //     break; // Exit the loop if everything is successful
                // }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is kraken and gemini being updated, I will update:
        //     //  56, 59, 64
        //     let indices = [56, 59, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        //03/13/24 - removed:
        // match value_after {
        //     Some(value) => return Ok(value),
        //     None => {
                
        //         panic!("Failed to get a valid value after {} attempts. 
        //         Final values: kraken_sell_price_bid = {:?}
        //         gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
        //     }
        // }
}

	pub async fn s_i155_xrp_5_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
											//03/02/24 - replaced:
											// Ok(value) => {
											//     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
											//         .ok_or_else(|| "Failed to get ask as string")
											//         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
									
											//     match gemini_buy_ask_result {
											//         Ok(ask) => {
											//             gemini_buy_ask = Some(ask);
											//             // Continue with your logic here using `ask`
											//             break; // Exit the loop if everything is successful
											//         },
											//         Err(e) => log::error!("{}", e),
											//     }
											// },
											// Err(_) => log::error!("Failed to parse JSON"),
											//03/02/24 - added in its place:
											Ok(value) => {
												match value["ask"].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask) => {
																gemini_buy_ask = Some(ask);
																// Continue with your logic here using `ask`
																break; // Exit the loop if everything is successful
															},
															Err(_) => log::error!("i155: gemini:  Failed to parse ask as f64"),
														}
													},
													None => log::error!("i155: gemini:  Failed to get ask as string"),
												}
											},
											Err(_) => log::error!("i155: gemini:  Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("i155: gemini:  Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("i155: gemini:  Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("i155: gemini:  Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 5 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    //03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	//Gemini calculations
																	let gemini_taker_fee = 0.004;
																	let fraction_of_wallet_im_using = 0.05; //aka 5 percent
																	let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																	let fee_for_purchase = total_spent*gemini_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*gemini_wallet -= total_spent;
																	
																	if let Some(gemini_buy_ask) = gemini_buy_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/09/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let gemini_wallet_unscaled = *gemini_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is bitstamp and gemini being updated, I will update:
																						//  56, 57, 60
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 59, 60];
																						let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;

																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*gemini_wallet = gemini_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is kraken and gemini being updated, I will update:
																					// //  56, 59, 60
																					// let indices = [56, 59, 60];
																					// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i155: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i155: gemini buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i155: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i155: Failed to get ask or bid as string"),
													}
                                                } 
                                                else {
                                                    log::error!("i155: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("i155: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("i155: Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("i155: Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("i155: Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
				//03/05/24 - removed the && ...
                //03/13/24 - removed:
                // if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
                //     break; // Exit the loop if everything is successful
                // }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is kraken and gemini being updated, I will update:
        //     //  56, 59, 64
        //     let indices = [56, 59, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        //03/13/24 - removed:
        // match value_after {
        //     Some(value) => return Ok(value),
        //     None => {
                
        //         panic!("Failed to get a valid value after {} attempts. 
        //         Final values: kraken_sell_price_bid = {:?}
        //         gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
        //     }
        // }
    }

    pub async fn s_i156_xrp_6_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {
                                        match serde_json::from_str::<Value>(&text) {
											//03/02/24 - replaced:
											// Ok(value) => {
											//     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
											//         .ok_or_else(|| "Failed to get ask as string")
											//         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
									
											//     match gemini_buy_ask_result {
											//         Ok(ask) => {
											//             gemini_buy_ask = Some(ask);
											//             // Continue with your logic here using `ask`
											//             break; // Exit the loop if everything is successful
											//         },
											//         Err(e) => log::error!("{}", e),
											//     }
											// },
											// Err(_) => log::error!("Failed to parse JSON"),
											//03/02/24 - added in its place:
											Ok(value) => {
												match value["ask"].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask) => {
																gemini_buy_ask = Some(ask);
																// Continue with your logic here using `ask`
																break; // Exit the loop if everything is successful
															},
															Err(_) => log::error!("i156: gemini:  Failed to parse ask as f64"),
														}
													},
													None => log::error!("i156: gemini:  Failed to get ask as string"),
												}
											},
											Err(_) => log::error!("i156: gemini:  Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("i156: gemini:  Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("i156: gemini:  Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("i156: gemini:  Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 6 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    //03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	//Gemini calculations
																	let gemini_taker_fee = 0.004;
																	let fraction_of_wallet_im_using = 0.06; //aka 6 percent
																	let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																	let fee_for_purchase = total_spent*gemini_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*gemini_wallet -= total_spent;
																	
																	if let Some(gemini_buy_ask) = gemini_buy_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/09/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let gemini_wallet_unscaled = *gemini_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is bitstamp and gemini being updated, I will update:
																						//  56, 57, 60
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 59, 60];
																						let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;

																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*gemini_wallet = gemini_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is kraken and gemini being updated, I will update:
																					// //  56, 59, 60
																					// let indices = [56, 59, 60];
																					// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i156: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i156: gemini buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i156: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i156: Failed to get ask or bid as string"),
													}
                                                } 
                                                else {
                                                    log::error!("i156: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("i156: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("i156: Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("i156: Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("i156: Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
				//03/05/24 - removed the && ...
                if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is kraken and gemini being updated, I will update:
        //     //  56, 59, 64
        //     let indices = [56, 59, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
    }

    pub async fn s_i157_xrp_7_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
											//03/02/24 - replaced:
											// Ok(value) => {
											//     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
											//         .ok_or_else(|| "Failed to get ask as string")
											//         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
									
											//     match gemini_buy_ask_result {
											//         Ok(ask) => {
											//             gemini_buy_ask = Some(ask);
											//             // Continue with your logic here using `ask`
											//             break; // Exit the loop if everything is successful
											//         },
											//         Err(e) => log::error!("{}", e),
											//     }
											// },
											// Err(_) => log::error!("Failed to parse JSON"),
											//03/02/24 - added in its place:
											Ok(value) => {
												match value["ask"].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask) => {
																gemini_buy_ask = Some(ask);
																// Continue with your logic here using `ask`
																break; // Exit the loop if everything is successful
															},
															Err(_) => log::error!("i157: gemini:  Failed to parse ask as f64"),
														}
													},
													None => log::error!("i157: gemini:  Failed to get ask as string"),
												}
											},
											Err(_) => log::error!("i157:gemini:   Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("i157:gemini:   Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("i157:gemini:   Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("i157:gemini:   Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 7 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    //03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	//Gemini calculations
																	let gemini_taker_fee = 0.004;
																	let fraction_of_wallet_im_using = 0.07; //aka 7 percent
																	let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																	let fee_for_purchase = total_spent*gemini_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*gemini_wallet -= total_spent;
																	
																	if let Some(gemini_buy_ask) = gemini_buy_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/09/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let gemini_wallet_unscaled = *gemini_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is bitstamp and gemini being updated, I will update:
																						//  56, 57, 60
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 59, 60];
																						let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;

																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*gemini_wallet = gemini_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is kraken and gemini being updated, I will update:
																					// //  56, 59, 60
																					// let indices = [56, 59, 60];
																					// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i157: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i157: gemini buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i157: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i157: Failed to get ask or bid as string"),
													}
                                                } 
                                                else {
                                                    log::error!("i157: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("i157: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("i157: Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("i157: Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("i157: Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
				//03/05/24 - removed the && ...
                if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is kraken and gemini being updated, I will update:
        //     //  56, 59, 64
        //     let indices = [56, 59, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
    }

    pub async fn s_i158_xrp_8_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
											//03/02/24 - replaced:
											// Ok(value) => {
											//     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
											//         .ok_or_else(|| "Failed to get ask as string")
											//         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
									
											//     match gemini_buy_ask_result {
											//         Ok(ask) => {
											//             gemini_buy_ask = Some(ask);
											//             // Continue with your logic here using `ask`
											//             break; // Exit the loop if everything is successful
											//         },
											//         Err(e) => log::error!("{}", e),
											//     }
											// },
											// Err(_) => log::error!("Failed to parse JSON"),
											//03/02/24 - added in its place:
											Ok(value) => {
												match value["ask"].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask) => {
																gemini_buy_ask = Some(ask);
																// Continue with your logic here using `ask`
																break; // Exit the loop if everything is successful
															},
															Err(_) => log::error!("i158:gemini:   Failed to parse ask as f64"),
														}
													},
													None => log::error!("i158:gemini:   Failed to get ask as string"),
												}
											},
											Err(_) => log::error!("i158:gemini:   Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("i158:gemini:   Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("i158:gemini:   Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("i158:gemini:   Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 8 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    //03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	//Gemini calculations
																	let gemini_taker_fee = 0.004;
																	let fraction_of_wallet_im_using = 0.08; //aka 8 percent
																	let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																	let fee_for_purchase = total_spent*gemini_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*gemini_wallet -= total_spent;
																	
																	if let Some(gemini_buy_ask) = gemini_buy_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/09/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let gemini_wallet_unscaled = *gemini_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is bitstamp and gemini being updated, I will update:
																						//  56, 57, 60
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 59, 60];
																						let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;

																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*gemini_wallet = gemini_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is kraken and gemini being updated, I will update:
																					// //  56, 59, 60
																					// let indices = [56, 59, 60];
																					// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i158: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i158: gemini buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i158: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i158: Failed to get ask or bid as string"),
													}
                                                } 
                                                else {
                                                    log::error!("i158: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("i158: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("i158: Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("i158: Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("i158: Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
				//03/05/24 - removed the && ...
                if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is kraken and gemini being updated, I will update:
        //     //  56, 59, 64
        //     let indices = [56, 59, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
    }

    pub async fn s_i159_xrp_9_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
											//03/02/24 - replaced:
											// Ok(value) => {
											//     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
											//         .ok_or_else(|| "Failed to get ask as string")
											//         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
									
											//     match gemini_buy_ask_result {
											//         Ok(ask) => {
											//             gemini_buy_ask = Some(ask);
											//             // Continue with your logic here using `ask`
											//             break; // Exit the loop if everything is successful
											//         },
											//         Err(e) => log::error!("{}", e),
											//     }
											// },
											// Err(_) => log::error!("Failed to parse JSON"),
											//03/02/24 - added in its place:
											Ok(value) => {
												match value["ask"].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask) => {
																gemini_buy_ask = Some(ask);
																// Continue with your logic here using `ask`
																break; // Exit the loop if everything is successful
															},
															Err(_) => log::error!("i159: gemini:  Failed to parse ask as f64"),
														}
													},
													None => log::error!("i159: gemini:  Failed to get ask as string"),
												}
											},
											Err(_) => log::error!("i159: gemini:  Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("i159:gemini:   Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("i159:gemini:   Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("i159:gemini:   Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 9 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    //03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	//Gemini calculations
																	let gemini_taker_fee = 0.004;
																	let fraction_of_wallet_im_using = 0.09; //aka 9 percent
																	let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																	let fee_for_purchase = total_spent*gemini_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*gemini_wallet -= total_spent;
																	
																	if let Some(gemini_buy_ask) = gemini_buy_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/09/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let gemini_wallet_unscaled = *gemini_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is bitstamp and gemini being updated, I will update:
																						//  56, 57, 60
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 59, 60];
																						let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;

																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*gemini_wallet = gemini_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is kraken and gemini being updated, I will update:
																					// //  56, 59, 60
																					// let indices = [56, 59, 60];
																					// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i153: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i153: gemini buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i153: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i153: Failed to get ask or bid as string"),
													}
                                                } 
                                                else {
                                                    log::error!("i159: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("i159: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("i159: Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("i159: Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("i159: Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
            
				//03/05/24 - removed the && ...
                if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }




        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is kraken and gemini being updated, I will update:
        //     //  56, 59, 64
        //     let indices = [56, 59, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)
        match value_after {
            Some(value) => return Ok(value),
            None => {
                
                panic!("Failed to get a valid value after {} attempts. 
                Final values: kraken_sell_price_bid = {:?}
                gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
            }
        }
}

	pub async fn s_i160_xrp_10_gemini_kraken( coinbase_wallet: &f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &mut f64, kraken_secret: &str, kraken_api_key: &str, client: reqwest::Client, gemini_secret: &str, gemini_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

        fn sign_gemini(gemini_secret: &str, gemini_payload: &serde_json::Value) -> String {
            let encoded_payload = encode(gemini_payload.to_string());
            let mut mac = Hmac::<Sha384>::new_from_slice(&gemini_secret.as_bytes())
                            .expect("HMAC can take key of any size");
            mac.update(encoded_payload.as_bytes());
            let result = mac.finalize();
            let code_bytes = result.into_bytes();
            let gemini_signature = hex::encode(code_bytes);
            println!("Gemini signature:\n{}", &gemini_signature);
            gemini_signature
    
        }
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time.
        //		let now = Utc::now();
        let now = Utc::now();
        let gemini_time_stamp = now.timestamp().to_string();
        let gemini_nonce = gemini_time_stamp;
        let gemini_url = "https://api.gemini.com/v1/pubticker/xrpusd";
        let gemini_payload = json!({
            "request": "/v1/mytrades",
            "nonce": &gemini_nonce
        });
        let base64_encoded_payload = encode(gemini_payload.to_string());
        let gemini_content_type = "text/plain";
        let gemini_content_length = "0";
        let gemini_cache_control = "no-cache";
        let gemini_signature = sign_gemini(&gemini_secret, &gemini_payload);

        //02/07/24 - added:
            let mut attempts = 0;
            let gemini_buy_ask: Option<f64>;
            loop {
                let gemini_request = client.get(gemini_url)
                    .header("Content-Type", gemini_content_type)
                    .header("Content-Length", gemini_content_length)
                    .header("X-GEMINI-APIKEY", gemini_api_key)
                    .header("X-GEMINI-PAYLOAD", &base64_encoded_payload)
                    .header("X-GEMINI-SIGNATURE", &gemini_signature)
                    .header("Cache-Control", gemini_cache_control)
                    .build();
            
                match gemini_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                let gemini_response_text = response.text().await;
                                match gemini_response_text {
                                    Ok(text) => {

                                        match serde_json::from_str::<Value>(&text) {
											//03/02/24 - replaced:
											// Ok(value) => {
											//     let gemini_buy_ask_result: Result<f64, _> = value["ask"].as_str()
											//         .ok_or_else(|| "Failed to get ask as string")
											//         .and_then(|ask_str| ask_str.parse().map_err(|_| "Failed to parse ask as f64"));
									
											//     match gemini_buy_ask_result {
											//         Ok(ask) => {
											//             gemini_buy_ask = Some(ask);
											//             // Continue with your logic here using `ask`
											//             break; // Exit the loop if everything is successful
											//         },
											//         Err(e) => log::error!("{}", e),
											//     }
											// },
											// Err(_) => log::error!("Failed to parse JSON"),
											//03/02/24 - added in its place:
											Ok(value) => {
												match value["ask"].as_str() {
													Some(ask_str) => {
														match ask_str.parse::<f64>() {
															Ok(ask) => {
																gemini_buy_ask = Some(ask);
																// Continue with your logic here using `ask`
																break; // Exit the loop if everything is successful
															},
															Err(_) => log::error!("i156: gemini:  Failed to parse ask as f64"),
														}
													},
													None => log::error!("i156: gemini:   Failed to get ask as string"),
												}
											},
											Err(_) => log::error!("i156: gemini:   Failed to parse JSON"),
                                        }
                                    },
                                    Err(_) => log::error!("i156: gemini:   Failed to turn response into text"),
                                }
                            },
                            Err(_) => log::error!("i156: gemini:  Failed to execute Gemini request"),
                        }
                    },
                    Err(_) => log::error!("i156: gemini:  Couldn't build gemini request"),
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }





    //02/07/24 - removed
        // let gemini_request = client.get(gemini_url)
        //         .header("Content-Type", gemini_content_type)
        //         .header("Content-Length", gemini_content_length)
        //         .header("X-GEMINI-APIKEY", gemini_api_key)
        //         .header("X-GEMINI-PAYLOAD", base64_encoded_payload)
        //         .header("X-GEMINI-SIGNATURE", &gemini_signature)
        //         .header("Cache-Control", gemini_cache_control)
        //         .build()
        //         .expect("couldn't build gemini request");
    
    
        // let gemini_response = client.execute(gemini_request).await
        //                         .expect("Failed to execute Gemini request");
        // let gemini_response_text = gemini_response.text().await
        //                         .expect("Failed to turn response into text");
        // let v: serde_json::Value = serde_json::from_str(&gemini_response_text)
        //                         .expect("Failed to parse JSON");
        // let gemini_sell_pricebid: f64 = v["bid"].as_str().unwrap().parse().unwrap();
        // //CAN ONLY BUY. NOT SELL
        // let gemini_buy_ask: f64 = v["ask"].as_str().unwrap().parse().unwrap();
        // //println!("gemini xrp: Bid: {}, Ask: {}", gemini_sell_pricebid, gemini_buy_ask);





        println!("xrp 10 gemini kraken simulated exchange delay: 8 sec...");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;



        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

        //kraken asked for 3 headers: key, sign, and content type with its corresponding info
        //.body is nonce because in the Kraken code provided in cURL: 
        //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
        //--data-urlencode "nonce=<YOUR-NONCE>"
        //		this means that nonce is added to the body of the request



        //02/07/24 - removed
            // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            //         .header("API-Key", kraken_api_key)
            //         .header("API-Sign", &kraken_signature)
            //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            //         .body(format!("nonce={}", nonce))
            //         .build()
            //         .expect("Failed to build kraken request");


            // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

            // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
            
            // //println!("kraken response:{}", kraken_response_text);

            // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
            // let mut kraken_buy_price_ask = 0.0;
            // let mut kraken_sell_price_bid = 0.0;
            // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
            //     // Access the ask and bid prices
            //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
            //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
            
            //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
            //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
            // }
            // else {
            //     println!("didnt parse kraken correctly.");
            // }
        //02/07/24 - replaced with:
            let mut kraken_sell_price_bid: Option<f64> = None;
            let mut kraken_buy_price_ask: Option<f64> = None;
            let mut value_after: Option<f64> = None;
            let mut attempts = 0;
            
            loop {
                let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
                    .header("API-Key", kraken_api_key)
                    .header("API-Sign", &kraken_signature)
                    .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
                    .body(format!("nonce={}", nonce))
                    .build();
            
                match kraken_basic_request {
                    Ok(request) => {
                        match client.execute(request).await {
                            Ok(response) => {
                                match response.text().await {
                                    Ok(kraken_response_text) => {
                                        match serde_json::from_str::<Value>(&kraken_response_text) {
                                            Ok(value) => {
                                                if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
                                                    //03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	//Gemini calculations
																	let gemini_taker_fee = 0.004;
																	let fraction_of_wallet_im_using = 0.10; //aka 10 percent
																	let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
																	let fee_for_purchase = total_spent*gemini_taker_fee;
																	let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*gemini_wallet -= total_spent;
																	
																	if let Some(gemini_buy_ask) = gemini_buy_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_sol = money_going_to_sol_after_fees/gemini_buy_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_sol * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/09/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let gemini_wallet_unscaled = *gemini_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						*gemini_wallet = standardization_functions::normal_wallet_standardization(&gemini_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is bitstamp and gemini being updated, I will update:
																						//  56, 57, 60
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 59, 60];
																						let scaled_values = [value_after, *kraken_wallet, *gemini_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;

																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*gemini_wallet = gemini_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is kraken and gemini being updated, I will update:
																					// //  56, 59, 60
																					// let indices = [56, 59, 60];
																					// let new_values = [value_after, Some(*kraken_wallet), Some(*gemini_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i156: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i156: gemini buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i156: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i156: Failed to get ask or bid as string"),
													}
                                                } 
                                                else {
                                                    log::error!("i156: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
                                                }
                                            },
                                            Err(e) => log::error!("i156: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
                                        }
                                    },
                                    Err(e) => log::error!("i156: Failed to read response text. Error was: {}", e),
                                }
                            },
                            Err(e) => log::error!("i156: Failed to execute Kraken request. Error was: {}", e),
                        }
                    },
                    Err(e) => log::error!("i156: Failed to build kraken request. Error was: {}", e),
                }
            
                // Continue with your logic here...
                // Remember to handle the case when kraken_sell_price_bid and kraken_buy_price_ask are None
				//03/05/24 - removed the && ...
                if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
                    break; // Exit the loop if everything is successful
                }
            
                attempts += 1;
                if attempts >= 3 {
                    panic!("Failed after 3 attempts");
                }
            }

			match value_after {
				Some(value) => return Ok(value),
				None => {
					
					panic!("Failed to get a valid value after {} attempts. 
					Final values: kraken_sell_price_bid = {:?}
					gemini_buy_ask = {:?}", attempts, &kraken_sell_price_bid, &gemini_buy_ask);
				}
			}



        // //gemini calculations for buy 
        //     //this should equal 0.4%
        //     let gemini_taker_fee = 0.004;
        //     let fraction_of_wallet_im_using = 0.04; //aka 4 percent

        //     let total_spent = fraction_of_wallet_im_using*(*gemini_wallet);
        //     let fee_for_purchase = total_spent*gemini_taker_fee;
        //     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        //     //new state of gemini wallet below
        //     *gemini_wallet -= total_spent;
        //     let amount_of_xrp = money_going_to_xrp_after_fees/gemini_buy_ask;




        // //coinbase calculations for sell

        //     //let coinbase_taker_fee = 0.008;
        //     //let money_from_sell_before_fees = amount_of_sol * coinbase_sell_price;
        //     //let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*coinbase_wallet += money_from_sell_after_fees;



        // //coinbase calculations for buy - not needed in this so code commented out
        
        //     //let coinbase_taker_fee = 0.008;

        //     //let total_spent = 0.10*(*coinbase_wallet);
        //     //let fee_for_purchase = total_spent*coinbase_taker_fee;
        //     //let money_going_to_sol_after_fees = total_spent - fee_for_purchase;
        //     ////new state of coinbase wallet below
        //     //*coinbase_wallet -= total_spent;
        //     //let amount_of_sol = money_going_to_sol_after_fees/coinbase_buy_price;

        // //kraken calculations - for sell
        //     let kraken_taker_fee = 0.0026;
            
        //     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
        //     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
        //     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
        //     *kraken_wallet += money_from_sell_after_fees;

        //     //let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + *bitstamp_wallet;


        // //bitstamp calculations - for sell
        //     //let bitstamp_taker_fee = 0.004;
        //     //let money_from_sell_before_fees = amount_of_sol * bitstamp_sell_price_bid;
        //     //let fee_for_sell = money_from_sell_before_fees * bitstamp_taker_fee;
        //     //let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        //     //*bitstamp_wallet += money_from_sell_after_fees;



        // //this will count as value after
        //     let value_after = *kraken_wallet + coinbase_wallet + *gemini_wallet + bitstamp_wallet;
        //     //println!("value after:\n\t{}",value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is kraken and gemini being updated, I will update:
        //     //  56, 59, 64
        //     let indices = [56, 59, 64];
        //     let new_values = [value_after, *kraken_wallet, *gemini_wallet];
        //     //01/24/24 - removed and added:
        //         //neural_network.update_input(&indices, &new_values);
        //         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //         //neural_network.update_input(&indices, &transformed_values).await;
        //         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //         neural_network.update_input(&indices, &scaled_values).await;

        //     return Ok(value_after)

    }
//coinbase kraken   = 3 AND UP FOR min of 10 USD for coinbase. min buy of 10 XRP for kraken so maximal min is 6 dollars.
    pub async fn s_i163_xrp_3_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		//03/05/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, 
        // &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);

        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);


	//03/05/24 added - 
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													//let product_id = pricebook["product_id"].as_str();
													//let bids = &pricebook["bids"][0];
													let asks = &pricebook["asks"][0];
													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
														(/*Some(bid_str),*/ Some(ask_str)) => {
															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
																(/*Ok(bid_str),*/ Ok(ask_str)) => {
																	//coinbase_sell_price_bid = Some(bid_str);
																	coinbase_buy_price_ask = Some(ask_str);
																	
																		success = true;
																},
																_ => {
																	log::error!("i159: coinbase: Failed to parse json into f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i159: coinbase: Failed to get bid price ");
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
															}
															continue ;
														}
													}
												}
											//03/02/24 - added else condition
											} else {
												log::error!("i159: coinbase: Failed to get pricebooks as array.");
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
												}
												continue;
											}
										},
										Err(_) => {
											log::error!("i159: coinbase: Failed to parse JSON to str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i159: coinbase: Failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i159: coinbase: Failed to execute request.");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i159: coinbase: Failed to build request");
					if attempts > 3 {
						panic!("Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}






        println!("xrp 3 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
			// //kraken asked for 3 headers: key, sign, and content type with its corresponding info
			// //.body is nonce because in the Kraken code provided in cURL: 
			// //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
			// //--data-urlencode "nonce=<YOUR-NONCE>"
			// //		this means that nonce is added to the body of the request
			// let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
			//         .header("API-Key", kraken_api_key)
			//         .header("API-Sign", &kraken_signature)
			//         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			//         .body(format!("nonce={}", nonce))
			//         .build()
			//         .expect("Failed to build kraken request");


			// let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

			// let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
			
			// //println!("kraken response:{}", kraken_response_text);

			// let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
			// let mut kraken_buy_price_ask = 0.0;
			// let mut kraken_sell_price_bid = 0.0;
			// if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
			//     // Access the ask and bid prices
			//     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
			//     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
			
			//     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
			//     //println!("xrp Bid price: {}", kraken_sell_price_bid );
			// }
			// else {
			//     println!("didnt parse kraken correctly.");
			// }











        //02/07/24 - replaced with:
			let mut kraken_sell_price_bid: Option<f64> = None;
			let mut kraken_buy_price_ask: Option<f64> = None;
			let mut value_after: Option<f64> = None;
			let mut attempts = 0;
			
			loop {
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
			
				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
													//03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// Continue with your logic here...

																	//Coinbase calculations
																	let coinbase_taker_fee = 0.008;
																	let fraction_of_wallet_im_using = 0.03; //aka 3 percent
																	let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																	let fee_for_purchase = total_spent*coinbase_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*coinbase_wallet -= total_spent;
																	
																	if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/10/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let coinbase_wallet_unscaled = *coinbase_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
	
																						*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is coinbase and kraken being updated, I will update:
																						//  56, 57, 59
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 57, 59];
																						let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;
	
																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*coinbase_wallet = coinbase_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is coinbase and kraken being updated, I will update:
																					// //  56, 57, 59
																					// let indices = [56, 57, 59];
																					// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i159: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i159: coinbase buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i159: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i159: Failed to get ask or bid as string"),
													}
												} 
												else {
													log::error!("i159: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i159: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i159: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i159: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i159: Failed to build kraken request. Error was: {}", e),
				}
				//03/05/24 - removed the &&buy_price_ask.is_some()
				if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
					break; // Exit the loop if everything is successful
				}
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			match value_after {
				Some(value) => return Ok(value),
				None => {
					
					panic!("Failed to get a valid value after {} attempts. 
					Final values: kraken_sell_price_bid = {:?}
					coinbase_buy_price_ask = {:?}", attempts, &kraken_sell_price_bid, &coinbase_buy_price_ask);
				}
			}

















		//03/05/24 - removed:
			//     let coinbase_taker_fee = 0.008;
			//     let fraction_of_wallet_used = 0.03;
			//     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
			//     let fee_for_purchase = total_spent*coinbase_taker_fee;
			//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
			//     //new state of coinbase wallet below
			//     *coinbase_wallet -= total_spent;
			//     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

			// //kraken calculations
			//     let kraken_taker_fee = 0.0026;
				
			//     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
			//     *kraken_wallet += money_from_sell_after_fees;

			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


			// //this will count as value after

			//         //value_after = 56
			//     //coinbase = 57
			//     //bitstamp = 58
			//     //kraken = 59
			//     //gemini = 60
			//     //since this is coinbase and kraken being updated, I will update:
			//     //  56, 57, 59
			//     let indices = [56, 57, 59];
			//     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;

			//     return Ok(value_after)

	}

	pub async fn s_i164_xrp_4_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		//03/05/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, 
        // &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);

        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);


	//03/05/24 added - 
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													//let product_id = pricebook["product_id"].as_str();
													//let bids = &pricebook["bids"][0];
													let asks = &pricebook["asks"][0];
													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
														(/*Some(bid_str),*/ Some(ask_str)) => {
															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
																(/*Ok(bid_str),*/ Ok(ask_str)) => {
																	//coinbase_sell_price_bid = Some(bid_str);
																	coinbase_buy_price_ask = Some(ask_str);
																	
																		success = true;
																},
																_ => {
																	log::error!("i164: coinbase: Failed to parse json into f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i164: coinbase: Failed to get bid price ");
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
															}
															continue ;
														}
													}
												}
											//03/02/24 - added else condition
											} else {
												log::error!("i164: coinbase: Failed to get pricebooks as array.");
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
												}
												continue;
											}
										},
										Err(_) => {
											log::error!("i164: coinbase: Failed to parse JSON to str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i164: coinbase: Failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i164: coinbase: Failed to execute request.");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i164: coinbase: Failed to build request");
					if attempts > 3 {
						panic!("Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}






        println!("xrp 4 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
			// //kraken asked for 3 headers: key, sign, and content type with its corresponding info
			// //.body is nonce because in the Kraken code provided in cURL: 
			// //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
			// //--data-urlencode "nonce=<YOUR-NONCE>"
			// //		this means that nonce is added to the body of the request
			// let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
			//         .header("API-Key", kraken_api_key)
			//         .header("API-Sign", &kraken_signature)
			//         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			//         .body(format!("nonce={}", nonce))
			//         .build()
			//         .expect("Failed to build kraken request");


			// let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

			// let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
			
			// //println!("kraken response:{}", kraken_response_text);

			// let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
			// let mut kraken_buy_price_ask = 0.0;
			// let mut kraken_sell_price_bid = 0.0;
			// if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
			//     // Access the ask and bid prices
			//     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
			//     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
			
			//     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
			//     //println!("xrp Bid price: {}", kraken_sell_price_bid );
			// }
			// else {
			//     println!("didnt parse kraken correctly.");
			// }











        //02/07/24 - replaced with:
			let mut kraken_sell_price_bid: Option<f64> = None;
			let mut kraken_buy_price_ask: Option<f64> = None;
			let mut value_after: Option<f64> = None;
			let mut attempts = 0;
			
			loop {
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
			
				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
													//03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	// let coinbase_taker_fee = 0.008;
																	// let fraction_of_wallet_used = 0.03;
																	// let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
																	// let fee_for_purchase = total_spent*coinbase_taker_fee;
																	// let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	// //new state of coinbase wallet below
																	// *coinbase_wallet -= total_spent;
																	// let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;



																	//Coinbase calculations
																	let coinbase_taker_fee = 0.008;
																	let fraction_of_wallet_im_using = 0.04; //aka 4 percent
																	let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																	let fee_for_purchase = total_spent*coinbase_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*coinbase_wallet -= total_spent;
																	
																	if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/10/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let coinbase_wallet_unscaled = *coinbase_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
	
																						*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is coinbase and kraken being updated, I will update:
																						//  56, 57, 59
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 57, 59];
																						let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;
	
																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*coinbase_wallet = coinbase_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is coinbase and kraken being updated, I will update:
																					// //  56, 57, 59
																					// let indices = [56, 57, 59];
																					// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i164: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i164: coinbase buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i164: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i164: Failed to get ask or bid as string"),
													}
												} 
												else {
													log::error!("i164: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i164: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i164: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i164: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i164: Failed to build kraken request. Error was: {}", e),
				}
				//03/05/24 - removed the &&buy_price_ask.is_some()
				if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
					break; // Exit the loop if everything is successful
				}
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			match value_after {
				Some(value) => return Ok(value),
				None => {
					
					panic!("Failed to get a valid value after {} attempts. 
					Final values: kraken_sell_price_bid = {:?}
					coinbase_buy_price_ask = {:?}", attempts, &kraken_sell_price_bid, &coinbase_buy_price_ask);
				}
			}

















		//03/05/24 - removed:
			//     let coinbase_taker_fee = 0.008;
			//     let fraction_of_wallet_used = 0.03;
			//     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
			//     let fee_for_purchase = total_spent*coinbase_taker_fee;
			//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
			//     //new state of coinbase wallet below
			//     *coinbase_wallet -= total_spent;
			//     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

			// //kraken calculations
			//     let kraken_taker_fee = 0.0026;
				
			//     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
			//     *kraken_wallet += money_from_sell_after_fees;

			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


			// //this will count as value after

			//         //value_after = 56
			//     //coinbase = 57
			//     //bitstamp = 58
			//     //kraken = 59
			//     //gemini = 60
			//     //since this is coinbase and kraken being updated, I will update:
			//     //  56, 57, 59
			//     let indices = [56, 57, 59];
			//     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;

			//     return Ok(value_after)

	}

    pub async fn s_i165_xrp_5_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		//03/05/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, 
        // &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);

        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);


	//03/05/24 added - 
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													//let product_id = pricebook["product_id"].as_str();
													//let bids = &pricebook["bids"][0];
													let asks = &pricebook["asks"][0];
													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
														(/*Some(bid_str),*/ Some(ask_str)) => {
															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
																(/*Ok(bid_str),*/ Ok(ask_str)) => {
																	//coinbase_sell_price_bid = Some(bid_str);
																	coinbase_buy_price_ask = Some(ask_str);
																	
																		success = true;
																},
																_ => {
																	log::error!("i165: coinbase: Failed to parse json into f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i165: coinbase: Failed to get bid price ");
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
															}
															continue ;
														}
													}
												}
											//03/02/24 - added else condition
											} else {
												log::error!("i165: coinbase: Failed to get pricebooks as array.");
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
												}
												continue;
											}
										},
										Err(_) => {
											log::error!("i165: coinbase: Failed to parse JSON to str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i165: coinbase: Failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i165: coinbase: Failed to execute request.");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i165: coinbase: Failed to build request");
					if attempts > 3 {
						panic!("Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}






        println!("xrp 5 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
			// //kraken asked for 3 headers: key, sign, and content type with its corresponding info
			// //.body is nonce because in the Kraken code provided in cURL: 
			// //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
			// //--data-urlencode "nonce=<YOUR-NONCE>"
			// //		this means that nonce is added to the body of the request
			// let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
			//         .header("API-Key", kraken_api_key)
			//         .header("API-Sign", &kraken_signature)
			//         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			//         .body(format!("nonce={}", nonce))
			//         .build()
			//         .expect("Failed to build kraken request");


			// let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

			// let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
			
			// //println!("kraken response:{}", kraken_response_text);

			// let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
			// let mut kraken_buy_price_ask = 0.0;
			// let mut kraken_sell_price_bid = 0.0;
			// if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
			//     // Access the ask and bid prices
			//     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
			//     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
			
			//     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
			//     //println!("xrp Bid price: {}", kraken_sell_price_bid );
			// }
			// else {
			//     println!("didnt parse kraken correctly.");
			// }











        //02/07/24 - replaced with:
			let mut kraken_sell_price_bid: Option<f64> = None;
			let mut kraken_buy_price_ask: Option<f64> = None;
			let mut value_after: Option<f64> = None;
			let mut attempts = 0;
			
			loop {
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
			
				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
													//03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	// let coinbase_taker_fee = 0.008;
																	// let fraction_of_wallet_used = 0.03;
																	// let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
																	// let fee_for_purchase = total_spent*coinbase_taker_fee;
																	// let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	// //new state of coinbase wallet below
																	// *coinbase_wallet -= total_spent;
																	// let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;



																	//Coinbase calculations
																	let coinbase_taker_fee = 0.008;
																	let fraction_of_wallet_im_using = 0.05; //aka 5 percent
																	let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																	let fee_for_purchase = total_spent*coinbase_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*coinbase_wallet -= total_spent;
																	
																	if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/10/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let coinbase_wallet_unscaled = *coinbase_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
	
																						*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is coinbase and kraken being updated, I will update:
																						//  56, 57, 59
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 57, 59];
																						let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;
	
																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*coinbase_wallet = coinbase_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is coinbase and kraken being updated, I will update:
																					// //  56, 57, 59
																					// let indices = [56, 57, 59];
																					// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i165: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i165: coinbase buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i165: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i165: Failed to get ask or bid as string"),
													}
												} 
												else {
													log::error!("i165: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i165: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i165: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i165: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i165: Failed to build kraken request. Error was: {}", e),
				}
				//03/05/24 - removed the &&buy_price_ask.is_some()
				if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
					break; // Exit the loop if everything is successful
				}
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			match value_after {
				Some(value) => return Ok(value),
				None => {
					
					panic!("Failed to get a valid value after {} attempts. 
					Final values: kraken_sell_price_bid = {:?}
					coinbase_buy_price_ask = {:?}", attempts, &kraken_sell_price_bid, &coinbase_buy_price_ask);
				}
			}

















		//03/05/24 - removed:
			//     let coinbase_taker_fee = 0.008;
			//     let fraction_of_wallet_used = 0.03;
			//     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
			//     let fee_for_purchase = total_spent*coinbase_taker_fee;
			//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
			//     //new state of coinbase wallet below
			//     *coinbase_wallet -= total_spent;
			//     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

			// //kraken calculations
			//     let kraken_taker_fee = 0.0026;
				
			//     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
			//     *kraken_wallet += money_from_sell_after_fees;

			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


			// //this will count as value after

			//         //value_after = 56
			//     //coinbase = 57
			//     //bitstamp = 58
			//     //kraken = 59
			//     //gemini = 60
			//     //since this is coinbase and kraken being updated, I will update:
			//     //  56, 57, 59
			//     let indices = [56, 57, 59];
			//     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;

			//     return Ok(value_after)

	}

    pub async fn s_i166_xrp_6_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		//03/05/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, 
        // &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);

        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);


	//03/05/24 added - 
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													//let product_id = pricebook["product_id"].as_str();
													//let bids = &pricebook["bids"][0];
													let asks = &pricebook["asks"][0];
													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
														(/*Some(bid_str),*/ Some(ask_str)) => {
															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
																(/*Ok(bid_str),*/ Ok(ask_str)) => {
																	//coinbase_sell_price_bid = Some(bid_str);
																	coinbase_buy_price_ask = Some(ask_str);
																	
																		success = true;
																},
																_ => {
																	log::error!("i166: coinbase: Failed to parse json into f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i166: coinbase: Failed to get bid price ");
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
															}
															continue ;
														}
													}
												}
											//03/02/24 - added else condition
											} else {
												log::error!("i166: coinbase: Failed to get pricebooks as array.");
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
												}
												continue;
											}
										},
										Err(_) => {
											log::error!("i166: coinbase: Failed to parse JSON to str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i166: coinbase: Failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i166: coinbase: Failed to execute request.");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i166: coinbase: Failed to build request");
					if attempts > 3 {
						panic!("Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}






        println!("xrp 6 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
			// //kraken asked for 3 headers: key, sign, and content type with its corresponding info
			// //.body is nonce because in the Kraken code provided in cURL: 
			// //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
			// //--data-urlencode "nonce=<YOUR-NONCE>"
			// //		this means that nonce is added to the body of the request
			// let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
			//         .header("API-Key", kraken_api_key)
			//         .header("API-Sign", &kraken_signature)
			//         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			//         .body(format!("nonce={}", nonce))
			//         .build()
			//         .expect("Failed to build kraken request");


			// let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

			// let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
			
			// //println!("kraken response:{}", kraken_response_text);

			// let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
			// let mut kraken_buy_price_ask = 0.0;
			// let mut kraken_sell_price_bid = 0.0;
			// if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
			//     // Access the ask and bid prices
			//     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
			//     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
			
			//     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
			//     //println!("xrp Bid price: {}", kraken_sell_price_bid );
			// }
			// else {
			//     println!("didnt parse kraken correctly.");
			// }











        //02/07/24 - replaced with:
			let mut kraken_sell_price_bid: Option<f64> = None;
			let mut kraken_buy_price_ask: Option<f64> = None;
			let mut value_after: Option<f64> = None;
			let mut attempts = 0;
			
			loop {
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
			
				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
													//03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	// let coinbase_taker_fee = 0.008;
																	// let fraction_of_wallet_used = 0.03;
																	// let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
																	// let fee_for_purchase = total_spent*coinbase_taker_fee;
																	// let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	// //new state of coinbase wallet below
																	// *coinbase_wallet -= total_spent;
																	// let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;



																	//Coinbase calculations
																	let coinbase_taker_fee = 0.008;
																	let fraction_of_wallet_im_using = 0.06; //aka 6 percent
																	let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																	let fee_for_purchase = total_spent*coinbase_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*coinbase_wallet -= total_spent;
																	
																	if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/10/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let coinbase_wallet_unscaled = *coinbase_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
	
																						*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is coinbase and kraken being updated, I will update:
																						//  56, 57, 59
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 57, 59];
																						let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;
	
																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*coinbase_wallet = coinbase_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is coinbase and kraken being updated, I will update:
																					// //  56, 57, 59
																					// let indices = [56, 57, 59];
																					// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i166: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i166: coinbase buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i166: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i166: Failed to get ask or bid as string"),
													}
												} 
												else {
													log::error!("i166: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i166: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i166: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i166: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i166: Failed to build kraken request. Error was: {}", e),
				}
				//03/05/24 - removed the &&buy_price_ask.is_some()
				if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
					break; // Exit the loop if everything is successful
				}
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			match value_after {
				Some(value) => return Ok(value),
				None => {
					
					panic!("Failed to get a valid value after {} attempts. 
					Final values: kraken_sell_price_bid = {:?}
					coinbase_buy_price_ask = {:?}", attempts, &kraken_sell_price_bid, &coinbase_buy_price_ask);
				}
			}

















		//03/05/24 - removed:
			//     let coinbase_taker_fee = 0.008;
			//     let fraction_of_wallet_used = 0.03;
			//     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
			//     let fee_for_purchase = total_spent*coinbase_taker_fee;
			//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
			//     //new state of coinbase wallet below
			//     *coinbase_wallet -= total_spent;
			//     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

			// //kraken calculations
			//     let kraken_taker_fee = 0.0026;
				
			//     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
			//     *kraken_wallet += money_from_sell_after_fees;

			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


			// //this will count as value after

			//         //value_after = 56
			//     //coinbase = 57
			//     //bitstamp = 58
			//     //kraken = 59
			//     //gemini = 60
			//     //since this is coinbase and kraken being updated, I will update:
			//     //  56, 57, 59
			//     let indices = [56, 57, 59];
			//     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;

			//     return Ok(value_after)

	}

    pub async fn s_i167_xrp_7_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		//03/05/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, 
        // &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);

        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);


	//03/05/24 added - 
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													//let product_id = pricebook["product_id"].as_str();
													//let bids = &pricebook["bids"][0];
													let asks = &pricebook["asks"][0];
													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
														(/*Some(bid_str),*/ Some(ask_str)) => {
															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
																(/*Ok(bid_str),*/ Ok(ask_str)) => {
																	//coinbase_sell_price_bid = Some(bid_str);
																	coinbase_buy_price_ask = Some(ask_str);
																	
																		success = true;
																},
																_ => {
																	log::error!("i167: coinbase: Failed to parse json into f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i167: coinbase: Failed to get bid price ");
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
															}
															continue ;
														}
													}
												}
											//03/02/24 - added else condition
											} else {
												log::error!("i167: coinbase: Failed to get pricebooks as array.");
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
												}
												continue;
											}
										},
										Err(_) => {
											log::error!("i167: coinbase: Failed to parse JSON to str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i167: coinbase: Failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i167: coinbase: Failed to execute request.");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i167: coinbase: Failed to build request");
					if attempts > 3 {
						panic!("Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}






        println!("xrp 7 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
			// //kraken asked for 3 headers: key, sign, and content type with its corresponding info
			// //.body is nonce because in the Kraken code provided in cURL: 
			// //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
			// //--data-urlencode "nonce=<YOUR-NONCE>"
			// //		this means that nonce is added to the body of the request
			// let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
			//         .header("API-Key", kraken_api_key)
			//         .header("API-Sign", &kraken_signature)
			//         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			//         .body(format!("nonce={}", nonce))
			//         .build()
			//         .expect("Failed to build kraken request");


			// let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

			// let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
			
			// //println!("kraken response:{}", kraken_response_text);

			// let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
			// let mut kraken_buy_price_ask = 0.0;
			// let mut kraken_sell_price_bid = 0.0;
			// if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
			//     // Access the ask and bid prices
			//     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
			//     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
			
			//     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
			//     //println!("xrp Bid price: {}", kraken_sell_price_bid );
			// }
			// else {
			//     println!("didnt parse kraken correctly.");
			// }











        //02/07/24 - replaced with:
			let mut kraken_sell_price_bid: Option<f64> = None;
			let mut kraken_buy_price_ask: Option<f64> = None;
			let mut value_after: Option<f64> = None;
			let mut attempts = 0;
			
			loop {
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
			
				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
													//03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	// let coinbase_taker_fee = 0.008;
																	// let fraction_of_wallet_used = 0.03;
																	// let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
																	// let fee_for_purchase = total_spent*coinbase_taker_fee;
																	// let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	// //new state of coinbase wallet below
																	// *coinbase_wallet -= total_spent;
																	// let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;



																	//Coinbase calculations
																	let coinbase_taker_fee = 0.008;
																	let fraction_of_wallet_im_using = 0.07; //aka 7 percent
																	let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																	let fee_for_purchase = total_spent*coinbase_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*coinbase_wallet -= total_spent;
																	
																	if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/10/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let coinbase_wallet_unscaled = *coinbase_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
	
																						*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is coinbase and kraken being updated, I will update:
																						//  56, 57, 59
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 57, 59];
																						let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;
	
																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*coinbase_wallet = coinbase_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is coinbase and kraken being updated, I will update:
																					// //  56, 57, 59
																					// let indices = [56, 57, 59];
																					// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i167: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i167: coinbase buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i167: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i167: Failed to get ask or bid as string"),
													}
												} 
												else {
													log::error!("i167: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i167: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i167: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i167: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i167: Failed to build kraken request. Error was: {}", e),
				}
				//03/05/24 - removed the &&buy_price_ask.is_some()
				if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
					break; // Exit the loop if everything is successful
				}
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			match value_after {
				Some(value) => return Ok(value),
				None => {
					
					panic!("Failed to get a valid value after {} attempts. 
					Final values: kraken_sell_price_bid = {:?}
					coinbase_buy_price_ask = {:?}", attempts, &kraken_sell_price_bid, &coinbase_buy_price_ask);
				}
			}

















		//03/05/24 - removed:
			//     let coinbase_taker_fee = 0.008;
			//     let fraction_of_wallet_used = 0.03;
			//     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
			//     let fee_for_purchase = total_spent*coinbase_taker_fee;
			//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
			//     //new state of coinbase wallet below
			//     *coinbase_wallet -= total_spent;
			//     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

			// //kraken calculations
			//     let kraken_taker_fee = 0.0026;
				
			//     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
			//     *kraken_wallet += money_from_sell_after_fees;

			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


			// //this will count as value after

			//         //value_after = 56
			//     //coinbase = 57
			//     //bitstamp = 58
			//     //kraken = 59
			//     //gemini = 60
			//     //since this is coinbase and kraken being updated, I will update:
			//     //  56, 57, 59
			//     let indices = [56, 57, 59];
			//     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;

			//     return Ok(value_after)

	}

    pub async fn s_i168_xrp_8_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		//03/05/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, 
        // &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);

        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);


	//03/05/24 added - 
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													//let product_id = pricebook["product_id"].as_str();
													//let bids = &pricebook["bids"][0];
													let asks = &pricebook["asks"][0];
													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
														(/*Some(bid_str),*/ Some(ask_str)) => {
															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
																(/*Ok(bid_str),*/ Ok(ask_str)) => {
																	//coinbase_sell_price_bid = Some(bid_str);
																	coinbase_buy_price_ask = Some(ask_str);
																	
																		success = true;
																},
																_ => {
																	log::error!("i168: coinbase: Failed to parse json into f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i168: coinbase: Failed to get bid price ");
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
															}
															continue ;
														}
													}
												}
											//03/02/24 - added else condition
											} else {
												log::error!("i168: coinbase: Failed to get pricebooks as array.");
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
												}
												continue;
											}
										},
										Err(_) => {
											log::error!("i168: coinbase: Failed to parse JSON to str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i168: coinbase: Failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i168: coinbase: Failed to execute request.");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i168: coinbase: Failed to build request");
					if attempts > 3 {
						panic!("Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}






        println!("xrp 8 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
			// //kraken asked for 3 headers: key, sign, and content type with its corresponding info
			// //.body is nonce because in the Kraken code provided in cURL: 
			// //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
			// //--data-urlencode "nonce=<YOUR-NONCE>"
			// //		this means that nonce is added to the body of the request
			// let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
			//         .header("API-Key", kraken_api_key)
			//         .header("API-Sign", &kraken_signature)
			//         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			//         .body(format!("nonce={}", nonce))
			//         .build()
			//         .expect("Failed to build kraken request");


			// let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

			// let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
			
			// //println!("kraken response:{}", kraken_response_text);

			// let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
			// let mut kraken_buy_price_ask = 0.0;
			// let mut kraken_sell_price_bid = 0.0;
			// if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
			//     // Access the ask and bid prices
			//     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
			//     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
			
			//     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
			//     //println!("xrp Bid price: {}", kraken_sell_price_bid );
			// }
			// else {
			//     println!("didnt parse kraken correctly.");
			// }











        //02/07/24 - replaced with:
			let mut kraken_sell_price_bid: Option<f64> = None;
			let mut kraken_buy_price_ask: Option<f64> = None;
			let mut value_after: Option<f64> = None;
			let mut attempts = 0;
			
			loop {
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
			
				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
													//03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	// let coinbase_taker_fee = 0.008;
																	// let fraction_of_wallet_used = 0.03;
																	// let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
																	// let fee_for_purchase = total_spent*coinbase_taker_fee;
																	// let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	// //new state of coinbase wallet below
																	// *coinbase_wallet -= total_spent;
																	// let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;



																	//Coinbase calculations
																	let coinbase_taker_fee = 0.008;
																	let fraction_of_wallet_im_using = 0.08; //aka 8 percent
																	let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																	let fee_for_purchase = total_spent*coinbase_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*coinbase_wallet -= total_spent;
																	
																	if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/10/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let coinbase_wallet_unscaled = *coinbase_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
	
																						*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is coinbase and kraken being updated, I will update:
																						//  56, 57, 59
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 57, 59];
																						let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;
	
																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*coinbase_wallet = coinbase_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is coinbase and kraken being updated, I will update:
																					// //  56, 57, 59
																					// let indices = [56, 57, 59];
																					// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i168: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i168: coinbase buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i168: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i168: Failed to get ask or bid as string"),
													}
												} 
												else {
													log::error!("i168: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i168: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i168: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i168: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i168: Failed to build kraken request. Error was: {}", e),
				}
				//03/05/24 - removed the &&buy_price_ask.is_some()
				if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
					break; // Exit the loop if everything is successful
				}
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			match value_after {
				Some(value) => return Ok(value),
				None => {
					
					panic!("Failed to get a valid value after {} attempts. 
					Final values: kraken_sell_price_bid = {:?}
					coinbase_buy_price_ask = {:?}", attempts, &kraken_sell_price_bid, &coinbase_buy_price_ask);
				}
			}

















		//03/05/24 - removed:
			//     let coinbase_taker_fee = 0.008;
			//     let fraction_of_wallet_used = 0.03;
			//     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
			//     let fee_for_purchase = total_spent*coinbase_taker_fee;
			//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
			//     //new state of coinbase wallet below
			//     *coinbase_wallet -= total_spent;
			//     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

			// //kraken calculations
			//     let kraken_taker_fee = 0.0026;
				
			//     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
			//     *kraken_wallet += money_from_sell_after_fees;

			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


			// //this will count as value after

			//         //value_after = 56
			//     //coinbase = 57
			//     //bitstamp = 58
			//     //kraken = 59
			//     //gemini = 60
			//     //since this is coinbase and kraken being updated, I will update:
			//     //  56, 57, 59
			//     let indices = [56, 57, 59];
			//     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;

			//     return Ok(value_after)

	}

    pub async fn s_i169_xrp_9_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		//03/05/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, 
        // &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);

        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);


	//03/05/24 added - 
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													//let product_id = pricebook["product_id"].as_str();
													//let bids = &pricebook["bids"][0];
													let asks = &pricebook["asks"][0];
													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
														(/*Some(bid_str),*/ Some(ask_str)) => {
															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
																(/*Ok(bid_str),*/ Ok(ask_str)) => {
																	//coinbase_sell_price_bid = Some(bid_str);
																	coinbase_buy_price_ask = Some(ask_str);
																	
																		success = true;
																},
																_ => {
																	log::error!("i169: coinbase: Failed to parse json into f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i169: coinbase: Failed to get bid price ");
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
															}
															continue ;
														}
													}
												}
											//03/02/24 - added else condition
											} else {
												log::error!("i169: coinbase: Failed to get pricebooks as array.");
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
												}
												continue;
											}
										},
										Err(_) => {
											log::error!("i169: coinbase: Failed to parse JSON to str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i169: coinbase: Failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i169: coinbase: Failed to execute request.");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i169: coinbase: Failed to build request");
					if attempts > 3 {
						panic!("Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}






        println!("xrp 9 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
			// //kraken asked for 3 headers: key, sign, and content type with its corresponding info
			// //.body is nonce because in the Kraken code provided in cURL: 
			// //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
			// //--data-urlencode "nonce=<YOUR-NONCE>"
			// //		this means that nonce is added to the body of the request
			// let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
			//         .header("API-Key", kraken_api_key)
			//         .header("API-Sign", &kraken_signature)
			//         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			//         .body(format!("nonce={}", nonce))
			//         .build()
			//         .expect("Failed to build kraken request");


			// let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

			// let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
			
			// //println!("kraken response:{}", kraken_response_text);

			// let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
			// let mut kraken_buy_price_ask = 0.0;
			// let mut kraken_sell_price_bid = 0.0;
			// if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
			//     // Access the ask and bid prices
			//     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
			//     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
			
			//     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
			//     //println!("xrp Bid price: {}", kraken_sell_price_bid );
			// }
			// else {
			//     println!("didnt parse kraken correctly.");
			// }











        //02/07/24 - replaced with:
			let mut kraken_sell_price_bid: Option<f64> = None;
			let mut kraken_buy_price_ask: Option<f64> = None;
			let mut value_after: Option<f64> = None;
			let mut attempts = 0;
			
			loop {
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
			
				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
													//03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	// let coinbase_taker_fee = 0.008;
																	// let fraction_of_wallet_used = 0.03;
																	// let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
																	// let fee_for_purchase = total_spent*coinbase_taker_fee;
																	// let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	// //new state of coinbase wallet below
																	// *coinbase_wallet -= total_spent;
																	// let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;



																	//Coinbase calculations
																	let coinbase_taker_fee = 0.008;
																	let fraction_of_wallet_im_using = 0.09; //aka 9 percent
																	let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																	let fee_for_purchase = total_spent*coinbase_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*coinbase_wallet -= total_spent;
																	
																	if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/10/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let coinbase_wallet_unscaled = *coinbase_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
	
																						*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is coinbase and kraken being updated, I will update:
																						//  56, 57, 59
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 57, 59];
																						let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;
	
																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*coinbase_wallet = coinbase_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is coinbase and kraken being updated, I will update:
																					// //  56, 57, 59
																					// let indices = [56, 57, 59];
																					// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i169: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i169: coinbase buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i169: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i169: Failed to get ask or bid as string"),
													}
												} 
												else {
													log::error!("i169: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i169: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i169: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i169: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i169: Failed to build kraken request. Error was: {}", e),
				}
				//03/05/24 - removed the &&buy_price_ask.is_some()
				if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
					break; // Exit the loop if everything is successful
				}
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			match value_after {
				Some(value) => return Ok(value),
				None => {
					
					panic!("Failed to get a valid value after {} attempts. 
					Final values: kraken_sell_price_bid = {:?}
					coinbase_buy_price_ask = {:?}", attempts, &kraken_sell_price_bid, &coinbase_buy_price_ask);
				}
			}

















		//03/05/24 - removed:
			//     let coinbase_taker_fee = 0.008;
			//     let fraction_of_wallet_used = 0.03;
			//     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
			//     let fee_for_purchase = total_spent*coinbase_taker_fee;
			//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
			//     //new state of coinbase wallet below
			//     *coinbase_wallet -= total_spent;
			//     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

			// //kraken calculations
			//     let kraken_taker_fee = 0.0026;
				
			//     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
			//     *kraken_wallet += money_from_sell_after_fees;

			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


			// //this will count as value after

			//         //value_after = 56
			//     //coinbase = 57
			//     //bitstamp = 58
			//     //kraken = 59
			//     //gemini = 60
			//     //since this is coinbase and kraken being updated, I will update:
			//     //  56, 57, 59
			//     let indices = [56, 57, 59];
			//     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;

			//     return Ok(value_after)

	}

    pub async fn s_i170_xrp_10_coinbase_kraken( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
        gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

		//03/05/24 - removed:
        // let now = Utc::now();
        // let time_stamp = now.timestamp().to_string();
        // let method = "GET";
        // let request_path = "/api/v3/brokerage/best_bid_ask";
        // let body = "";
        // let message = format!("{}{}{}{}", &time_stamp, 
        // &method, &request_path, &body);
        // type HmacSha256 = Hmac<Sha256>;
        // fn sign(message: &str, coinbase_secret: &str) -> String {
        // let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
        //             .expect("HMAC can take key of any size");
        // mac.update(message.as_bytes());
        // let result = mac.finalize();
        // let code_bytes = result.into_bytes();
        // hex::encode(code_bytes)
        // }
        // let coinbase_signature = sign(&message, &coinbase_secret);

        // let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        // .header("CB-ACCESS-KEY", coinbase_api_key)
        // .header("CB-ACCESS-SIGN", &coinbase_signature)
        // .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        // .build()
        // .expect("couldn't build request");
        // //manages the error I described above
        // //let request = match request {
        // //Ok(req) => req,
        // //Err(e) => {
        // //eprintln!("Failed to build request: \n{}", e);
        // //return Err(e);
        // //}
        // //};

        // let response = client.execute(request).await.expect("couldn't build response");
        // //let response = match response {
        // //    Ok(resp) => resp,
        // //    Err(e) => {
        // //        eprintln!("Failed to execute request: \n{}", e);
        // //        return Err(e);
        // //    }
        // //};


        // let response_text = response.text().await.expect("couldn't build response_text");

        // //added 12/29/23
        // //this is the parsing
        // let v: Value = serde_json::from_str(&response_text).expect("couldn't turn response_text into serde_json format");
        // let mut coinbase_sell_price_bid = 0.0;
        // let mut coinbase_buy_price_ask = 0.0;

        // // Access the pricebooks array
        // if let Some(pricebooks) = v["pricebooks"].as_array() {
        //     // Iterate over each pricebook
        //     for pricebook in pricebooks {
        //         // Access the product_id, bids, and asks
        //         let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //         let bids = &pricebook["bids"][0];
        //         let asks = &pricebook["asks"][0];
        
        //         // Access the price and size of the bids and asks
        //         coinbase_sell_price_bid = bids["price"].as_str().expect("could not find bids[price]").parse::<f64>().expect("could not parse to f64. bids");
        //         let bid_size = bids["size"].as_str().expect("could not find bids[size]");
        //         coinbase_buy_price_ask = asks["price"].as_str().expect("could not find asks[price]").parse::<f64>().expect("could not parse to f64");
        //         let ask_size = asks["size"].as_str().expect("could not find asks[size]");
        
        //         //println!("Product ID: {}", product_id);
        //         //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //         //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //     }
        // }

        //manages any errors from line above
        //let response_text = match response_text {
        //    Ok(t) => t,
        //    Err(e) => {
        //        eprintln!("Failed to read response text: \n{}", e);
        //        return;
        //    }
        //};

        //prints the actual response
        //println!("list accounts response\n{:?}", &response_text);


	//03/05/24 added - 
		let now = Utc::now();
		let time_stamp = now.timestamp().to_string();
		let method = "GET";
		let request_path = "/api/v3/brokerage/best_bid_ask";
		let body = "";
		let message = format!("{}{}{}{}", &time_stamp, 
		&method, &request_path, &body);
		type HmacSha256 = Hmac<Sha256>;
		fn sign(message: &str, coinbase_secret: &str) -> String {
		let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
					.expect("HMAC can take key of any size");
		mac.update(message.as_bytes());
		let result = mac.finalize();
		let code_bytes = result.into_bytes();
		hex::encode(code_bytes)
		}
		let coinbase_signature = sign(&message, &coinbase_secret);


		let mut coinbase_buy_price_ask: Option<f64> = None;
		let mut attempts = 0;
		let mut success = false;
		loop {
			attempts +=1;
			let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
			.header("CB-ACCESS-KEY", coinbase_api_key)
			.header("CB-ACCESS-SIGN", &coinbase_signature)
			.header("CB-ACCESS-TIMESTAMP", &time_stamp)
			.build();

			match request {
				Ok(req) => {
					let response = client.execute(req).await;
					match response {
						Ok(resp) => {
							let response_text = resp.text().await;
							match response_text {
								Ok(text) => {
									match serde_json::from_str::<Value>(&text) {
										Ok(v) => {
											if let Some(pricebooks) = v["pricebooks"].as_array() {
												for pricebook in pricebooks {
													//let product_id = pricebook["product_id"].as_str();
													//let bids = &pricebook["bids"][0];
													let asks = &pricebook["asks"][0];
													//let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
													let before_parse_coinbase_buy_price_ask = asks["price"].as_str();

													match (/*before_parse_coinbase_sell_price_bid,*/ before_parse_coinbase_buy_price_ask) {
														(/*Some(bid_str),*/ Some(ask_str)) => {
															match (/*bid_str.parse::<f64>(),*/ ask_str.parse::<f64>()) {
																(/*Ok(bid_str),*/ Ok(ask_str)) => {
																	//coinbase_sell_price_bid = Some(bid_str);
																	coinbase_buy_price_ask = Some(ask_str);
																	
																		success = true;
																},
																_ => {
																	log::error!("i170: coinbase: Failed to parse json into f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i170: coinbase: Failed to get bid price ");
															if attempts > 3 {
																//panic!("Failed to get bid or ask price after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
																panic!("Failed to get bid price after 3 attempts. Ask: {:?}", before_parse_coinbase_buy_price_ask);
															}
															continue ;
														}
													}
												}
											//03/02/24 - added else condition
											} else {
												log::error!("i170: coinbase: Failed to get pricebooks as array.");
												if attempts > 3 {
													panic!("Failed to get pricebooks as array after 3 attempts. Response text: {}", text);
												}
												continue;
											}
										},
										Err(_) => {
											log::error!("i170: coinbase: Failed to parse JSON to str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i170: coinbase: Failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i170: coinbase: Failed to execute request.");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i170: coinbase: Failed to build request");
					if attempts > 3 {
						panic!("Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}






        println!("xrp 10 coinbase kraken: 8 sec delay");
        let when = tokio::time::Instant::now() + Duration::from_secs(8);
        //02/09/21 - tokio update. changed from delay_until to sleep_until
        tokio::time::sleep_until(when).await;





        //---KRAKEN--//

        //basically Kraken requires a value that is always increasing to be in each request.
        //I didnt use now.timestamp().to_string()  because just in case I have 2 
        //	requests in a second I dont want to be penalized.
        //if no "now" in scope when moving file, 
        //	the code is this:
        ////returns current time. MAY NEED TO USE LOCAL TIME
        let now = Utc::now();
        let nonce = now.timestamp_millis().to_string();
        let data = vec![
            ("nonce", &nonce),
            // Add more parameters as needed
        ];
        //let post_data: String = form_urlencoded::Serializer::new(String::new())
        //    .extend_pairs(data)
        //    .finish();
        
        let url_path = "/0/public/Ticker?pair=XRPUSD";
        //let message = format!("{}{}{}", url_path, nonce, post_data);

        fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
        -> String {
            // Create the post data
            let post_data: String = form_urlencoded::Serializer::new(String::new())
                .extend_pairs(data)
                .finish();
            //FOR DEBUGGING
            //println!("Private key:\n{}", secret);
            //println!("Nonce:\n{}", nonce_str);
            //println!("Encoded payload:\n{}", post_data);
            //println!("URI Path:\n{}", url_path);
        
            // Create the encoded string (nonce + post data) and hash it
            let encoded = format!("{}{}", nonce_str, post_data);
            let mut hasher = sha2::Sha256::new();
            hasher.update(encoded);
            let encoded_hash = hasher.finalize();
        
            // Create the message (url_path + encoded_hash as bytes)
            let mut message = url_path.as_bytes().to_vec();
            message.extend_from_slice(&encoded_hash);
        
            // Create a HMAC-SHA512 object with the base64-decoded secret
            let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
            let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
                .expect("HMAC can take key of any size");
        
            // Compute the HMAC of the message
            mac.update(&message);
            let result = mac.finalize();
        
            // Return the base64-encoded HMAC
            let signature = base64::encode(result.into_bytes());
            //println!("Kraken signature:\n{}", signature);
        
            signature
        }

        let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

		//03/05/24 - removed:
			// //kraken asked for 3 headers: key, sign, and content type with its corresponding info
			// //.body is nonce because in the Kraken code provided in cURL: 
			// //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
			// //--data-urlencode "nonce=<YOUR-NONCE>"
			// //		this means that nonce is added to the body of the request
			// let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
			//         .header("API-Key", kraken_api_key)
			//         .header("API-Sign", &kraken_signature)
			//         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
			//         .body(format!("nonce={}", nonce))
			//         .build()
			//         .expect("Failed to build kraken request");


			// let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

			// let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
			
			// //println!("kraken response:{}", kraken_response_text);

			// let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
			// let mut kraken_buy_price_ask = 0.0;
			// let mut kraken_sell_price_bid = 0.0;
			// if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
			//     // Access the ask and bid prices
			//     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
			//     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
			
			//     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
			//     //println!("xrp Bid price: {}", kraken_sell_price_bid );
			// }
			// else {
			//     println!("didnt parse kraken correctly.");
			// }











        //02/07/24 - replaced with:
			let mut kraken_sell_price_bid: Option<f64> = None;
			let mut kraken_buy_price_ask: Option<f64> = None;
			let mut value_after: Option<f64> = None;
			let mut attempts = 0;
			
			loop {
				let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
					.header("API-Key", kraken_api_key)
					.header("API-Sign", &kraken_signature)
					.header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
					.body(format!("nonce={}", nonce))
					.build();
			
				match kraken_basic_request {
					Ok(request) => {
						match client.execute(request).await {
							Ok(response) => {
								match response.text().await {
									Ok(kraken_response_text) => {
										match serde_json::from_str::<Value>(&kraken_response_text) {
											Ok(value) => {
												if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {
													//03/05/24 - changed to this: the other code was too much, so I just removed it
													//		instead of code commenting it out
													match (/*xrpusd["a"][0].as_str(),*/ xrpusd["b"][0].as_str()) {
														(/*Some(ask_str),*/ Some(bid_str)) => {
															match (/*ask_str.parse::<f64>(),*/ bid_str.parse::<f64>()) {
																(/*Ok(ask),*/ Ok(bid)) => {
																	//kraken_buy_price_ask = Some(ask);
																	kraken_sell_price_bid = Some(bid);
																	// // Continue with your logic here...
	
																	// let coinbase_taker_fee = 0.008;
																	// let fraction_of_wallet_used = 0.03;
																	// let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
																	// let fee_for_purchase = total_spent*coinbase_taker_fee;
																	// let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	// //new state of coinbase wallet below
																	// *coinbase_wallet -= total_spent;
																	// let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;



																	//Coinbase calculations
																	let coinbase_taker_fee = 0.008;
																	let fraction_of_wallet_im_using = 0.10; //aka 10 percent
																	let total_spent = fraction_of_wallet_im_using*(*coinbase_wallet);
																	let fee_for_purchase = total_spent*coinbase_taker_fee;
																	let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
																	//new state of coinbase wallet below
																	*coinbase_wallet -= total_spent;
																	
																	if let Some(coinbase_buy_price_ask) = coinbase_buy_price_ask {
																		if let Some(kraken_sell_price_bid) = kraken_sell_price_bid {
																			
																			let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;
																			// Continue with your logic here...
																			//kraken calculations - for sell
																				let kraken_taker_fee = 0.0026;
																				
																				let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
																				let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
																				let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
																				*kraken_wallet += money_from_sell_after_fees;
																			
																			
																			
																			//this will count as value after
																					value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																					if let Some(mut value_after) = value_after {

																						//03/10/24 - added for unscaling
																						let value_after_unscaled = value_after;
																						let coinbase_wallet_unscaled = *coinbase_wallet;
																						let kraken_wallet_unscaled = *kraken_wallet;
	
																						*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																						*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																						value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																						
																						//value_after = 56
																						//coinbase = 57
																						//bitstamp = 58
																						//kraken = 59
																						//gemini = 60
																						//since this is coinbase and kraken being updated, I will update:
																						//  56, 57, 59
																						//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																						let indices = [56, 57, 59];
																						let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																						//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																						neural_network.update_input(&indices, &scaled_values).await;
	
																						//03/09/24 - added for unscaling:
																						value_after = value_after_unscaled;
																						*coinbase_wallet = coinbase_wallet_unscaled;
																						*kraken_wallet = kraken_wallet_unscaled;

                                                                                        //03/13/24 - added:
                                                                                        return Ok(value_after);
																					}
																					//03/08/24 - removed:
																					// //value_after = 56
																					// //coinbase = 57
																					// //bitstamp = 58
																					// //kraken = 59
																					// //gemini = 60
																					// //since this is coinbase and kraken being updated, I will update:
																					// //  56, 57, 59
																					// let indices = [56, 57, 59];
																					// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																					// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																					// neural_network.update_input(&indices, &scaled_values).await;
																		}
																		else {
																			log::error!("i170: Kraken sell price is None. Response text was: {}", kraken_response_text);
																		}
																	} 
																	else {
																		log::error!("i170: coinbase buy ask is None. Response text was: {}", kraken_response_text);
																	}
																	//03/05/24 - dont think its necessary
																	//break; // Exit the loop if everything is successful
																},
																_ => log::error!("i170: Failed to parse ask or bid as f64"),
															}
														},
														_ => log::error!("i170: Failed to get ask or bid as string"),
													}
												} 
												else {
													log::error!("i170: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
												}
											},
											Err(e) => log::error!("i170: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
										}
									},
									Err(e) => log::error!("i170: Failed to read response text. Error was: {}", e),
								}
							},
							Err(e) => log::error!("i170: Failed to execute Kraken request. Error was: {}", e),
						}
					},
					Err(e) => log::error!("i170: Failed to build kraken request. Error was: {}", e),
				}
				//03/05/24 - removed the &&buy_price_ask.is_some()
				if kraken_sell_price_bid.is_some() /*&& kraken_buy_price_ask.is_some()*/ {
					break; // Exit the loop if everything is successful
				}
				attempts += 1;
				if attempts >= 3 {
					panic!("Failed after 3 attempts");
				}
			}

			match value_after {
				Some(value) => return Ok(value),
				None => {
					
					panic!("Failed to get a valid value after {} attempts. 
					Final values: kraken_sell_price_bid = {:?}
					coinbase_buy_price_ask = {:?}", attempts, &kraken_sell_price_bid, &coinbase_buy_price_ask);
				}
			}

















		//03/05/24 - removed:
			//     let coinbase_taker_fee = 0.008;
			//     let fraction_of_wallet_used = 0.03;
			//     let total_spent = fraction_of_wallet_used*(*coinbase_wallet);
			//     let fee_for_purchase = total_spent*coinbase_taker_fee;
			//     let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
			//     //new state of coinbase wallet below
			//     *coinbase_wallet -= total_spent;
			//     let amount_of_xrp = money_going_to_xrp_after_fees/coinbase_buy_price_ask;

			// //kraken calculations
			//     let kraken_taker_fee = 0.0026;
				
			//     let money_from_sell_before_fees = amount_of_xrp * kraken_sell_price_bid;
			//     let fee_for_sell = money_from_sell_before_fees * kraken_taker_fee;
			//     let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell ;
			//     *kraken_wallet += money_from_sell_after_fees;

			//     let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;


			// //this will count as value after

			//         //value_after = 56
			//     //coinbase = 57
			//     //bitstamp = 58
			//     //kraken = 59
			//     //gemini = 60
			//     //since this is coinbase and kraken being updated, I will update:
			//     //  56, 57, 59
			//     let indices = [56, 57, 59];
			//     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
			//     //01/24/24 - removed and added:
			//         //neural_network.update_input(&indices, &new_values);
			//         //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
			//         //neural_network.update_input(&indices, &transformed_values).await;
			//         let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
			//         neural_network.update_input(&indices, &scaled_values).await;

			//     return Ok(value_after)

	}
//kraken coinbase   = 4 AND UP for min of 25 XRP withdraw = 15 dollars. 3 and up should work but just in case
	pub async fn s_i174_xrp_4_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

    //---KRAKEN--//

    //basically Kraken requires a value that is always increasing to be in each request.
    //I didnt use now.timestamp().to_string()  because just in case I have 2 
    //	requests in a second I dont want to be penalized.
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time. MAY NEED TO USE LOCAL TIME
    let now = Utc::now();
    let nonce = now.timestamp_millis().to_string();
    let data = vec![
        ("nonce", &nonce),
        // Add more parameters as needed
    ];
    //let post_data: String = form_urlencoded::Serializer::new(String::new())
    //    .extend_pairs(data)
    //    .finish();
    
    let url_path = "/0/public/Ticker?pair=XRPUSD";
    //let message = format!("{}{}{}", url_path, nonce, post_data);


    fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
    -> String {
        // Create the post data
        let post_data: String = form_urlencoded::Serializer::new(String::new())
            .extend_pairs(data)
            .finish();
        //FOR DEBUGGING
        //println!("Private key:\n{}", secret);
        //println!("Nonce:\n{}", nonce_str);
        //println!("Encoded payload:\n{}", post_data);
        //println!("URI Path:\n{}", url_path);
    
        // Create the encoded string (nonce + post data) and hash it
        let encoded = format!("{}{}", nonce_str, post_data);
        let mut hasher = sha2::Sha256::new();
        hasher.update(encoded);
        let encoded_hash = hasher.finalize();
    
        // Create the message (url_path + encoded_hash as bytes)
        let mut message = url_path.as_bytes().to_vec();
        message.extend_from_slice(&encoded_hash);
    
        // Create a HMAC-SHA512 object with the base64-decoded secret
        let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
            .expect("HMAC can take key of any size");
    
        // Compute the HMAC of the message
        mac.update(&message);
        let result = mac.finalize();
    
        // Return the base64-encoded HMAC
        let signature = base64::encode(result.into_bytes());
        //println!("Kraken signature:\n{}", signature);
    
        signature
    }


    
    let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

    //kraken asked for 3 headers: key, sign, and content type with its corresponding info
    //.body is nonce because in the Kraken code provided in cURL: 
    //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
    //--data-urlencode "nonce=<YOUR-NONCE>"
    //		this means that nonce is added to the body of the request
    //02/02/24 - removed:
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
        //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
        //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }
//02/02/24 - added in its place:
	//03/05/24 - changed to mut and = None;
    let mut kraken_buy_price_ask: Option<f64> = None;
    //let mut kraken_sell_price_bid: Option<f64> = None;
    let mut attempts = 0;

    loop {
        attempts += 1;
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            .header("API-Key", kraken_api_key)
            .header("API-Sign", &kraken_signature)
            .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            .body(format!("nonce={}", nonce))
            .build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

												match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
													(Some(ask_str), /*Some(bid_str)*/) => {
														match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
															(Ok(ask), /*Ok(bid)*/) => {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															_ => log::error!("i174: Kraken: Failed to parse ask or bid as f64"),
														}
													},
													_ => log::error!("i174: Kraken: Failed to get ask or bid as string"),
												}										
											}
											else {
												log::error!("i174: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i174: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i174: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i174: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i174: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}







    println!("xrp 4 kraken coinbase : 8 sec delay");
    let when = tokio::time::Instant::now() + Duration::from_secs(8);
    //02/09/21 - tokio update. changed from delay_until to sleep_until
    tokio::time::sleep_until(when).await;






    //------------COINBASE------------//
    let now = Utc::now();
    let time_stamp = now.timestamp().to_string();
    let method = "GET";
    let request_path = "/api/v3/brokerage/best_bid_ask";
    let body = "";
    let message = format!("{}{}{}{}", &time_stamp, 
    &method, &request_path, &body);
    type HmacSha256 = Hmac<Sha256>;
    fn sign(message: &str, coinbase_secret: &str) -> String {
    let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                .expect("HMAC can take key of any size");
    mac.update(message.as_bytes());
    let result = mac.finalize();
    let code_bytes = result.into_bytes();
    hex::encode(code_bytes)
    }
    let coinbase_signature = sign(&message, &coinbase_secret);

    //01/30/24 - added:
    //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
    //      instead, it will try to do any of the following things it failed 3 times.
    //      if it still doesn't work, then yeah panic.
        //new variables
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        let mut success = false;
    loop {
        attempts +=1;
        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build();
        //.expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};
        match request {
            Ok(req) => {
        //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                let response = client.execute(req).await;
                match response {
                    Ok(resp) => {
                        let response_text = resp.text().await;
                        match response_text {
                            Ok(text) => {
                                match serde_json::from_str::<Value>(&text) {
                                    Ok(v) => {
                                        if let Some(pricebooks) = v["pricebooks"].as_array() {
                                            for pricebook in pricebooks {
                                                //let product_id = pricebook["product_id"].as_str();
                                                let bids = &pricebook["bids"][0];
                                                //let asks = &pricebook["asks"][0];
                                                let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
    
                                                match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                    (Some(bid_str), /*Some(ask_str)*/) => {
                                                        match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                            (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                coinbase_sell_price_bid = Some(bid_str);
                                                                //coinbase_buy_price_ask = Some(ask_str);

                                                                // Place your calculations and updates here
                                                                    let kraken_taker_fee = 0.0026;
                                                                    let fraction_of_wallet_im_using = 0.04;  //aka 4 percent
                                                                    let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                    let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                    //03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;
                                                                    let amount_of_xrp_before_withdraw_fee = 
                                                                                    money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                        .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                        even though to get to this point it had to be Some. 
                                                                                        Kraken_buy_price_ask: {:?}
                                                                                        Honestly restart the program from the last saved state. 
                                                                                        The most likely error is a bit got flipped after the loop", 
                                                                                        &kraken_buy_price_ask));
                                                                    let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                    //coinbase calculations for sell

                                                                    let coinbase_taker_fee = 0.008;
                                                                    let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                    let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                    *coinbase_wallet += money_from_sell_after_fees;
                                                                    value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																	if let Some(mut value_after) = value_after {

																		//03/10/24 - added for unscaling
																		let value_after_unscaled = value_after;
																		let coinbase_wallet_unscaled = *coinbase_wallet;
																		let kraken_wallet_unscaled = *kraken_wallet;

																		*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is coinbase and kraken being updated, I will update:
																		//  56, 57, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 57, 59];
																		let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;

																		//03/09/24 - added for unscaling:
																		value_after = value_after_unscaled;
																		*coinbase_wallet = coinbase_wallet_unscaled;
																		*kraken_wallet = kraken_wallet_unscaled;

                                                                        //03/13/24 - added:
                                                                        return Ok(value_after);
																	}
																	//03/08/24 - removed:
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is coinbase and kraken being updated, I will update:
																	// //  56, 57, 59
																	// let indices = [56, 57, 59];
																	// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;

                                                                    success = true;
																},
																_ => {
																	log::error!("i174: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i174: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i174: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i174: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i174: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i174: Failed to build request");
					if attempts > 3 {
						panic!("i174: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


        //    let response_text = response.text().await.expect("Failed to build response_text from response");

        //    //added 12/29/23
        //    //this is the parsing
        //    //01/30/24 - improved error messages to be more detailed in let v: Value
        //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
        //    let mut coinbase_sell_price_bid = 0.0;
        //    let mut coinbase_buy_price_ask = 0.0;

        //    // Access the pricebooks array
        //    if let Some(pricebooks) = v["pricebooks"].as_array() {
        //        // Iterate over each pricebook
        //        for pricebook in pricebooks {
        //            // Access the product_id, bids, and asks
        //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //            let bids = &pricebook["bids"][0];
        //            let asks = &pricebook["asks"][0];
        //            // Access the price and size of the bids and asks
        //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
        //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
        //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
        //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
        //            //println!("Product ID: {}", product_id);
        //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //        }
        //    }
        //}
    //}








        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
        // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        // *kraken_wallet -= money_going_to_xrp_after_fees;
        // let amount_of_xrp_before_withdraw_fee = 
        //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
        // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;





        //coinbase calculations for sell

        // let coinbase_taker_fee = 0.008;
        // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *coinbase_wallet += money_from_sell_after_fees;
        // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is coinbase and kraken being updated, I will update:
        //     //  56, 57, 59
        //     let indices = [56, 57, 59];
        //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;


        match value_after {
            Some(value) => return Ok(value),
            None => {
                //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
            }
        }
	}

	pub async fn s_i175_xrp_5_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

    //---KRAKEN--//

    //basically Kraken requires a value that is always increasing to be in each request.
    //I didnt use now.timestamp().to_string()  because just in case I have 2 
    //	requests in a second I dont want to be penalized.
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time. MAY NEED TO USE LOCAL TIME
    let now = Utc::now();
    let nonce = now.timestamp_millis().to_string();
    let data = vec![
        ("nonce", &nonce),
        // Add more parameters as needed
    ];
    //let post_data: String = form_urlencoded::Serializer::new(String::new())
    //    .extend_pairs(data)
    //    .finish();
    
    let url_path = "/0/public/Ticker?pair=XRPUSD";
    //let message = format!("{}{}{}", url_path, nonce, post_data);


    fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
    -> String {
        // Create the post data
        let post_data: String = form_urlencoded::Serializer::new(String::new())
            .extend_pairs(data)
            .finish();
        //FOR DEBUGGING
        //println!("Private key:\n{}", secret);
        //println!("Nonce:\n{}", nonce_str);
        //println!("Encoded payload:\n{}", post_data);
        //println!("URI Path:\n{}", url_path);
    
        // Create the encoded string (nonce + post data) and hash it
        let encoded = format!("{}{}", nonce_str, post_data);
        let mut hasher = sha2::Sha256::new();
        hasher.update(encoded);
        let encoded_hash = hasher.finalize();
    
        // Create the message (url_path + encoded_hash as bytes)
        let mut message = url_path.as_bytes().to_vec();
        message.extend_from_slice(&encoded_hash);
    
        // Create a HMAC-SHA512 object with the base64-decoded secret
        let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
            .expect("HMAC can take key of any size");
    
        // Compute the HMAC of the message
        mac.update(&message);
        let result = mac.finalize();
    
        // Return the base64-encoded HMAC
        let signature = base64::encode(result.into_bytes());
        //println!("Kraken signature:\n{}", signature);
    
        signature
    }


    
    let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

    //kraken asked for 3 headers: key, sign, and content type with its corresponding info
    //.body is nonce because in the Kraken code provided in cURL: 
    //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
    //--data-urlencode "nonce=<YOUR-NONCE>"
    //		this means that nonce is added to the body of the request
    //02/02/24 - removed:
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
        //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
        //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }
//02/02/24 - added in its place:
	//03/05/24 - changed to mut and = None;
    let mut kraken_buy_price_ask: Option<f64> = None;
    //let mut kraken_sell_price_bid: Option<f64> = None;
    let mut attempts = 0;

    loop {
        attempts += 1;
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            .header("API-Key", kraken_api_key)
            .header("API-Sign", &kraken_signature)
            .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            .body(format!("nonce={}", nonce))
            .build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

												match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
													(Some(ask_str), /*Some(bid_str)*/) => {
														match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
															(Ok(ask), /*Ok(bid)*/) => {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															_ => log::error!("i175: Kraken: Failed to parse ask or bid as f64"),
														}
													},
													_ => log::error!("i175: Kraken: Failed to get ask or bid as string"),
												}										
											}
											else {
												log::error!("i175: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i175: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i175: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i175: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i175: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}







    println!("xrp 5 kraken coinbase : 8 sec delay");
    let when = tokio::time::Instant::now() + Duration::from_secs(8);
    //02/09/21 - tokio update. changed from delay_until to sleep_until
    tokio::time::sleep_until(when).await;






    //------------COINBASE------------//
    let now = Utc::now();
    let time_stamp = now.timestamp().to_string();
    let method = "GET";
    let request_path = "/api/v3/brokerage/best_bid_ask";
    let body = "";
    let message = format!("{}{}{}{}", &time_stamp, 
    &method, &request_path, &body);
    type HmacSha256 = Hmac<Sha256>;
    fn sign(message: &str, coinbase_secret: &str) -> String {
    let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                .expect("HMAC can take key of any size");
    mac.update(message.as_bytes());
    let result = mac.finalize();
    let code_bytes = result.into_bytes();
    hex::encode(code_bytes)
    }
    let coinbase_signature = sign(&message, &coinbase_secret);

    //01/30/24 - added:
    //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
    //      instead, it will try to do any of the following things it failed 3 times.
    //      if it still doesn't work, then yeah panic.
        //new variables
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        let mut success = false;
    loop {
        attempts +=1;
        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build();
        //.expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};
        match request {
            Ok(req) => {
        //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                let response = client.execute(req).await;
                match response {
                    Ok(resp) => {
                        let response_text = resp.text().await;
                        match response_text {
                            Ok(text) => {
                                match serde_json::from_str::<Value>(&text) {
                                    Ok(v) => {
                                        if let Some(pricebooks) = v["pricebooks"].as_array() {
                                            for pricebook in pricebooks {
                                                //let product_id = pricebook["product_id"].as_str();
                                                let bids = &pricebook["bids"][0];
                                                //let asks = &pricebook["asks"][0];
                                                let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
    
                                                match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                    (Some(bid_str), /*Some(ask_str)*/) => {
                                                        match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                            (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                coinbase_sell_price_bid = Some(bid_str);
                                                                //coinbase_buy_price_ask = Some(ask_str);

                                                                // Place your calculations and updates here
                                                                    let kraken_taker_fee = 0.0026;
                                                                    let fraction_of_wallet_im_using = 0.05;  //aka 5 percent
                                                                    let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                    let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                    //03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;
                                                                    let amount_of_xrp_before_withdraw_fee = 
                                                                                    money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                        .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                        even though to get to this point it had to be Some. 
                                                                                        Kraken_buy_price_ask: {:?}
                                                                                        Honestly restart the program from the last saved state. 
                                                                                        The most likely error is a bit got flipped after the loop", 
                                                                                        &kraken_buy_price_ask));
                                                                    let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                    //coinbase calculations for sell

                                                                    let coinbase_taker_fee = 0.008;
                                                                    let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                    let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                    *coinbase_wallet += money_from_sell_after_fees;
                                                                    value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																	if let Some(mut value_after) = value_after {

																		//03/10/24 - added for unscaling
																		let value_after_unscaled = value_after;
																		let coinbase_wallet_unscaled = *coinbase_wallet;
																		let kraken_wallet_unscaled = *kraken_wallet;

																		*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is coinbase and kraken being updated, I will update:
																		//  56, 57, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 57, 59];
																		let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;

																		//03/09/24 - added for unscaling:
																		value_after = value_after_unscaled;
																		*coinbase_wallet = coinbase_wallet_unscaled;
																		*kraken_wallet = kraken_wallet_unscaled;

                                                                        //03/13/24 - added:
                                                                        return Ok(value_after);
																	}
																	//03/08/24 - removed:
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is coinbase and kraken being updated, I will update:
																	// //  56, 57, 59
																	// let indices = [56, 57, 59];
																	// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;

                                                                    success = true;
																},
																_ => {
																	log::error!("i175: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i175: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i175: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i175: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i175: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i175: Failed to build request");
					if attempts > 3 {
						panic!("i175: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


        //    let response_text = response.text().await.expect("Failed to build response_text from response");

        //    //added 12/29/23
        //    //this is the parsing
        //    //01/30/24 - improved error messages to be more detailed in let v: Value
        //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
        //    let mut coinbase_sell_price_bid = 0.0;
        //    let mut coinbase_buy_price_ask = 0.0;

        //    // Access the pricebooks array
        //    if let Some(pricebooks) = v["pricebooks"].as_array() {
        //        // Iterate over each pricebook
        //        for pricebook in pricebooks {
        //            // Access the product_id, bids, and asks
        //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //            let bids = &pricebook["bids"][0];
        //            let asks = &pricebook["asks"][0];
        //            // Access the price and size of the bids and asks
        //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
        //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
        //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
        //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
        //            //println!("Product ID: {}", product_id);
        //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //        }
        //    }
        //}
    //}








        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
        // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        // *kraken_wallet -= money_going_to_xrp_after_fees;
        // let amount_of_xrp_before_withdraw_fee = 
        //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
        // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;





        //coinbase calculations for sell

        // let coinbase_taker_fee = 0.008;
        // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *coinbase_wallet += money_from_sell_after_fees;
        // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is coinbase and kraken being updated, I will update:
        //     //  56, 57, 59
        //     let indices = [56, 57, 59];
        //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;


        match value_after {
            Some(value) => return Ok(value),
            None => {
                //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
            }
        }
	}

	pub async fn s_i176_xrp_6_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

    //---KRAKEN--//

    //basically Kraken requires a value that is always increasing to be in each request.
    //I didnt use now.timestamp().to_string()  because just in case I have 2 
    //	requests in a second I dont want to be penalized.
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time. MAY NEED TO USE LOCAL TIME
    let now = Utc::now();
    let nonce = now.timestamp_millis().to_string();
    let data = vec![
        ("nonce", &nonce),
        // Add more parameters as needed
    ];
    //let post_data: String = form_urlencoded::Serializer::new(String::new())
    //    .extend_pairs(data)
    //    .finish();
    
    let url_path = "/0/public/Ticker?pair=XRPUSD";
    //let message = format!("{}{}{}", url_path, nonce, post_data);


    fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
    -> String {
        // Create the post data
        let post_data: String = form_urlencoded::Serializer::new(String::new())
            .extend_pairs(data)
            .finish();
        //FOR DEBUGGING
        //println!("Private key:\n{}", secret);
        //println!("Nonce:\n{}", nonce_str);
        //println!("Encoded payload:\n{}", post_data);
        //println!("URI Path:\n{}", url_path);
    
        // Create the encoded string (nonce + post data) and hash it
        let encoded = format!("{}{}", nonce_str, post_data);
        let mut hasher = sha2::Sha256::new();
        hasher.update(encoded);
        let encoded_hash = hasher.finalize();
    
        // Create the message (url_path + encoded_hash as bytes)
        let mut message = url_path.as_bytes().to_vec();
        message.extend_from_slice(&encoded_hash);
    
        // Create a HMAC-SHA512 object with the base64-decoded secret
        let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
            .expect("HMAC can take key of any size");
    
        // Compute the HMAC of the message
        mac.update(&message);
        let result = mac.finalize();
    
        // Return the base64-encoded HMAC
        let signature = base64::encode(result.into_bytes());
        //println!("Kraken signature:\n{}", signature);
    
        signature
    }


    
    let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

    //kraken asked for 3 headers: key, sign, and content type with its corresponding info
    //.body is nonce because in the Kraken code provided in cURL: 
    //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
    //--data-urlencode "nonce=<YOUR-NONCE>"
    //		this means that nonce is added to the body of the request
    //02/02/24 - removed:
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
        //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
        //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }
//02/02/24 - added in its place:
	//03/05/24 - changed to mut and = None;
    let mut kraken_buy_price_ask: Option<f64> = None;
    //let mut kraken_sell_price_bid: Option<f64> = None;
    let mut attempts = 0;

    loop {
        attempts += 1;
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            .header("API-Key", kraken_api_key)
            .header("API-Sign", &kraken_signature)
            .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            .body(format!("nonce={}", nonce))
            .build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

												match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
													(Some(ask_str), /*Some(bid_str)*/) => {
														match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
															(Ok(ask), /*Ok(bid)*/) => {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															_ => log::error!("i176: Kraken: Failed to parse ask or bid as f64"),
														}
													},
													_ => log::error!("i176: Kraken: Failed to get ask or bid as string"),
												}										
											}
											else {
												log::error!("i176: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i176: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i176: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i176: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i176: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}







    println!("xrp 6 kraken coinbase : 8 sec delay");
    let when = tokio::time::Instant::now() + Duration::from_secs(8);
    //02/09/21 - tokio update. changed from delay_until to sleep_until
    tokio::time::sleep_until(when).await;






    //------------COINBASE------------//
    let now = Utc::now();
    let time_stamp = now.timestamp().to_string();
    let method = "GET";
    let request_path = "/api/v3/brokerage/best_bid_ask";
    let body = "";
    let message = format!("{}{}{}{}", &time_stamp, 
    &method, &request_path, &body);
    type HmacSha256 = Hmac<Sha256>;
    fn sign(message: &str, coinbase_secret: &str) -> String {
    let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                .expect("HMAC can take key of any size");
    mac.update(message.as_bytes());
    let result = mac.finalize();
    let code_bytes = result.into_bytes();
    hex::encode(code_bytes)
    }
    let coinbase_signature = sign(&message, &coinbase_secret);

    //01/30/24 - added:
    //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
    //      instead, it will try to do any of the following things it failed 3 times.
    //      if it still doesn't work, then yeah panic.
        //new variables
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        let mut success = false;
    loop {
        attempts +=1;
        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build();
        //.expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};
        match request {
            Ok(req) => {
        //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                let response = client.execute(req).await;
                match response {
                    Ok(resp) => {
                        let response_text = resp.text().await;
                        match response_text {
                            Ok(text) => {
                                match serde_json::from_str::<Value>(&text) {
                                    Ok(v) => {
                                        if let Some(pricebooks) = v["pricebooks"].as_array() {
                                            for pricebook in pricebooks {
                                                //let product_id = pricebook["product_id"].as_str();
                                                let bids = &pricebook["bids"][0];
                                                //let asks = &pricebook["asks"][0];
                                                let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
    
                                                match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                    (Some(bid_str), /*Some(ask_str)*/) => {
                                                        match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                            (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                coinbase_sell_price_bid = Some(bid_str);
                                                                //coinbase_buy_price_ask = Some(ask_str);

                                                                // Place your calculations and updates here
                                                                    let kraken_taker_fee = 0.0026;
                                                                    let fraction_of_wallet_im_using = 0.06;  //aka 6 percent
                                                                    let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                    let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                    //03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;
                                                                    let amount_of_xrp_before_withdraw_fee = 
                                                                                    money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                        .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                        even though to get to this point it had to be Some. 
                                                                                        Kraken_buy_price_ask: {:?}
                                                                                        Honestly restart the program from the last saved state. 
                                                                                        The most likely error is a bit got flipped after the loop", 
                                                                                        &kraken_buy_price_ask));
                                                                    let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                    //coinbase calculations for sell

                                                                    let coinbase_taker_fee = 0.008;
                                                                    let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                    let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                    *coinbase_wallet += money_from_sell_after_fees;
                                                                    value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																	if let Some(mut value_after) = value_after {

																		//03/10/24 - added for unscaling
																		let value_after_unscaled = value_after;
																		let coinbase_wallet_unscaled = *coinbase_wallet;
																		let kraken_wallet_unscaled = *kraken_wallet;

																		*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is coinbase and kraken being updated, I will update:
																		//  56, 57, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 57, 59];
																		let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;

																		//03/09/24 - added for unscaling:
																		value_after = value_after_unscaled;
																		*coinbase_wallet = coinbase_wallet_unscaled;
																		*kraken_wallet = kraken_wallet_unscaled;

                                                                        //03/13/24 - added:
                                                                        return Ok(value_after);
																	}
																	//03/08/24 - removed:
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is coinbase and kraken being updated, I will update:
																	// //  56, 57, 59
																	// let indices = [56, 57, 59];
																	// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;

                                                                    success = true;
																},
																_ => {
																	log::error!("i176: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i176: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i176: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i176: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i176: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i176: Failed to build request");
					if attempts > 3 {
						panic!("i176: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


        //    let response_text = response.text().await.expect("Failed to build response_text from response");

        //    //added 12/29/23
        //    //this is the parsing
        //    //01/30/24 - improved error messages to be more detailed in let v: Value
        //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
        //    let mut coinbase_sell_price_bid = 0.0;
        //    let mut coinbase_buy_price_ask = 0.0;

        //    // Access the pricebooks array
        //    if let Some(pricebooks) = v["pricebooks"].as_array() {
        //        // Iterate over each pricebook
        //        for pricebook in pricebooks {
        //            // Access the product_id, bids, and asks
        //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //            let bids = &pricebook["bids"][0];
        //            let asks = &pricebook["asks"][0];
        //            // Access the price and size of the bids and asks
        //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
        //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
        //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
        //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
        //            //println!("Product ID: {}", product_id);
        //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //        }
        //    }
        //}
    //}








        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
        // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        // *kraken_wallet -= money_going_to_xrp_after_fees;
        // let amount_of_xrp_before_withdraw_fee = 
        //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
        // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;





        //coinbase calculations for sell

        // let coinbase_taker_fee = 0.008;
        // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *coinbase_wallet += money_from_sell_after_fees;
        // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is coinbase and kraken being updated, I will update:
        //     //  56, 57, 59
        //     let indices = [56, 57, 59];
        //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;


        match value_after {
            Some(value) => return Ok(value),
            None => {
                //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
            }
        }
	}

	pub async fn s_i177_xrp_7_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

    //---KRAKEN--//

    //basically Kraken requires a value that is always increasing to be in each request.
    //I didnt use now.timestamp().to_string()  because just in case I have 2 
    //	requests in a second I dont want to be penalized.
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time. MAY NEED TO USE LOCAL TIME
    let now = Utc::now();
    let nonce = now.timestamp_millis().to_string();
    let data = vec![
        ("nonce", &nonce),
        // Add more parameters as needed
    ];
    //let post_data: String = form_urlencoded::Serializer::new(String::new())
    //    .extend_pairs(data)
    //    .finish();
    
    let url_path = "/0/public/Ticker?pair=XRPUSD";
    //let message = format!("{}{}{}", url_path, nonce, post_data);


    fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
    -> String {
        // Create the post data
        let post_data: String = form_urlencoded::Serializer::new(String::new())
            .extend_pairs(data)
            .finish();
        //FOR DEBUGGING
        //println!("Private key:\n{}", secret);
        //println!("Nonce:\n{}", nonce_str);
        //println!("Encoded payload:\n{}", post_data);
        //println!("URI Path:\n{}", url_path);
    
        // Create the encoded string (nonce + post data) and hash it
        let encoded = format!("{}{}", nonce_str, post_data);
        let mut hasher = sha2::Sha256::new();
        hasher.update(encoded);
        let encoded_hash = hasher.finalize();
    
        // Create the message (url_path + encoded_hash as bytes)
        let mut message = url_path.as_bytes().to_vec();
        message.extend_from_slice(&encoded_hash);
    
        // Create a HMAC-SHA512 object with the base64-decoded secret
        let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
            .expect("HMAC can take key of any size");
    
        // Compute the HMAC of the message
        mac.update(&message);
        let result = mac.finalize();
    
        // Return the base64-encoded HMAC
        let signature = base64::encode(result.into_bytes());
        //println!("Kraken signature:\n{}", signature);
    
        signature
    }


    
    let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

    //kraken asked for 3 headers: key, sign, and content type with its corresponding info
    //.body is nonce because in the Kraken code provided in cURL: 
    //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
    //--data-urlencode "nonce=<YOUR-NONCE>"
    //		this means that nonce is added to the body of the request
    //02/02/24 - removed:
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
        //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
        //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }
//02/02/24 - added in its place:
	//03/05/24 - changed to mut and = None;
    let mut kraken_buy_price_ask: Option<f64> = None;
    //let mut kraken_sell_price_bid: Option<f64> = None;
    let mut attempts = 0;

    loop {
        attempts += 1;
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            .header("API-Key", kraken_api_key)
            .header("API-Sign", &kraken_signature)
            .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            .body(format!("nonce={}", nonce))
            .build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

												match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
													(Some(ask_str), /*Some(bid_str)*/) => {
														match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
															(Ok(ask), /*Ok(bid)*/) => {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															_ => log::error!("i177: Kraken: Failed to parse ask or bid as f64"),
														}
													},
													_ => log::error!("i177: Kraken: Failed to get ask or bid as string"),
												}										
											}
											else {
												log::error!("i177: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i177: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i177: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i177: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i177: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}







    println!("xrp 7 kraken coinbase : 8 sec delay");
    let when = tokio::time::Instant::now() + Duration::from_secs(8);
    //02/09/21 - tokio update. changed from delay_until to sleep_until
    tokio::time::sleep_until(when).await;






    //------------COINBASE------------//
    let now = Utc::now();
    let time_stamp = now.timestamp().to_string();
    let method = "GET";
    let request_path = "/api/v3/brokerage/best_bid_ask";
    let body = "";
    let message = format!("{}{}{}{}", &time_stamp, 
    &method, &request_path, &body);
    type HmacSha256 = Hmac<Sha256>;
    fn sign(message: &str, coinbase_secret: &str) -> String {
    let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                .expect("HMAC can take key of any size");
    mac.update(message.as_bytes());
    let result = mac.finalize();
    let code_bytes = result.into_bytes();
    hex::encode(code_bytes)
    }
    let coinbase_signature = sign(&message, &coinbase_secret);

    //01/30/24 - added:
    //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
    //      instead, it will try to do any of the following things it failed 3 times.
    //      if it still doesn't work, then yeah panic.
        //new variables
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        let mut success = false;
    loop {
        attempts +=1;
        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build();
        //.expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};
        match request {
            Ok(req) => {
        //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                let response = client.execute(req).await;
                match response {
                    Ok(resp) => {
                        let response_text = resp.text().await;
                        match response_text {
                            Ok(text) => {
                                match serde_json::from_str::<Value>(&text) {
                                    Ok(v) => {
                                        if let Some(pricebooks) = v["pricebooks"].as_array() {
                                            for pricebook in pricebooks {
                                                //let product_id = pricebook["product_id"].as_str();
                                                let bids = &pricebook["bids"][0];
                                                //let asks = &pricebook["asks"][0];
                                                let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
    
                                                match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                    (Some(bid_str), /*Some(ask_str)*/) => {
                                                        match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                            (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                coinbase_sell_price_bid = Some(bid_str);
                                                                //coinbase_buy_price_ask = Some(ask_str);

                                                                // Place your calculations and updates here
                                                                    let kraken_taker_fee = 0.0026;
                                                                    let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
                                                                    let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                    let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                    //03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;
                                                                    let amount_of_xrp_before_withdraw_fee = 
                                                                                    money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                        .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                        even though to get to this point it had to be Some. 
                                                                                        Kraken_buy_price_ask: {:?}
                                                                                        Honestly restart the program from the last saved state. 
                                                                                        The most likely error is a bit got flipped after the loop", 
                                                                                        &kraken_buy_price_ask));
                                                                    let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                    //coinbase calculations for sell

                                                                    let coinbase_taker_fee = 0.008;
                                                                    let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                    let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                    *coinbase_wallet += money_from_sell_after_fees;
                                                                    value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																	if let Some(mut value_after) = value_after {

																		//03/10/24 - added for unscaling
																		let value_after_unscaled = value_after;
																		let coinbase_wallet_unscaled = *coinbase_wallet;
																		let kraken_wallet_unscaled = *kraken_wallet;

																		*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is coinbase and kraken being updated, I will update:
																		//  56, 57, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 57, 59];
																		let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;

																		//03/09/24 - added for unscaling:
																		value_after = value_after_unscaled;
																		*coinbase_wallet = coinbase_wallet_unscaled;
																		*kraken_wallet = kraken_wallet_unscaled;

                                                                        //03/13/24 - added:
                                                                        return Ok(value_after);
																	}
																	//03/08/24 - removed:
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is coinbase and kraken being updated, I will update:
																	// //  56, 57, 59
																	// let indices = [56, 57, 59];
																	// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;

                                                                    success = true;
																},
																_ => {
																	log::error!("i177: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i177: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i177: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i177: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i177: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i177: Failed to build request");
					if attempts > 3 {
						panic!("i177: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


        //    let response_text = response.text().await.expect("Failed to build response_text from response");

        //    //added 12/29/23
        //    //this is the parsing
        //    //01/30/24 - improved error messages to be more detailed in let v: Value
        //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
        //    let mut coinbase_sell_price_bid = 0.0;
        //    let mut coinbase_buy_price_ask = 0.0;

        //    // Access the pricebooks array
        //    if let Some(pricebooks) = v["pricebooks"].as_array() {
        //        // Iterate over each pricebook
        //        for pricebook in pricebooks {
        //            // Access the product_id, bids, and asks
        //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //            let bids = &pricebook["bids"][0];
        //            let asks = &pricebook["asks"][0];
        //            // Access the price and size of the bids and asks
        //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
        //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
        //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
        //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
        //            //println!("Product ID: {}", product_id);
        //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //        }
        //    }
        //}
    //}








        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
        // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        // *kraken_wallet -= money_going_to_xrp_after_fees;
        // let amount_of_xrp_before_withdraw_fee = 
        //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
        // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;





        //coinbase calculations for sell

        // let coinbase_taker_fee = 0.008;
        // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *coinbase_wallet += money_from_sell_after_fees;
        // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is coinbase and kraken being updated, I will update:
        //     //  56, 57, 59
        //     let indices = [56, 57, 59];
        //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;


        match value_after {
            Some(value) => return Ok(value),
            None => {
                //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
            }
        }
	}

	pub async fn s_i178_xrp_8_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

    //---KRAKEN--//

    //basically Kraken requires a value that is always increasing to be in each request.
    //I didnt use now.timestamp().to_string()  because just in case I have 2 
    //	requests in a second I dont want to be penalized.
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time. MAY NEED TO USE LOCAL TIME
    let now = Utc::now();
    let nonce = now.timestamp_millis().to_string();
    let data = vec![
        ("nonce", &nonce),
        // Add more parameters as needed
    ];
    //let post_data: String = form_urlencoded::Serializer::new(String::new())
    //    .extend_pairs(data)
    //    .finish();
    
    let url_path = "/0/public/Ticker?pair=XRPUSD";
    //let message = format!("{}{}{}", url_path, nonce, post_data);


    fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
    -> String {
        // Create the post data
        let post_data: String = form_urlencoded::Serializer::new(String::new())
            .extend_pairs(data)
            .finish();
        //FOR DEBUGGING
        //println!("Private key:\n{}", secret);
        //println!("Nonce:\n{}", nonce_str);
        //println!("Encoded payload:\n{}", post_data);
        //println!("URI Path:\n{}", url_path);
    
        // Create the encoded string (nonce + post data) and hash it
        let encoded = format!("{}{}", nonce_str, post_data);
        let mut hasher = sha2::Sha256::new();
        hasher.update(encoded);
        let encoded_hash = hasher.finalize();
    
        // Create the message (url_path + encoded_hash as bytes)
        let mut message = url_path.as_bytes().to_vec();
        message.extend_from_slice(&encoded_hash);
    
        // Create a HMAC-SHA512 object with the base64-decoded secret
        let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
            .expect("HMAC can take key of any size");
    
        // Compute the HMAC of the message
        mac.update(&message);
        let result = mac.finalize();
    
        // Return the base64-encoded HMAC
        let signature = base64::encode(result.into_bytes());
        //println!("Kraken signature:\n{}", signature);
    
        signature
    }


    
    let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

    //kraken asked for 3 headers: key, sign, and content type with its corresponding info
    //.body is nonce because in the Kraken code provided in cURL: 
    //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
    //--data-urlencode "nonce=<YOUR-NONCE>"
    //		this means that nonce is added to the body of the request
    //02/02/24 - removed:
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
        //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
        //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }
//02/02/24 - added in its place:
	//03/05/24 - changed to mut and = None;
    let mut kraken_buy_price_ask: Option<f64> = None;
    //let mut kraken_sell_price_bid: Option<f64> = None;
    let mut attempts = 0;

    loop {
        attempts += 1;
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            .header("API-Key", kraken_api_key)
            .header("API-Sign", &kraken_signature)
            .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            .body(format!("nonce={}", nonce))
            .build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

												match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
													(Some(ask_str), /*Some(bid_str)*/) => {
														match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
															(Ok(ask), /*Ok(bid)*/) => {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															_ => log::error!("i178: Kraken: Failed to parse ask or bid as f64"),
														}
													},
													_ => log::error!("i178: Kraken: Failed to get ask or bid as string"),
												}										
											}
											else {
												log::error!("i178: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i178: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i178: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i178: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i178: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}







    println!("xrp 8 kraken coinbase : 8 sec delay");
    let when = tokio::time::Instant::now() + Duration::from_secs(8);
    //02/09/21 - tokio update. changed from delay_until to sleep_until
    tokio::time::sleep_until(when).await;






    //------------COINBASE------------//
    let now = Utc::now();
    let time_stamp = now.timestamp().to_string();
    let method = "GET";
    let request_path = "/api/v3/brokerage/best_bid_ask";
    let body = "";
    let message = format!("{}{}{}{}", &time_stamp, 
    &method, &request_path, &body);
    type HmacSha256 = Hmac<Sha256>;
    fn sign(message: &str, coinbase_secret: &str) -> String {
    let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                .expect("HMAC can take key of any size");
    mac.update(message.as_bytes());
    let result = mac.finalize();
    let code_bytes = result.into_bytes();
    hex::encode(code_bytes)
    }
    let coinbase_signature = sign(&message, &coinbase_secret);

    //01/30/24 - added:
    //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
    //      instead, it will try to do any of the following things it failed 3 times.
    //      if it still doesn't work, then yeah panic.
        //new variables
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        let mut success = false;
    loop {
        attempts +=1;
        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build();
        //.expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};
        match request {
            Ok(req) => {
        //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                let response = client.execute(req).await;
                match response {
                    Ok(resp) => {
                        let response_text = resp.text().await;
                        match response_text {
                            Ok(text) => {
                                match serde_json::from_str::<Value>(&text) {
                                    Ok(v) => {
                                        if let Some(pricebooks) = v["pricebooks"].as_array() {
                                            for pricebook in pricebooks {
                                                //let product_id = pricebook["product_id"].as_str();
                                                let bids = &pricebook["bids"][0];
                                                //let asks = &pricebook["asks"][0];
                                                let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
    
                                                match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                    (Some(bid_str), /*Some(ask_str)*/) => {
                                                        match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                            (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                coinbase_sell_price_bid = Some(bid_str);
                                                                //coinbase_buy_price_ask = Some(ask_str);

                                                                // Place your calculations and updates here
                                                                    let kraken_taker_fee = 0.0026;
                                                                    let fraction_of_wallet_im_using = 0.08;  //aka 8 percent
                                                                    let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                    let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                    //03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;
                                                                    let amount_of_xrp_before_withdraw_fee = 
                                                                                    money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                        .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                        even though to get to this point it had to be Some. 
                                                                                        Kraken_buy_price_ask: {:?}
                                                                                        Honestly restart the program from the last saved state. 
                                                                                        The most likely error is a bit got flipped after the loop", 
                                                                                        &kraken_buy_price_ask));
                                                                    let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                    //coinbase calculations for sell

                                                                    let coinbase_taker_fee = 0.008;
                                                                    let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                    let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                    *coinbase_wallet += money_from_sell_after_fees;
                                                                    value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																	if let Some(mut value_after) = value_after {

																		//03/10/24 - added for unscaling
																		let value_after_unscaled = value_after;
																		let coinbase_wallet_unscaled = *coinbase_wallet;
																		let kraken_wallet_unscaled = *kraken_wallet;

																		*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is coinbase and kraken being updated, I will update:
																		//  56, 57, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 57, 59];
																		let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;

																		//03/09/24 - added for unscaling:
																		value_after = value_after_unscaled;
																		*coinbase_wallet = coinbase_wallet_unscaled;
																		*kraken_wallet = kraken_wallet_unscaled;

                                                                        //03/13/24 - added:
                                                                        return Ok(value_after);
																	}
																	//03/08/24 - removed:
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is coinbase and kraken being updated, I will update:
																	// //  56, 57, 59
																	// let indices = [56, 57, 59];
																	// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;

                                                                    success = true;
																},
																_ => {
																	log::error!("i178: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i178: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i178: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i178: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i178: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i178: Failed to build request");
					if attempts > 3 {
						panic!("i178: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


        //    let response_text = response.text().await.expect("Failed to build response_text from response");

        //    //added 12/29/23
        //    //this is the parsing
        //    //01/30/24 - improved error messages to be more detailed in let v: Value
        //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
        //    let mut coinbase_sell_price_bid = 0.0;
        //    let mut coinbase_buy_price_ask = 0.0;

        //    // Access the pricebooks array
        //    if let Some(pricebooks) = v["pricebooks"].as_array() {
        //        // Iterate over each pricebook
        //        for pricebook in pricebooks {
        //            // Access the product_id, bids, and asks
        //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //            let bids = &pricebook["bids"][0];
        //            let asks = &pricebook["asks"][0];
        //            // Access the price and size of the bids and asks
        //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
        //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
        //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
        //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
        //            //println!("Product ID: {}", product_id);
        //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //        }
        //    }
        //}
    //}








        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
        // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        // *kraken_wallet -= money_going_to_xrp_after_fees;
        // let amount_of_xrp_before_withdraw_fee = 
        //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
        // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;





        //coinbase calculations for sell

        // let coinbase_taker_fee = 0.008;
        // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *coinbase_wallet += money_from_sell_after_fees;
        // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is coinbase and kraken being updated, I will update:
        //     //  56, 57, 59
        //     let indices = [56, 57, 59];
        //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;


        match value_after {
            Some(value) => return Ok(value),
            None => {
                //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
            }
        }
	}

	pub async fn s_i179_xrp_9_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

    //---KRAKEN--//

    //basically Kraken requires a value that is always increasing to be in each request.
    //I didnt use now.timestamp().to_string()  because just in case I have 2 
    //	requests in a second I dont want to be penalized.
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time. MAY NEED TO USE LOCAL TIME
    let now = Utc::now();
    let nonce = now.timestamp_millis().to_string();
    let data = vec![
        ("nonce", &nonce),
        // Add more parameters as needed
    ];
    //let post_data: String = form_urlencoded::Serializer::new(String::new())
    //    .extend_pairs(data)
    //    .finish();
    
    let url_path = "/0/public/Ticker?pair=XRPUSD";
    //let message = format!("{}{}{}", url_path, nonce, post_data);


    fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
    -> String {
        // Create the post data
        let post_data: String = form_urlencoded::Serializer::new(String::new())
            .extend_pairs(data)
            .finish();
        //FOR DEBUGGING
        //println!("Private key:\n{}", secret);
        //println!("Nonce:\n{}", nonce_str);
        //println!("Encoded payload:\n{}", post_data);
        //println!("URI Path:\n{}", url_path);
    
        // Create the encoded string (nonce + post data) and hash it
        let encoded = format!("{}{}", nonce_str, post_data);
        let mut hasher = sha2::Sha256::new();
        hasher.update(encoded);
        let encoded_hash = hasher.finalize();
    
        // Create the message (url_path + encoded_hash as bytes)
        let mut message = url_path.as_bytes().to_vec();
        message.extend_from_slice(&encoded_hash);
    
        // Create a HMAC-SHA512 object with the base64-decoded secret
        let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
            .expect("HMAC can take key of any size");
    
        // Compute the HMAC of the message
        mac.update(&message);
        let result = mac.finalize();
    
        // Return the base64-encoded HMAC
        let signature = base64::encode(result.into_bytes());
        //println!("Kraken signature:\n{}", signature);
    
        signature
    }


    
    let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

    //kraken asked for 3 headers: key, sign, and content type with its corresponding info
    //.body is nonce because in the Kraken code provided in cURL: 
    //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
    //--data-urlencode "nonce=<YOUR-NONCE>"
    //		this means that nonce is added to the body of the request
    //02/02/24 - removed:
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
        //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
        //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }
//02/02/24 - added in its place:
	//03/05/24 - changed to mut and = None;
    let mut kraken_buy_price_ask: Option<f64> = None;
    //let mut kraken_sell_price_bid: Option<f64> = None;
    let mut attempts = 0;

    loop {
        attempts += 1;
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            .header("API-Key", kraken_api_key)
            .header("API-Sign", &kraken_signature)
            .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            .body(format!("nonce={}", nonce))
            .build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

												match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
													(Some(ask_str), /*Some(bid_str)*/) => {
														match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
															(Ok(ask), /*Ok(bid)*/) => {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															_ => log::error!("i179: Kraken: Failed to parse ask or bid as f64"),
														}
													},
													_ => log::error!("i179: Kraken: Failed to get ask or bid as string"),
												}										
											}
											else {
												log::error!("i179: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i179: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i179: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i179: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i179: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}







    println!("xrp 9 kraken coinbase : 8 sec delay");
    let when = tokio::time::Instant::now() + Duration::from_secs(8);
    //02/09/21 - tokio update. changed from delay_until to sleep_until
    tokio::time::sleep_until(when).await;






    //------------COINBASE------------//
    let now = Utc::now();
    let time_stamp = now.timestamp().to_string();
    let method = "GET";
    let request_path = "/api/v3/brokerage/best_bid_ask";
    let body = "";
    let message = format!("{}{}{}{}", &time_stamp, 
    &method, &request_path, &body);
    type HmacSha256 = Hmac<Sha256>;
    fn sign(message: &str, coinbase_secret: &str) -> String {
    let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                .expect("HMAC can take key of any size");
    mac.update(message.as_bytes());
    let result = mac.finalize();
    let code_bytes = result.into_bytes();
    hex::encode(code_bytes)
    }
    let coinbase_signature = sign(&message, &coinbase_secret);

    //01/30/24 - added:
    //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
    //      instead, it will try to do any of the following things it failed 3 times.
    //      if it still doesn't work, then yeah panic.
        //new variables
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        let mut success = false;
    loop {
        attempts +=1;
        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build();
        //.expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};
        match request {
            Ok(req) => {
        //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                let response = client.execute(req).await;
                match response {
                    Ok(resp) => {
                        let response_text = resp.text().await;
                        match response_text {
                            Ok(text) => {
                                match serde_json::from_str::<Value>(&text) {
                                    Ok(v) => {
                                        if let Some(pricebooks) = v["pricebooks"].as_array() {
                                            for pricebook in pricebooks {
                                                //let product_id = pricebook["product_id"].as_str();
                                                let bids = &pricebook["bids"][0];
                                                //let asks = &pricebook["asks"][0];
                                                let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
    
                                                match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                    (Some(bid_str), /*Some(ask_str)*/) => {
                                                        match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                            (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                coinbase_sell_price_bid = Some(bid_str);
                                                                //coinbase_buy_price_ask = Some(ask_str);

                                                                // Place your calculations and updates here
                                                                    let kraken_taker_fee = 0.0026;
                                                                    let fraction_of_wallet_im_using = 0.09;  //aka 9 percent
                                                                    let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                    let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                    //03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;
                                                                    let amount_of_xrp_before_withdraw_fee = 
                                                                                    money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                        .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                        even though to get to this point it had to be Some. 
                                                                                        Kraken_buy_price_ask: {:?}
                                                                                        Honestly restart the program from the last saved state. 
                                                                                        The most likely error is a bit got flipped after the loop", 
                                                                                        &kraken_buy_price_ask));
                                                                    let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                    //coinbase calculations for sell

                                                                    let coinbase_taker_fee = 0.008;
                                                                    let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                    let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                    *coinbase_wallet += money_from_sell_after_fees;
                                                                    value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																	if let Some(mut value_after) = value_after {

																		//03/10/24 - added for unscaling
																		let value_after_unscaled = value_after;
																		let coinbase_wallet_unscaled = *coinbase_wallet;
																		let kraken_wallet_unscaled = *kraken_wallet;

																		*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is coinbase and kraken being updated, I will update:
																		//  56, 57, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 57, 59];
																		let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;

																		//03/09/24 - added for unscaling:
																		value_after = value_after_unscaled;
																		*coinbase_wallet = coinbase_wallet_unscaled;
																		*kraken_wallet = kraken_wallet_unscaled;

                                                                        //03/13/24 - added:
                                                                        return Ok(value_after);
																	}
																	//03/08/24 - removed:
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is coinbase and kraken being updated, I will update:
																	// //  56, 57, 59
																	// let indices = [56, 57, 59];
																	// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;

                                                                    success = true;
																},
																_ => {
																	log::error!("i179: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i179: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i179: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i179: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i179: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i179: Failed to build request");
					if attempts > 3 {
						panic!("i179: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


        //    let response_text = response.text().await.expect("Failed to build response_text from response");

        //    //added 12/29/23
        //    //this is the parsing
        //    //01/30/24 - improved error messages to be more detailed in let v: Value
        //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
        //    let mut coinbase_sell_price_bid = 0.0;
        //    let mut coinbase_buy_price_ask = 0.0;

        //    // Access the pricebooks array
        //    if let Some(pricebooks) = v["pricebooks"].as_array() {
        //        // Iterate over each pricebook
        //        for pricebook in pricebooks {
        //            // Access the product_id, bids, and asks
        //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //            let bids = &pricebook["bids"][0];
        //            let asks = &pricebook["asks"][0];
        //            // Access the price and size of the bids and asks
        //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
        //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
        //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
        //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
        //            //println!("Product ID: {}", product_id);
        //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //        }
        //    }
        //}
    //}








        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
        // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        // *kraken_wallet -= money_going_to_xrp_after_fees;
        // let amount_of_xrp_before_withdraw_fee = 
        //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
        // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;





        //coinbase calculations for sell

        // let coinbase_taker_fee = 0.008;
        // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *coinbase_wallet += money_from_sell_after_fees;
        // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is coinbase and kraken being updated, I will update:
        //     //  56, 57, 59
        //     let indices = [56, 57, 59];
        //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;


        match value_after {
            Some(value) => return Ok(value),
            None => {
                //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
            }
        }
	}

	pub async fn s_i180_xrp_10_kraken_coinbase( coinbase_wallet: &mut f64, kraken_wallet: &mut f64, bitstamp_wallet: &f64,
		gemini_wallet: &f64, coinbase_secret: &str, coinbase_api_key: &str, client: reqwest::Client, kraken_secret: &str, kraken_api_key: &str, neural_network: &mut NeuralNetwork)-> Result<f64, Box<dyn Error + Send>> {

    //---KRAKEN--//

    //basically Kraken requires a value that is always increasing to be in each request.
    //I didnt use now.timestamp().to_string()  because just in case I have 2 
    //	requests in a second I dont want to be penalized.
    //if no "now" in scope when moving file, 
    //	the code is this:
    ////returns current time. MAY NEED TO USE LOCAL TIME
    let now = Utc::now();
    let nonce = now.timestamp_millis().to_string();
    let data = vec![
        ("nonce", &nonce),
        // Add more parameters as needed
    ];
    //let post_data: String = form_urlencoded::Serializer::new(String::new())
    //    .extend_pairs(data)
    //    .finish();
    
    let url_path = "/0/public/Ticker?pair=XRPUSD";
    //let message = format!("{}{}{}", url_path, nonce, post_data);


    fn sign_kraken(url_path: &str, nonce_str: &str, data: Vec<(&str, &String)>, secret: &str) 
    -> String {
        // Create the post data
        let post_data: String = form_urlencoded::Serializer::new(String::new())
            .extend_pairs(data)
            .finish();
        //FOR DEBUGGING
        //println!("Private key:\n{}", secret);
        //println!("Nonce:\n{}", nonce_str);
        //println!("Encoded payload:\n{}", post_data);
        //println!("URI Path:\n{}", url_path);
    
        // Create the encoded string (nonce + post data) and hash it
        let encoded = format!("{}{}", nonce_str, post_data);
        let mut hasher = sha2::Sha256::new();
        hasher.update(encoded);
        let encoded_hash = hasher.finalize();
    
        // Create the message (url_path + encoded_hash as bytes)
        let mut message = url_path.as_bytes().to_vec();
        message.extend_from_slice(&encoded_hash);
    
        // Create a HMAC-SHA512 object with the base64-decoded secret
        let secret_decoded = base64::decode(secret).expect("Failed to decode secret");
        let mut mac = Hmac::<Sha512>::new_from_slice(&secret_decoded)
            .expect("HMAC can take key of any size");
    
        // Compute the HMAC of the message
        mac.update(&message);
        let result = mac.finalize();
    
        // Return the base64-encoded HMAC
        let signature = base64::encode(result.into_bytes());
        //println!("Kraken signature:\n{}", signature);
    
        signature
    }


    
    let kraken_signature = sign_kraken(&url_path, &nonce, data, &kraken_secret);

    //kraken asked for 3 headers: key, sign, and content type with its corresponding info
    //.body is nonce because in the Kraken code provided in cURL: 
    //https://docs.kraken.com/rest/#tag/Account-Data/operation/getAccountBalance
    //--data-urlencode "nonce=<YOUR-NONCE>"
    //		this means that nonce is added to the body of the request
    //02/02/24 - removed:
        // let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
        //         .header("API-Key", kraken_api_key)
        //         .header("API-Sign", &kraken_signature)
        //         .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
        //         .body(format!("nonce={}", nonce))
        //         .build()
        //         .expect("Failed to build kraken request");


        // let kraken_response = client.execute(kraken_basic_request).await.expect("Failed to execute Kraken request");

        // let kraken_response_text = kraken_response.text().await.expect("Failed to read response text");
        
        // //println!("kraken response:{}", kraken_response_text);

        // let v: Value = serde_json::from_str(&kraken_response_text).expect("getting value didnt work");
        // let mut kraken_buy_price_ask = 0.0;
        // let mut kraken_sell_price_bid = 0.0;
        // if let Some(xrpusd) = v["result"]["XXRPZUSD"].as_object() {
        //     // Access the ask and bid prices
        //     kraken_buy_price_ask = xrpusd["a"][0].as_str().unwrap().parse::<f64>().unwrap();
        //     kraken_sell_price_bid = xrpusd["b"][0].as_str().unwrap().parse::<f64>().unwrap();
        
        //     //println!("XRP kraken buy  price Ask price: {}", kraken_buy_price_ask);
        //     //println!("xrp Bid price: {}", kraken_sell_price_bid );
        // }
        // else {
        //     println!("didnt parse kraken correctly.");
        // }
//02/02/24 - added in its place:
	//03/05/24 - changed to mut and = None;
    let mut kraken_buy_price_ask: Option<f64> = None;
    //let mut kraken_sell_price_bid: Option<f64> = None;
    let mut attempts = 0;

    loop {
        attempts += 1;
        let kraken_basic_request = client.get("https://api.kraken.com/0/public/Ticker?pair=XRPUSD")
            .header("API-Key", kraken_api_key)
            .header("API-Sign", &kraken_signature)
            .header("Content-Type", "application/x-www-form-urlencoded; charset=utf-8")
            .body(format!("nonce={}", nonce))
            .build();

			match kraken_basic_request {
				Ok(request) => {
					match client.execute(request).await {
						Ok(response) => {
							match response.text().await {
								Ok(kraken_response_text) => {
									match serde_json::from_str::<Value>(&kraken_response_text) {
										Ok(value) => {
											if let Some(xrpusd) = value["result"]["XXRPZUSD"].as_object() {

												match (xrpusd["a"][0].as_str(), /*solusd["b"][0].as_str()*/) {
													(Some(ask_str), /*Some(bid_str)*/) => {
														match (ask_str.parse::<f64>(), /*bid_str.parse::<f64>()*/) {
															(Ok(ask), /*Ok(bid)*/) => {
																kraken_buy_price_ask = Some(ask);
																//kraken_sell_price_bid = Some(bid);

																//03/05/24 - dont think this break is necessary
																//break; // Exit the loop if everything is successful
															},
															_ => log::error!("i180: Kraken: Failed to parse ask or bid as f64"),
														}
													},
													_ => log::error!("i180: Kraken: Failed to get ask or bid as string"),
												}										
											}
											else {
												log::error!("i180: Kraken: Didn't parse Kraken correctly. Response text was: {}", kraken_response_text);
											}
										},
										Err(e) => log::error!("i180: Kraken: Failed to parse JSON. Error was: {}. Response text was: {}", e, kraken_response_text),
									}
								},
								Err(e) => log::error!("i180: Kraken: Failed to read response text. Error was: {}", e),
							}
						},
						Err(e) => log::error!("i180: Kraken: Failed to execute Kraken request. Error was: {}", e),
					}
				},
				Err(e) => log::error!("i180: Kraken: Failed to build kraken request. Error was: {}", e),
			}
			if /*kraken_sell_price_bid.is_some() &&*/ kraken_buy_price_ask.is_some() {
				break; // Exit the loop if everything is successful
			}

			attempts += 1;
			if attempts >= 3 {
				panic!("Failed after 3 attempts");
			}
		}







    println!("xrp 10 kraken coinbase : 8 sec delay");
    let when = tokio::time::Instant::now() + Duration::from_secs(8);
    //02/09/21 - tokio update. changed from delay_until to sleep_until
    tokio::time::sleep_until(when).await;






    //------------COINBASE------------//
    let now = Utc::now();
    let time_stamp = now.timestamp().to_string();
    let method = "GET";
    let request_path = "/api/v3/brokerage/best_bid_ask";
    let body = "";
    let message = format!("{}{}{}{}", &time_stamp, 
    &method, &request_path, &body);
    type HmacSha256 = Hmac<Sha256>;
    fn sign(message: &str, coinbase_secret: &str) -> String {
    let mut mac = HmacSha256::new_from_slice(&coinbase_secret.as_bytes())
                .expect("HMAC can take key of any size");
    mac.update(message.as_bytes());
    let result = mac.finalize();
    let code_bytes = result.into_bytes();
    hex::encode(code_bytes)
    }
    let coinbase_signature = sign(&message, &coinbase_secret);

    //01/30/24 - added:
    //THIS IS WHERE i WILL BEGIN TO DO A LOOP so that it doesn't panic immediately when it encounters an error,
    //      instead, it will try to do any of the following things it failed 3 times.
    //      if it still doesn't work, then yeah panic.
        //new variables
        let mut attempts = 0;
        let mut coinbase_sell_price_bid: Option<f64> = None;
        //let coinbase_buy_price_ask: Option<f64>;
        let mut value_after: Option<f64> = None;
        //03/02/24 - changed to false
        let mut success = false;
    loop {
        attempts +=1;
        let request = client.get("https://api.coinbase.com/api/v3/brokerage/best_bid_ask?product_ids=XRP-USD")
        .header("CB-ACCESS-KEY", coinbase_api_key)
        .header("CB-ACCESS-SIGN", &coinbase_signature)
        .header("CB-ACCESS-TIMESTAMP", &time_stamp)
        .build();
        //.expect("couldn't build request");
        //manages the error I described above
        //let request = match request {
        //Ok(req) => req,
        //Err(e) => {
        //eprintln!("Failed to build request: \n{}", e);
        //return Err(e);
        //}
        //};
        match request {
            Ok(req) => {
        //      response_text, v, coinbase_sell_price_bid, coinbase_buy_price_ask, bid/ask size
                let response = client.execute(req).await;
                match response {
                    Ok(resp) => {
                        let response_text = resp.text().await;
                        match response_text {
                            Ok(text) => {
                                match serde_json::from_str::<Value>(&text) {
                                    Ok(v) => {
                                        if let Some(pricebooks) = v["pricebooks"].as_array() {
                                            for pricebook in pricebooks {
                                                //let product_id = pricebook["product_id"].as_str();
                                                let bids = &pricebook["bids"][0];
                                                //let asks = &pricebook["asks"][0];
                                                let before_parse_coinbase_sell_price_bid = bids["price"].as_str();
                                                //let before_parse_coinbase_buy_price_ask = asks["price"].as_str();
    
                                                match (before_parse_coinbase_sell_price_bid, /*before_parse_coinbase_buy_price_ask*/) {
                                                    (Some(bid_str), /*Some(ask_str)*/) => {
                                                        match (bid_str.parse::<f64>(), /*ask_str.parse::<f64>()*/) {
                                                            (Ok(bid_str), /*Ok(ask_str)*/) => {
                                                                coinbase_sell_price_bid = Some(bid_str);
                                                                //coinbase_buy_price_ask = Some(ask_str);

                                                                // Place your calculations and updates here
                                                                    let kraken_taker_fee = 0.0026;
                                                                    let fraction_of_wallet_im_using = 0.10;  //aka 10 percent
                                                                    let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
                                                                    let fee_for_purchase = total_spent*kraken_taker_fee;
                                                                    let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
                                                                    //03/05/24 - changed from -= money_going_to_sol_after_fees to
																	//				  total_spent;
																	*kraken_wallet -= total_spent;
                                                                    let amount_of_xrp_before_withdraw_fee = 
                                                                                    money_going_to_xrp_after_fees/kraken_buy_price_ask
                                                                                        .expect(&format!("kraken_buy_price_ask is somehow Not Some. 
                                                                                        even though to get to this point it had to be Some. 
                                                                                        Kraken_buy_price_ask: {:?}
                                                                                        Honestly restart the program from the last saved state. 
                                                                                        The most likely error is a bit got flipped after the loop", 
                                                                                        &kraken_buy_price_ask));
                                                                    let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;

                                                                    //coinbase calculations for sell

                                                                    let coinbase_taker_fee = 0.008;
                                                                    let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid.unwrap();
                                                                    let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
                                                                    let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
                                                                    *coinbase_wallet += money_from_sell_after_fees;
                                                                    value_after = Some(*kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet);
																	if let Some(mut value_after) = value_after {

																		//03/10/24 - added for unscaling
																		let value_after_unscaled = value_after;
																		let coinbase_wallet_unscaled = *coinbase_wallet;
																		let kraken_wallet_unscaled = *kraken_wallet;

																		*coinbase_wallet = standardization_functions::normal_wallet_standardization(&coinbase_wallet);
																		*kraken_wallet = standardization_functions::normal_wallet_standardization(&kraken_wallet);
																		value_after = standardization_functions::normal_value_prior_standardization(&value_after);
																		
																		//value_after = 56
																		//coinbase = 57
																		//bitstamp = 58
																		//kraken = 59
																		//gemini = 60
																		//since this is coinbase and kraken being updated, I will update:
																		//  56, 57, 59
																		//IT MUST BE ONE TO ONE. IN ORDER. so if Im changing coinbase_wallet 2nd, i need to put in 2nd place 57
																		let indices = [56, 57, 59];
																		let scaled_values = [value_after, *coinbase_wallet, *kraken_wallet];
																		//let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																		neural_network.update_input(&indices, &scaled_values).await;

																		//03/09/24 - added for unscaling:
																		value_after = value_after_unscaled;
																		*coinbase_wallet = coinbase_wallet_unscaled;
																		*kraken_wallet = kraken_wallet_unscaled;

                                                                        //03/13/24 - added:
                                                                        return Ok(value_after);
																	}
																	//03/08/24 - removed:
																	// //value_after = 56
																	// //coinbase = 57
																	// //bitstamp = 58
																	// //kraken = 59
																	// //gemini = 60
																	// //since this is coinbase and kraken being updated, I will update:
																	// //  56, 57, 59
																	// let indices = [56, 57, 59];
																	// let new_values = [value_after, Some(*coinbase_wallet), Some(*kraken_wallet)];
																	// let scaled_values: Vec<f64> = new_values.iter().map(|&x| x.unwrap() / divisor).collect();
																	// neural_network.update_input(&indices, &scaled_values).await;

                                                                    success = true;
																},
																_ => {
																	log::error!("i180: failed to parse JSON to f64");
																	if attempts > 3 {
																		panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
																	}
																	continue ;
																}
															}
														},
														_ => {
															log::error!("i180: Failed to get bid");
															if attempts > 3 {
																panic!("Failed to get bid after 3 attempts. Bid: {:?}", before_parse_coinbase_sell_price_bid);
															}
															continue ;
														}
													}
												}
											}
										},
										Err(_) => {
											log::error!("i180: failed to parse JSON as str");
											if attempts > 3 {
												panic!("Failed to parse JSON after 3 attempts. Response text: {}", text);
											}
											continue ; // Continue to the next iteration if parsing fails
										}
									}
								},
								Err(_) => {
									log::error!("i180: failed to get response text");
									if attempts > 3 {
										panic!("Failed to get response text after 3 attempts");
									}
									continue ; // Continue to the next iteration if getting response text fails
								}
							}
						},
						Err(_) => {
							log::error!("i180: Failed to execute request");
							if attempts > 3 {
								panic!("Failed to execute request after 3 attempts");
							}
							continue; // Continue to the next iteration if executing request fails
						}
					}
				},
				Err(_) => {
					log::error!("i180: Failed to build request");
					if attempts > 3 {
						panic!("i180: Failed to build request after 3 attempts");
					}
					continue; // Continue to the next iteration if building request fails
				}
			}
			if success == true {
				break;
			}
		}
            //let response = match response {
            //    Ok(resp) => resp,
            //    Err(e) => {
            //        eprintln!("Failed to execute request: \n{}", e);
            //        return Err(e);
            //    }
            //};


        //    let response_text = response.text().await.expect("Failed to build response_text from response");

        //    //added 12/29/23
        //    //this is the parsing
        //    //01/30/24 - improved error messages to be more detailed in let v: Value
        //    let v: Value = serde_json::from_str(&response_text).expect(&format!("Failed to parse response_text into serde_json format: {}", response_text));
        //    let mut coinbase_sell_price_bid = 0.0;
        //    let mut coinbase_buy_price_ask = 0.0;

        //    // Access the pricebooks array
        //    if let Some(pricebooks) = v["pricebooks"].as_array() {
        //        // Iterate over each pricebook
        //        for pricebook in pricebooks {
        //            // Access the product_id, bids, and asks
        //            let product_id = pricebook["product_id"].as_str().expect(&format!("couldn't get product_id. pricebook: {:?}", pricebook));
        //            let bids = &pricebook["bids"][0];
        //            let asks = &pricebook["asks"][0];
        //            // Access the price and size of the bids and asks
        //            coinbase_sell_price_bid = bids["price"].as_str().expect(&format!("Could not find bids[price] in {:?}", &bids))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Bids: {:?}", &bids));
        //            let bid_size = bids["size"].as_str().expect(&format!("Could not find bids[size] in {:?}", &bids));
        //            coinbase_buy_price_ask = asks["price"].as_str().expect(&format!("Could not find asks[price] in {:?}", &asks))
        //                .parse::<f64>().expect(&format!("Could not parse to f64. Asks: {:?}", &asks));
        //            let ask_size = asks["size"].as_str().expect(&format!("Could not find asks[size] in {:?}", &asks));
        //            //println!("Product ID: {}", product_id);
        //            //println!("Best bid: {} (size: {})", coinbase_sell_price_bid, bid_size);
        //            //println!("Best ask: {} (size: {})", coinbase_buy_price_ask, ask_size);
        //        }
        //    }
        //}
    //}








        // //kraken calculations - buy
        // let kraken_taker_fee = 0.0026;
        // let fraction_of_wallet_im_using = 0.07;  //aka 7 percent
        // let total_spent = fraction_of_wallet_im_using*(*kraken_wallet);
        // let fee_for_purchase = total_spent*kraken_taker_fee;
        // let money_going_to_xrp_after_fees = total_spent - fee_for_purchase;
        // *kraken_wallet -= money_going_to_xrp_after_fees;
        // let amount_of_xrp_before_withdraw_fee = 
        //                 money_going_to_xrp_after_fees/kraken_buy_price_ask;
        // let amount_of_xrp = amount_of_xrp_before_withdraw_fee - 0.2;





        //coinbase calculations for sell

        // let coinbase_taker_fee = 0.008;
        // let money_from_sell_before_fees = amount_of_xrp * coinbase_sell_price_bid;
        // let fee_for_sell = money_from_sell_before_fees * coinbase_taker_fee;
        // let money_from_sell_after_fees = money_from_sell_before_fees - fee_for_sell;
        // *coinbase_wallet += money_from_sell_after_fees;
        // let value_after = *kraken_wallet + *coinbase_wallet + gemini_wallet + bitstamp_wallet;
        // //println!("sol1_kraken_coinbase\tvalue after\n\t{}", value_after);


        //     //value_after = 56
        //     //coinbase = 57
        //     //bitstamp = 58
        //     //kraken = 59
        //     //gemini = 60
        //     //since this is coinbase and kraken being updated, I will update:
        //     //  56, 57, 59
        //     let indices = [56, 57, 59];
        //     let new_values = [value_after, *coinbase_wallet, *kraken_wallet];
        // //01/24/24 - removed and added:
        //     //neural_network.update_input(&indices, &new_values);
        //     //let transformed_values: Vec<f64> = new_values.iter().map(|x: &f64| x.ln()).collect();
        //     //neural_network.update_input(&indices, &transformed_values).await;
        //     let scaled_values: Vec<f64> = new_values.iter().map(|&x| x / divisor).collect();
        //     neural_network.update_input(&indices, &scaled_values).await;


        match value_after {
            Some(value) => return Ok(value),
            None => {
                //panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}, coinbase_buy_price_ask = {:?}", attempts, coinbase_sell_price_bid, coinbase_buy_price_ask);
                panic!("Failed to get a valid value after {} attempts. Final values: coinbase_sell_price_bid = {:?}", attempts, coinbase_sell_price_bid);
            }
        }
	}



//coinbase - xrp works with just changing the letters XLM or SOL to XRP - 

//kraken - xrp works with minor changes. - 

//bitstamp - xrp works with changes made just to xlm to xrp it seems like. 

//gemini - xrp works with just changing letter












